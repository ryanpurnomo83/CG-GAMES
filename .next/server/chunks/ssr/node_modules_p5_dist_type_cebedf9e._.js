module.exports = {

"[project]/node_modules/p5/dist/type/textCore.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>textCore),
    "textCoreConstants": (()=>textCoreConstants)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/p5.Renderer-CwAYZOC2.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$creating_reading$2d$D4AAKRbx$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/creating_reading-D4AAKRbx.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$color$2f$color_spaces$2f$hsb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/color/color_spaces/hsb.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$C$2d$g_eAdC$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/constants-C-g_eAdC.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$filters$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/filters.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Vector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$custom_shapes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/custom_shapes.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$States$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/States.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$utilities$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/utilities.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$file$2d$saver$2f$FileSaver$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/file-saver/FileSaver.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
/**
 * @module Typography
 * @requires core
 */ const textCoreConstants = {
    IDEOGRAPHIC: 'ideographic',
    RIGHT_TO_LEFT: 'rtl',
    LEFT_TO_RIGHT: 'ltr',
    _CTX_MIDDLE: 'middle',
    _TEXT_BOUNDS: '_textBoundsSingle',
    _FONT_BOUNDS: '_fontBoundsSingle',
    HANGING: 'hanging',
    START: 'start',
    END: 'end'
};
function textCore(p51, fn) {
    const LeadingScale = 1.275;
    const DefaultFill = '#000000';
    const LinebreakRe = /\r?\n/g;
    const CommaDelimRe = /,\s+/;
    const QuotedRe = /^".*"$/;
    const TabsRe = /\t/g;
    const FontVariationSettings = 'fontVariationSettings';
    const VariableAxes = [
        'wght',
        'wdth',
        'ital',
        'slnt',
        'opsz'
    ];
    const VariableAxesRe = new RegExp(`(?:${VariableAxes.join('|')})`);
    const textFunctions = [
        'text',
        'textAlign',
        'textAscent',
        'textDescent',
        'textLeading',
        'textMode',
        'textFont',
        'textSize',
        'textStyle',
        'textWidth',
        'textWrap',
        'textBounds',
        'textDirection',
        'textProperty',
        'textProperties',
        'fontBounds',
        'fontWidth',
        'fontAscent',
        'fontDescent',
        'textWeight'
    ];
    /**
   * Draws text to the canvas.
   *
   * The first parameter, `str`, is the text to be drawn. The second and third
   * parameters, `x` and `y`, set the coordinates of the text's bottom-left
   * corner. See <a href="#/p5/textAlign">textAlign()</a> for other ways to
   * align text.
   *
   * The fourth and fifth parameters, `maxWidth` and `maxHeight`, are optional.
   * They set the dimensions of the invisible rectangle containing the text. By
   * default, they set its  maximum width and height. See
   * <a href="#/p5/rectMode">rectMode()</a> for other ways to define the
   * rectangular text box. Text will wrap to fit within the text box. Text
   * outside of the box won't be drawn.
   *
   * Text can be styled a few ways. Call the <a href="#/p5/fill">fill()</a>
   * function to set the text's fill color. Call
   * <a href="#/p5/stroke">stroke()</a> and
   * <a href="#/p5/strokeWeight">strokeWeight()</a> to set the text's outline.
   * Call <a href="#/p5/textSize">textSize()</a> and
   * <a href="#/p5/textFont">textFont()</a> to set the text's size and font,
   * respectively.
   *
   * Note: `WEBGL` mode only supports fonts loaded with
   * <a href="#/p5/loadFont">loadFont()</a>. Calling
   * <a href="#/p5/stroke">stroke()</a> has no effect in `WEBGL` mode.
   *
   * @method text
   * @param {String|Object|Array|Number|Boolean} str text to be displayed.
   * @param {Number} x          x-coordinate of the text box.
   * @param {Number} y          y-coordinate of the text box.
   * @param {Number} [maxWidth] maximum width of the text box. See
   *                            <a href="#/p5/rectMode">rectMode()</a> for
   *                            other options.
   * @param {Number} [maxHeight] maximum height of the text box. See
   *                            <a href="#/p5/rectMode">rectMode()</a> for
   *                            other options.
   *
   * @for p5
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *   background(200);
   *   text('hi', 50, 50);
   *
   *   describe('The text "hi" written in black in the middle of a gray square.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *   background('skyblue');
   *   textSize(100);
   *   text('🌈', 0, 100);
   *
   *   describe('A rainbow in a blue sky.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *   textSize(32);
   *   fill(255);
   *   stroke(0);
   *   strokeWeight(4);
   *   text('hi', 50, 50);
   *
   *   describe('The text "hi" written in white with a black outline.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *   background('black');
   *   textSize(22);
   *   fill('yellow');
   *   text('rainbows', 6, 20);
   *   fill('cornflowerblue');
   *   text('rainbows', 6, 45);
   *   fill('tomato');
   *   text('rainbows', 6, 70);
   *   fill('limegreen');
   *   text('rainbows', 6, 95);
   *
   *   describe('The text "rainbows" written on several lines, each in a different color.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *   background(200);
   *   let s = 'The quick brown fox jumps over the lazy dog.';
   *   text(s, 10, 10, 70, 80);
   *
   *   describe('The sample text "The quick brown fox..." written in black across several lines.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *   background(200);
   *   rectMode(CENTER);
   *   let s = 'The quick brown fox jumps over the lazy dog.';
   *   text(s, 50, 50, 70, 80);
   *
   *   describe('The sample text "The quick brown fox..." written in black across several lines.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div modernizr='webgl'>
   * <code>
   * let font;
   *
   * async function setup() {
   *   createCanvas(100, 100, WEBGL);
   *   font = await loadFont('assets/inconsolata.otf');
   *   textFont(font);
   *   textSize(32);
   *   textAlign(CENTER, CENTER);
   * }
   *
   * function draw() {
   *   background(200);
   *   rotateY(frameCount / 30);
   *   text('p5*js', 0, 0);
   *
   *   describe('The text "p5*js" written in white and spinning in 3D.');
   * }
   * </code>
   * </div>
   */ /**
   * Sets the way text is aligned when <a href="#/p5/text">text()</a> is called.
   *
   * By default, calling `text('hi', 10, 20)` places the bottom-left corner of
   * the text's bounding box at (10, 20).
   *
   * The first parameter, `horizAlign`, changes the way
   * <a href="#/p5/text">text()</a> interprets x-coordinates. By default, the
   * x-coordinate sets the left edge of the bounding box. `textAlign()` accepts
   * the following values for `horizAlign`: `LEFT`, `CENTER`, or `RIGHT`.
   *
   * The second parameter, `vertAlign`, is optional. It changes the way
   * <a href="#/p5/text">text()</a> interprets y-coordinates. By default, the
   * y-coordinate sets the bottom edge of the bounding box. `textAlign()`
   * accepts the following values for `vertAlign`: `TOP`, `BOTTOM`, `CENTER`,
   * or `BASELINE`.
   *
   * @method textAlign
   * @for p5
   * @param {LEFT|CENTER|RIGHT} horizAlign horizontal alignment
   * @param {TOP|BOTTOM|CENTER|BASELINE} [vertAlign] vertical alignment
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Draw a vertical line.
   *   strokeWeight(0.5);
   *   line(50, 0, 50, 100);
   *
   *   // Top line.
   *   textSize(16);
   *   textAlign(RIGHT);
   *   text('ABCD', 50, 30);
   *
   *   // Middle line.
   *   textAlign(CENTER);
   *   text('EFGH', 50, 50);
   *
   *   // Bottom line.
   *   textAlign(LEFT);
   *   text('IJKL', 50, 70);
   *
   *   describe('The letters ABCD displayed at top-left, EFGH at center, and IJKL at bottom-right. A vertical line divides the canvas in half.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   strokeWeight(0.5);
   *
   *   // First line.
   *   line(0, 12, width, 12);
   *   textAlign(CENTER, TOP);
   *   text('TOP', 50, 12);
   *
   *   // Second line.
   *   line(0, 37, width, 37);
   *   textAlign(CENTER, CENTER);
   *   text('CENTER', 50, 37);
   *
   *   // Third line.
   *   line(0, 62, width, 62);
   *   textAlign(CENTER, BASELINE);
   *   text('BASELINE', 50, 62);
   *
   *   // Fourth line.
   *   line(0, 97, width, 97);
   *   textAlign(CENTER, BOTTOM);
   *   text('BOTTOM', 50, 97);
   *
   *   describe('The words "TOP", "CENTER", "BASELINE", and "BOTTOM" each drawn relative to a horizontal line. Their positions demonstrate different vertical alignments.');
   * }
   * </code>
   * </div>
   */ /**
   * Returns the ascent of the text.
   *
   * The `textAscent()` function calculates the distance from the baseline to the
   * highest point of the current font. This value represents the ascent, which is essential
   * for determining the overall height of the text along with `textDescent()`. If
   * a text string is provided as an argument, the ascent is calculated based on that specific
   * string; otherwise, the ascent of the current font is returned.
   *
   * @method textAscent
   * @for p5
   *
   * @param {String} [txt] - (Optional) The text string for which to calculate the ascent.
   *                         If omitted, the function returns the ascent for the current font.
   * @returns {Number} The ascent value in pixels.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(400, 300);
   *   background(220);
   *
   *   textSize(48);
   *   textAlign(LEFT, BASELINE);
   *   textFont('Georgia');
   *
   *   let s = "Hello, p5.js!";
   *   let x = 50, y = 150;
   *
   *   fill(0);
   *   text(s, x, y);
   *
   *   // Get the ascent of the current font
   *   let asc = textAscent();
   *
   *   // Draw a red line at the baseline and a blue line at the ascent position
   *   stroke('red');
   *   line(x, y, x + 200, y); // Baseline
   *   stroke('blue');
   *   line(x, y - asc, x + 200, y - asc); // Ascent (top of text)
   *
   *   noStroke();
   *   fill(0);
   *   textSize(16);
   *   text("textAscent: " + asc.toFixed(2) + " pixels", x, y - asc - 10);
   * }
   * </code>
   * </div>
   *
   *
   * @example
   * <div>
   * <code>
   * let font;
   *
   * async function setup()  {
   *   font = await loadFont('assets/inconsolata.otf');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the text.
   *   textFont(font);
   *
   *   // Different for each font.
   *   let fontScale = 0.8;
   *
   *   let baseY = 75;
   *   strokeWeight(0.5);
   *
   *   // Draw small text.
   *   textSize(24);
   *   text('dp', 0, baseY);
   *
   *   // Draw baseline and ascent.
   *   let a = textAscent() * fontScale;
   *   line(0, baseY, 23, baseY);
   *   line(23, baseY - a, 23, baseY);
   *
   *   // Draw large text.
   *   textSize(48);
   *   text('dp', 45, baseY);
   *
   *   // Draw baseline and ascent.
   *   a = textAscent() * fontScale;
   *   line(45, baseY, 91, baseY);
   *   line(91, baseY - a, 91, baseY);
   *
   *   describe('The letters "dp" written twice in different sizes. Each version has a horizontal baseline. A vertical line extends upward from each baseline to the top of the "d".');
   * }
   * </code>
   * </div>
   */ /**
   * Returns the descent of the text.
   *
   * The `textDescent()` function calculates the distance from the baseline to the
   * lowest point of the current font. This value represents the descent, which, when combined
   * with the ascent (from `textAscent()`), determines the overall vertical span of the text.
   * If a text string is provided as an argument, the descent is calculated based on that specific string;
   * otherwise, the descent of the current font is returned.
   *
   * @method textDescent
   * @for p5
   *
   * @param {String} [txt] - (Optional) The text string for which to calculate the descent.
   *                         If omitted, the function returns the descent for the current font.
   * @returns {Number} The descent value in pixels.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(400, 300);
   *   background(220);
   *
   *   textSize(48);
   *   textAlign(LEFT, BASELINE);
   *   textFont('Georgia');
   *
   *   let s = "Hello, p5.js!";
   *   let x = 50, y = 150;
   *
   *   fill(0);
   *   text(s, x, y);
   *
   *   // Get the descent of the current font
   *   let desc = textDescent();
   *
   *   // Draw a red line at the baseline and a blue line at the bottom of the text
   *   stroke('red');
   *   line(x, y, x + 200, y); // Baseline
   *   stroke('blue');
   *   line(x, y + desc, x + 200, y + desc); // Descent (bottom of text)
   *
   *   noStroke();
   *   fill(0);
   *   textSize(16);
   *   text("textDescent: " + desc.toFixed(2) + " pixels", x, y + desc + 20);
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * let font;
   *
   * async function setup()  {
   *   font = await loadFont('assets/inconsolata.otf');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the font.
   *   textFont(font);
   *
   *   // Different for each font.
   *   let fontScale = 0.9;
   *
   *   let baseY = 75;
   *   strokeWeight(0.5);
   *
   *   // Draw small text.
   *   textSize(24);
   *   text('dp', 0, baseY);
   *
   *   // Draw baseline and descent.
   *   let d = textDescent() * fontScale;
   *   line(0, baseY, 23, baseY);
   *   line(23, baseY, 23, baseY + d);
   *
   *   // Draw large text.
   *   textSize(48);
   *   text('dp', 45, baseY);
   *
   *   // Draw baseline and descent.
   *   d = textDescent() * fontScale;
   *   line(45, baseY, 91, baseY);
   *   line(91, baseY, 91, baseY + d);
   *
   *   describe('The letters "dp" written twice in different sizes. Each version has a horizontal baseline. A vertical line extends downward from each baseline to the bottom of the "p".');
   * }
   * </code>
   * </div>
   */ /**
 * Sets the spacing between lines of text when
 * <a href="#/p5/text">text()</a> is called.
 *
 * Note: Spacing is measured in pixels.
 *
 * Calling `textLeading()` without an argument returns the current spacing.
 *
 * @method textLeading
 * @for p5
 * @param {Number} leading The new text leading to apply, in pixels
 * @returns {Number} If no arguments are provided, the current text leading
 *
 * @example
 * <div>
 * <code>
 * function setup() {
 *   createCanvas(100, 100);
 *
 *   background(200);
 *
 *   // "\n" starts a new line of text.
 *   let lines = 'one\ntwo';
 *
 *   // Left.
 *   text(lines, 10, 25);
 *
 *   // Right.
 *   textLeading(30);
 *   text(lines, 70, 25);
 *
 *   describe('The words "one" and "two" written on separate lines twice. The words on the left have less vertical spacing than the words on the right.');
 * }
 * </code>
 * </div>
 */ /*
  * @method textLeading
  * @for p5
  */ /**
   * Sets the font used by the <a href="#/p5/text">text()</a> function.
   *
   * The first parameter, `font`, sets the font. `textFont()` recognizes either
   * a <a href="#/p5.Font">p5.Font</a> object or a string with the name of a
   * system font. For example, `'Courier New'`.
   *
   * The second parameter, `size`, is optional. It sets the font size in pixels.
   * This has the same effect as calling <a href="#/p5/textSize">textSize()</a>.
   *
   * Note: `WEBGL` mode only supports fonts loaded with
   * <a href="#/p5/loadFont">loadFont()</a>.
   *
   * @method textFont
   * @param {p5.Font|String|Object} font The font to apply
   * @param {Number} [size] An optional text size to apply.
   * @for p5
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *   background(200);
   *   textFont('Courier New');
   *   textSize(24);
   *   text('hi', 35, 55);
   *
   *   describe('The text "hi" written in a black, monospace font on a gray background.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *   background('black');
   *   fill('palegreen');
   *   textFont('Courier New', 10);
   *   text('You turn to the left and see a door. Do you enter?', 5, 5, 90, 90);
   *   text('>', 5, 70);
   *
   *   describe('A text prompt from a game is written in a green, monospace font on a black background.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *   background(200);
   *   textFont('Verdana');
   *   let currentFont = textFont();
   *   text(currentFont, 25, 50);
   *
   *   describe('The text "Verdana" written in a black, sans-serif font on a gray background.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * let fontRegular;
   * let fontItalic;
   * let fontBold;
   *
   * async function setup() {
   *   createCanvas(100, 100);
   *   fontRegular = await loadFont('assets/Regular.otf');
   *   fontItalic = await loadFont('assets/Italic.ttf');
   *   fontBold = await loadFont('assets/Bold.ttf');
   *
   *   background(200);
   *   textFont(fontRegular);
   *   text('I am Normal', 10, 30);
   *   textFont(fontItalic);
   *   text('I am Italic', 10, 50);
   *   textFont(fontBold);
   *   text('I am Bold', 10, 70);
   *
   *   describe('The statements "I am Normal", "I am Italic", and "I am Bold" written in black on separate lines. The statements have normal, italic, and bold fonts, respectively.');
   * }
   * </code>
   * </div>
   */ /**
   * Sets or gets the current text size.
   *
   * The `textSize()` function is used to specify the size of the text
   * that will be rendered on the canvas. When called with an argument, it sets the
   * text size to the specified value (which can be a number representing pixels or a
   * CSS-style string, e.g., '32px', '2em'). When called without an argument, it
   * returns the current text size in pixels.
   *
   * @method textSize
   * @for p5
   *
   * @param {Number} size - The size to set for the text.
   * @returns {Number} If no arguments are provided, the current text size in pixels.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(600, 200);
   *   background(240);
   *
   *   // Set the text size to 48 pixels
   *   textSize(48);
   *   textAlign(CENTER, CENTER);
   *   textFont("Georgia");
   *
   *   // Draw text using the current text size
   *   fill(0);
   *   text("Hello, p5.js!", width / 2, height / 2);
   *
   *   // Retrieve and display the current text size
   *   let currentSize = textSize();
   *   fill(50);
   *   textSize(16);
   *   text("Current text size: " + currentSize, width / 2, height - 20);
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Top.
   *   textSize(12);
   *   text('Font Size 12', 10, 30);
   *
   *   // Middle.
   *   textSize(14);
   *   text('Font Size 14', 10, 60);
   *
   *   // Bottom.
   *   textSize(16);
   *   text('Font Size 16', 10, 90);
   *
   *   describe('The text "Font Size 12" drawn small, "Font Size 14" drawn medium, and "Font Size 16" drawn large.');
   * }
   * </code>
   * </div>
   */ /**
    * @method textSize
    * @for p5
    * @returns {Number} The current text size in pixels.
    */ /**
   * Sets the style for system fonts when
   * <a href="#/p5/text">text()</a> is called.
   *
   * The parameter, `style`, can be either `NORMAL`, `ITALIC`, `BOLD`, or
   * `BOLDITALIC`.
   *
   * `textStyle()` may be overridden by CSS styling. This function doesn't
   * affect fonts loaded with <a href="#/p5/loadFont">loadFont()</a>.
   *
   * @method textStyle
   * @for p5
   * @param {NORMAL|ITALIC|BOLD|BOLDITALIC} style The style to use
   * @returns {NORMAL|ITALIC|BOLD|BOLDITALIC} If no arguments are provided, the current style
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the text.
   *   textSize(12);
   *   textAlign(CENTER);
   *
   *   // First row.
   *   textStyle(NORMAL);
   *   text('Normal', 50, 15);
   *
   *   // Second row.
   *   textStyle(ITALIC);
   *   text('Italic', 50, 40);
   *
   *   // Third row.
   *   textStyle(BOLD);
   *   text('Bold', 50, 65);
   *
   *   // Fourth row.
   *   textStyle(BOLDITALIC);
   *   text('Bold Italic', 50, 90);
   *
   *   describe('The words "Normal" displayed normally, "Italic" in italic, "Bold" in bold, and "Bold Italic" in bold italics.');
   * }
   * </code>
   * </div>
   */ /**
   * @method textStyle
   * @for p5
   * @returns {NORMAL|BOLD|ITALIC|BOLDITALIC}
   */ /**
   * Calculates the width of the given text string in pixels.
   *
   * The `textWidth()` function processes the provided text string to determine its tight bounding box
   * based on the current text properties such as font, textSize, and textStyle. Internally, it splits
   * the text into individual lines (if line breaks are present) and computes the bounding box for each
   * line using the renderer’s measurement functions. The final width is determined as the maximum width
   * among all these lines.
   *
   * For example, if the text contains multiple lines due to wrapping or explicit line breaks, textWidth()
   * will return the width of the longest line.
   *
   * @method textWidth
   * @for p5
   * @param {String} text The text to measure
   * @returns {Number} The width of the text
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(200, 200);
   *   background(220);
   *
   *   // Set text size and alignment
   *   textSize(48);
   *   textAlign(LEFT, TOP);
   *
   *   let myText = "Hello";
   *
   *   // Calculate the width of the text
   *   let tw = textWidth(myText);
   *
   *   // Draw the text on the canvas
   *   fill(0);
   *   text(myText, 50, 50);
   *
   *   // Display the text width below
   *   noStroke();
   *   fill(0);
   *   textSize(20);
   *   text("Text width: " + tw, 10, 150);
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the text.
   *   textSize(28);
   *   strokeWeight(0.5);
   *
   *   // Calculate the text width.
   *   let s = 'yoyo';
   *   let w = textWidth(s);
   *
   *   // Display the text.
   *   text(s, 22, 55);
   *
   *   // Underline the text.
   *   line(22, 55, 22 + w, 55);
   *
   *   describe('The word "yoyo" underlined.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the text.
   *   textSize(28);
   *   strokeWeight(0.5);
   *
   *   // Calculate the text width.
   *   // "\n" starts a new line.
   *   let s = 'yo\nyo';
   *   let w = textWidth(s);
   *
   *   // Display the text.
   *   text(s, 22, 55);
   *
   *   // Underline the text.
   *   line(22, 55, 22 + w, 55);
   *
   *   describe('The word "yo" written twice, one copy beneath the other. The words are divided by a horizontal line.');
   * }
   * </code>
   * </div>
   */ /**
   * Sets the style for wrapping text when
   * <a href="#/p5/text">text()</a> is called.
   *
   * The parameter, `style`, can be one of the following values:
   *
   * `WORD` starts new lines of text at spaces. If a string of text doesn't
   * have spaces, it may overflow the text box and the canvas. This is the
   * default style.
   *
   * `CHAR` starts new lines as needed to stay within the text box.
   *
   * `textWrap()` only works when the maximum width is set for a text box. For
   * example, calling `text('Have a wonderful day', 0, 10, 100)` sets the
   * maximum width to 100 pixels.
   *
   * Calling `textWrap()` without an argument returns the current style.
   *
   * @method textWrap
   * @for p5
   *
   * @param {WORD|CHAR} style The wrapping style to use
   * @returns {CHAR|WORD} If no arguments are provided, the current wrapping style
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the text.
   *   textSize(20);
   *   textWrap(WORD);
   *
   *   // Display the text.
   *   text('Have a wonderful day', 0, 10, 100);
   *
   *   describe('The text "Have a wonderful day" written across three lines.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the text.
   *   textSize(20);
   *   textWrap(CHAR);
   *
   *   // Display the text.
   *   text('Have a wonderful day', 0, 10, 100);
   *
   *   describe('The text "Have a wonderful day" written across two lines.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the text.
   *   textSize(20);
   *   textWrap(CHAR);
   *
   *   // Display the text.
   *   text('祝你有美好的一天', 0, 10, 100);
   *
   *   describe('The text "祝你有美好的一天" written across two lines.');
   * }
   * </code>
   * </div>
   */ /**
    * @method textWrap
    * @for p5
    * @returns {CHAR|WORD} The current wrapping style
    */ /**
   * Computes the tight bounding box for a block of text.
   *
   * The `textBounds()` function calculates the precise pixel boundaries that enclose
   * the rendered text based on the current text properties (such as font, textSize, textStyle, and
   * alignment). If the text spans multiple lines (due to line breaks or wrapping), the function
   * measures each line individually and then aggregates these measurements into a single bounding box.
   * The resulting object contains the x and y coordinates along with the width (w) and height (h)
   * of the text block.
   *
   * @method textBounds
   * @for p5
   *
   * @param {String} str - The text string to measure.
   * @param {Number} x - The x-coordinate where the text is drawn.
   * @param {Number} y - The y-coordinate where the text is drawn.
   * @param {Number} [width] - (Optional) The maximum width available for the text block.
   *                           When specified, the text may be wrapped to fit within this width.
   * @param {Number} [height] - (Optional) The maximum height available for the text block.
   *                            Any lines exceeding this height will be truncated.
   * @returns {Object} An object with properties `x`, `y`, `w`, and `h` that represent the tight
   *                   bounding box of the rendered text.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(300, 200);
   *   background(220);
   *
   *   // Set up text properties for clarity
   *   textSize(32);
   *   textAlign(LEFT, TOP);
   *
   *   let txt = "Hello, World!";
   *   // Compute the bounding box for the text starting at (50, 50)
   *   let bounds = textBounds(txt, 50, 50);
   *
   *   // Draw the text
   *   fill(0);
   *   text(txt, 50, 50);
   *
   *   // Draw the computed bounding box in red to visualize the measured area
   *   noFill();
   *   stroke('red');
   *   rect(bounds.x, bounds.y, bounds.w, bounds.h);
   * }
   * </code>
   * </div>
   */ /**
   * Sets or gets the text drawing direction.
   *
   * The <code>textDirection()</code> function allows you to specify the direction in which text is
   * rendered on the canvas. When provided with a <code>direction</code> parameter (such as "ltr" for
   * left-to-right, "rtl" for right-to-left, or "inherit"), it updates the renderer's state with that
   * value and applies the new setting. When called without any arguments, it returns the current text
   * direction. This function is particularly useful for rendering text in languages with different
   * writing directions.
   *
   * @method textDirection
   * @for p5
   *
   * @param {String} direction - The text direction to set ("ltr", "rtl", or "inherit").
   * @returns {String} If no arguments are provided, the current text direction, either "ltr", "rtl", or "inherit"
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(300, 300);
   *   background(240);
   *
   *   textSize(32);
   *   textFont("Georgia");
   *   textAlign(LEFT, TOP);
   *
   *   // Set text direction to right-to-left and draw Arabic text.
   *   textDirection("rtl");
   *   fill(0);
   *   text("مرحبًا!", 50, 50);
   *
   *   // Set text direction to left-to-right and draw English text.
   *   textDirection("ltr");
   *   text("Hello, p5.js!", 50, 150);
   *
   *   // Display the current text direction.
   *   textSize(16);
   *   fill(50);
   *   textAlign(LEFT, TOP);
   *   text("Current textDirection: " + textDirection(), 50, 250);
   * }
   * </code>
   * </div>
   */ /**
    * @method textDirection
    * @for p5
    * @returns {String} The current text direction, either "ltr", "rtl", or "inherit"
    */ /**
   * Sets or gets a single text property for the renderer.
   *
   * The `textProperty()` function allows you to set or retrieve a single text-related property,
   * such as `textAlign`, `textBaseline`, `fontStyle`, or any other property
   * that may be part of the renderer's state, its drawing context, or the canvas style.
   *
   * When called with a `prop` and a `value`, the function sets the property by checking
   * for its existence in the renderer's state, the drawing context, or the canvas style. If the property is
   * successfully modified, the function applies the updated text properties. If called with only the
   * `prop` parameter, the function returns the current value of that property.
   *
   * @method textProperty
   * @for p5
   *
   * @param {String} prop - The name of the text property to set or get.
   * @param value - The value to set for the specified text property. If omitted, the current
   *                      value of the property is returned
   * @returns If no arguments are provided, the current value of the specified text property
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(300, 300);
   *   background(240);
   *
   *   // Set the text alignment to CENTER and the baseline to TOP using textProperty.
   *   textProperty("textAlign", CENTER);
   *   textProperty("textBaseline", TOP);
   *
   *   // Set additional text properties and draw the text.
   *   textSize(32);
   *   textFont("Georgia");
   *   fill(0);
   *   text("Hello, World!", width / 2, 50);
   *
   *   // Retrieve and display the current text properties.
   *   let currentAlign = textProperty("textAlign");
   *   let currentBaseline = textProperty("textBaseline");
   *
   *   textSize(16);
   *   textAlign(LEFT, TOP);
   *   fill(50);
   *   text("Current textAlign: " + currentAlign, 50, 150);
   *   text("Current textBaseline: " + currentBaseline, 50, 170);
   * }
   * </code>
   * </div>
   */ /**
    * @method textProperty
    * @for p5
    * @param {String} prop - The name of the text property to set or get.
    * @returns The current value of the specified text property
    */ /**
   * Gets or sets text properties in batch, similar to calling `textProperty()`
   * multiple times.
   *
   * If an object is passed in, `textProperty(key, value)` will be called for you
   * on every key/value pair in the object.
   *
   * If no arguments are passed in, an object will be returned with all the current
   * properties.
   *
   * @method textProperties
   * @for p5
   * @param {Object} properties An object whose keys are properties to set, and whose
   *                            values are what they should be set to.
   */ /**
   * @method textProperties
   * @for p5
   * @returns {Object} An object with all the possible properties and their current values.
   */ /**
   * Computes a generic (non-tight) bounding box for a block of text.
   *
   * The `fontBounds()` function calculates the bounding box for the text based on the
   * font's intrinsic metrics (such as `fontBoundingBoxAscent` and
   * `fontBoundingBoxDescent`). Unlike `textBounds()`, which measures the exact
   * pixel boundaries of the rendered text, `fontBounds()` provides a looser measurement
   * derived from the font’s default spacing. This measurement is useful for layout purposes where
   * a consistent approximation of the text's dimensions is desired.
   *
   * @method fontBounds
   * @for p5
   *
   * @param {String} str - The text string to measure.
   * @param {Number} x - The x-coordinate where the text is drawn.
   * @param {Number} y - The y-coordinate where the text is drawn.
   * @param {Number} [width] - (Optional) The maximum width available for the text block.
   *                           When specified, the text may be wrapped to fit within this width.
   * @param {Number} [height] - (Optional) The maximum height available for the text block.
   *                            Any lines exceeding this height will be truncated.
   * @returns {Object} An object with properties `x`, `y`, `w`, and `h` representing the loose
   *                   bounding box of the text based on the font's intrinsic metrics.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(300, 200);
   *   background(240);
   *
   *   textSize(32);
   *   textAlign(LEFT, TOP);
   *   textFont('Georgia');
   *
   *   let txt = "Hello, World!";
   *   // Compute the bounding box based on the font's intrinsic metrics
   *   let bounds = fontBounds(txt, 50, 50);
   *
   *   fill(0);
   *   text(txt, 50, 50);
   *
   *   noFill();
   *   stroke('green');
   *   rect(bounds.x, bounds.y, bounds.w, bounds.h);
   *
   *   noStroke();
   *   fill(50);
   *   textSize(15);
   *   text("Font Bounds: x=" + bounds.x.toFixed(1) + ", y=" + bounds.y.toFixed(1) +
   *        ", w=" + bounds.w.toFixed(1) + ", h=" + bounds.h.toFixed(1), 8, 100);
   * }
   * </code>
   * </div>
   */ /**
   * Returns the loose width of a text string based on the current font.
   *
   * The `fontWidth()` function measures the width of the provided text string using
   * the font's default measurement (i.e., the width property from the text metrics returned by
   * the browser). Unlike `textWidth()`, which calculates the tight pixel boundaries
   * of the text glyphs, `fontWidth()` uses the font's intrinsic spacing, which may include
   * additional space for character spacing and kerning. This makes it useful for scenarios where
   * an approximate width is sufficient for layout and positioning.
   *
   * @method fontWidth
   * @for p5
   *
   * @param {String} theText - The text string to measure.
   * @returns {Number} The loose width of the text in pixels.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(300, 200);
   *   background(240);
   *
   *   textSize(32);
   *   textAlign(LEFT, TOP);
   *   textFont('Georgia');
   *
   *   let s = "Hello, World!";
   *   let fw = fontWidth(s);
   *
   *   fill(0);
   *   text(s, 50, 50);
   *
   *   stroke('blue');
   *   line(50, 90, 50 + fw, 90);
   *
   *   noStroke();
   *   fill(50);
   *   textSize(16);
   *   text("Font width: " + fw.toFixed(2) + " pixels", 50, 100);
   * }
   * </code>
   * </div>
   */ /**
   * Returns the loose ascent of the text based on the font's intrinsic metrics.
   *
   * The `fontAscent()` function calculates the ascent of the text using the font's
   * intrinsic metrics (e.g., `fontBoundingBoxAscent`). This value represents the space
   * above the baseline that the font inherently occupies, and is useful for layout purposes when
   * an approximate vertical measurement is required.
   *
   * @method fontAscent
   * @for p5
   *
   * @returns {Number} The loose ascent value in pixels.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(300, 300);
   *   background(220);
   *
   *   textSize(48);
   *   textAlign(LEFT, BASELINE);
   *   textFont('Georgia');
   *
   *   let s = "Hello, p5.js!";
   *   let x = 50, y = 150;
   *
   *   fill(0);
   *   text(s, x, y);
   *
   *   // Get the font descent of the current font
   *   let fasc = fontAscent();
   *
   *   // Draw a red line at the baseline and a blue line at the ascent position
   *   stroke('red');
   *   line(x, y, x + 200, y); // Baseline
   *   stroke('blue');
   *   line(x, y - fasc, x + 200, y - fasc); // Font ascent position
   *
   *   noStroke();
   *   fill(0);
   *   textSize(16);
   *   text("fontAscent: " + fasc.toFixed(2) + " pixels", x, y + fdesc + 20);
   * }
   * </code>
   * </div>
   */ /**
   * Returns the loose descent of the text based on the font's intrinsic metrics.
   *
   * The `fontDescent()` function calculates the descent of the text using the font's
   * intrinsic metrics (e.g., `fontBoundingBoxDescent`). This value represents the space
   * below the baseline that the font inherently occupies, and is useful for layout purposes when
   * an approximate vertical measurement is required.
   *
   * @method fontDescent
   * @for p5
   *
   * @returns {Number} The loose descent value in pixels.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(300, 300);
   *   background(220);
   *
   *   textSize(48);
   *   textAlign(LEFT, BASELINE);
   *   textFont('Georgia');
   *
   *   let s = "Hello, p5.js!";
   *   let x = 50, y = 150;
   *
   *   fill(0);
   *   text(s, x, y);
   *
   *   // Get the font descent of the current font
   *   let fdesc = fontDescent();
   *
   *   // Draw a red line at the baseline and a blue line at the descent position
   *   stroke('red');
   *   line(x, y, x + 200, y); // Baseline
   *   stroke('blue');
   *   line(x, y + fdesc, x + 200, y + fdesc); // Font descent position
   *
   *   noStroke();
   *   fill(0);
   *   textSize(16);
   *   text("fontDescent: " + fdesc.toFixed(2) + " pixels", x, y + fdesc + 20);
   * }
   * </code>
   * </div>
   */ /**
   *
   * Sets or gets the current font weight.
   *
   * The <code>textWeight()</code> function is used to specify the weight (thickness) of the text.
   * When a numeric value is provided, it sets the font weight to that value and updates the
   * rendering properties accordingly (including the "font-variation-settings" on the canvas style).
   * When called without an argument, it returns the current font weight setting.
   *
   * @method textWeight
   * @for p5
   *
   * @param {Number} weight - The numeric weight value to set for the text.
   * @returns {Number} If no arguments are provided, the current font weight
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(300, 200);
   *   background(240);
   *
   *   // Set text alignment, size, and font
   *   textAlign(LEFT, TOP);
   *   textSize(20);
   *   textFont("Georgia");
   *
   *   // Draw text with a normal weight (lighter appearance)
   *   push();
   *   textWeight(400);  // Set font weight to 400
   *   fill(0);
   *   text("Normal", 50, 50);
   *   let normalWeight = textWeight();  // Should return 400
   *   pop();
   *
   *   // Draw text with a bold weight (heavier appearance)
   *   push();
   *   textWeight(900);  // Set font weight to 900
   *   fill(0);
   *   text("Bold", 50, 100);
   *   let boldWeight = textWeight();  // Should return 900
   *   pop();
   *
   *   // Display the current font weight values on the canvas
   *   textSize(16);
   *   fill(50);
   *   text("Normal Weight: " + normalWeight, 150, 52);
   *   text("Bold Weight: " + boldWeight, 150, 100);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let font;
   *
   * async function setup() {
   *   createCanvas(100, 100);
   *   font = await loadFont(
   *     'https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100..900;1,100..900&display=swap'
   *   );
   * }
   *
   * function draw() {
   *   background(255);
   *   textFont(font);
   *   textAlign(LEFT, TOP);
   *   textSize(35);
   *   textWeight(sin(millis() * 0.002) * 200 + 400);
   *   text('p5*js', 0, 10);
   *   describe('The text p5*js pulsing its weight over time');
   * }
   * </code>
   * </div>
   */ /**
   * @method textWeight
   * @for p5
   * @returns {Number} The current font weight
   */ // attach each text func to p5, delegating to the renderer
    textFunctions.forEach((func)=>{
        fn[func] = function(...args) {
            if (!(func in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype)) {
                throw Error(`Renderer2D.prototype.${func} is not defined.`);
            }
            return this._renderer[func](...args);
        };
        // attach also to p5.Graphics.prototype
        p51.Graphics.prototype[func] = function(...args) {
            return this._renderer[func](...args);
        };
    });
    const RendererTextProps = {
        textAlign: {
            default: fn.LEFT,
            type: 'Context2d'
        },
        textBaseline: {
            default: fn.BASELINE,
            type: 'Context2d'
        },
        textFont: {
            default: {
                family: 'sans-serif'
            }
        },
        textLeading: {
            default: 15
        },
        textSize: {
            default: 12
        },
        textWrap: {
            default: fn.WORD
        },
        fontStretch: {
            default: fn.NORMAL,
            isShorthand: true
        },
        fontWeight: {
            default: fn.NORMAL,
            isShorthand: true
        },
        lineHeight: {
            default: fn.NORMAL,
            isShorthand: true
        },
        fontVariant: {
            default: fn.NORMAL,
            isShorthand: true
        },
        fontStyle: {
            default: fn.NORMAL,
            isShorthand: true
        },
        direction: {
            default: 'inherit'
        }
    };
    // note: font must be first here otherwise it may reset other properties
    const ContextTextProps = [
        'font',
        'direction',
        'fontKerning',
        'fontStretch',
        'fontVariantCaps',
        'letterSpacing',
        'textAlign',
        'textBaseline',
        'textRendering',
        'wordSpacing'
    ];
    // shorthand font properties that can be set with context2d.font
    const ShorthandFontProps = Object.keys(RendererTextProps).filter((p)=>RendererTextProps[p].isShorthand);
    // allowable values for font-stretch property for context2d.font
    const FontStretchKeys = [
        "ultra-condensed",
        "extra-condensed",
        "condensed",
        "semi-condensed",
        "normal",
        "semi-expanded",
        "expanded",
        "extra-expanded",
        "ultra-expanded"
    ];
    let contextQueue, cachedDiv; // lazy
    ////////////////////////////// start API ///////////////////////////////
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype.text = function(str, x, y, width, height) {
        let setBaseline = this.textDrawingContext().textBaseline; // store baseline
        // adjust {x,y,w,h} properties based on rectMode
        ({ x, y, width, height } = this._handleRectMode(x, y, width, height));
        // parse the lines according to width, height & linebreaks
        let lines = this._processLines(str, width, height);
        // add the adjusted positions [x,y] to each line
        lines = this._positionLines(x, y, width, height, lines);
        // render each line at the adjusted position
        lines.forEach((line)=>this._renderText(line.text, line.x, line.y));
        this.textDrawingContext().textBaseline = setBaseline; // restore baseline
    };
    /**
   * Computes the precise (tight) bounding box for a block of text
   * @param {String} str - the text to measure
   * @param {Number} x - the x-coordinate of the text
   * @param {Number} y - the y-coordinate of the text
   * @param {Number} width - the max width of the text block
   * @param {Number} height - the max height of the text block
   * @returns - a bounding box object for the text block: {x,y,w,h}
   * @private
   */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype.textBounds = function(str, x, y, width, height) {
        // delegate to _textBoundsSingle for measuring
        return this._computeBounds(textCoreConstants._TEXT_BOUNDS, str, x, y, width, height).bounds;
    };
    /**
   * Computes a generic (non-tight) bounding box for a block of text
   * @param {String} str - the text to measure
   * @param {Number} x - the x-coordinate of the text
   * @param {Number} y - the y-coordinate of the text
   * @param {Number} width - the max width of the text block
   * @param {Number} height - the max height of the text block
   * @returns - a bounding box object for the text block: {x,y,w,h}
   * @private
   */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype.fontBounds = function(str, x, y, width, height) {
        // delegate to _fontBoundsSingle for measuring
        return this._computeBounds(textCoreConstants._FONT_BOUNDS, str, x, y, width, height).bounds;
    };
    /**
   * Get the width of a text string in pixels (tight bounds)
   * @param {String} theText
   * @returns - the width of the text in pixels
   * @private
   */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype.textWidth = function(theText) {
        let lines = this._processLines(theText);
        // return the max width of the lines (using tight bounds)
        return Math.max(...lines.map((l)=>this._textWidthSingle(l)));
    };
    /**
   * Get the width of a text string in pixels (loose bounds)
   * @param {String} theText
   * @returns - the width of the text in pixels
   * @private
   */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype.fontWidth = function(theText) {
        // return the max width of the lines (using loose bounds)
        let lines = this._processLines(theText);
        return Math.max(...lines.map((l)=>this._fontWidthSingle(l)));
    };
    /**
   * @param {*} txt - optional text to measure, if provided will be
   * used to compute the ascent, otherwise the font's ascent will be used
   * @returns - the ascent of the text
   * @private
   */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype.textAscent = function(txt = '') {
        if (!txt.length) return this.fontAscent();
        return this.textDrawingContext().measureText(txt).actualBoundingBoxAscent;
    };
    /**
   * @returns - returns the ascent for the current font
   * @private
   */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype.fontAscent = function() {
        return this.textDrawingContext().measureText('_').fontBoundingBoxAscent;
    };
    /**
   * @param {*} txt - optional text to measure, if provided will
   * be used to compute the descent, otherwise the font's descent will be used
   * @returns - the descent of the text
   * @private
   */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype.textDescent = function(txt = '') {
        if (!txt.length) return this.fontDescent();
        return this.textDrawingContext().measureText(txt).actualBoundingBoxDescent;
    };
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype.fontDescent = function() {
        return this.textDrawingContext().measureText('_').fontBoundingBoxDescent;
    };
    // setters/getters for text properties //////////////////////////
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype.textAlign = function(h, v) {
        // the setter
        if (typeof h !== 'undefined') {
            this.states.setValue('textAlign', h);
            if (typeof v !== 'undefined') {
                if (v === fn.CENTER) {
                    v = textCoreConstants._CTX_MIDDLE;
                }
                this.states.setValue('textBaseline', v);
            }
            return this._applyTextProperties();
        }
        // the getter
        return {
            horizontal: this.states.textAlign,
            vertical: this.states.textBaseline
        };
    };
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._currentTextFont = function() {
        return this.states.textFont.font || this.states.textFont.family;
    };
    /**
   * Set the font and [size] and [options] for rendering text
   * @param {p5.Font | string} font - the font to use for rendering text
   * @param {Number} size - the size of the text, can be a number or a css-style string
   * @param {Object} options - additional options for rendering text, see FontProps
   * @private
   */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype.textFont = function(font, size, options1) {
        if (arguments.length === 0) {
            return this._currentTextFont();
        }
        let family = font;
        // do we have a custon loaded font ?
        if (font instanceof p51.Font) {
            family = font.face.family;
        } else if (font.data instanceof Uint8Array) {
            family = font.name.fontFamily;
            if (font.name?.fontSubfamily) {
                family += '-' + font.name.fontSubfamily;
            }
        } else if (typeof font === 'string') {
            // direct set the font-string if it contains size
            if (typeof size === 'undefined' && /[.0-9]+(%|em|p[xt])/.test(family)) {
                //console.log('direct set font-string: ', family);
                ({ family, size } = this._directSetFontString(family));
            }
        }
        if (typeof family !== 'string') throw Error('null font in textFont()');
        // handle two-arg case: textFont(font, options)
        if (arguments.length === 2 && typeof size === 'object') {
            options1 = size;
            size = undefined;
        }
        // update font properties in this.states
        this.states.setValue('textFont', {
            font,
            family,
            size
        });
        // convert/update the size in this.states
        if (typeof size !== 'undefined') {
            this._setTextSize(size);
        }
        // apply any options to this.states
        if (typeof options1 === 'object') {
            this.textProperties(options1);
        }
        return this._applyTextProperties();
    };
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._directSetFontString = function(font, debug = 0) {
        if (debug) console.log('_directSetFontString"' + font + '"');
        let defaults = ShorthandFontProps.reduce((props, p)=>{
            props[p] = RendererTextProps[p].default;
            return props;
        }, {});
        let el = this._cachedDiv(defaults);
        el.style.font = font;
        let style = getComputedStyle(el);
        ShorthandFontProps.forEach((prop)=>{
            this.states[prop] = style[prop];
            if (debug) console.log('  this.states.' + prop + '="' + style[prop] + '"');
        });
        return {
            family: style.fontFamily,
            size: style.fontSize
        };
    };
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype.textLeading = function(leading) {
        // the setter
        if (typeof leading === 'number') {
            this.states.setValue('leadingSet', true);
            this.states.setValue('textLeading', leading);
            return this._applyTextProperties();
        }
        // the getter
        return this.states.textLeading;
    };
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype.textWeight = function(weight) {
        // the setter
        if (typeof weight === 'number') {
            this.states.setValue('fontWeight', weight);
            this._applyTextProperties();
            // Safari works without weight set in the canvas style attribute, and actually
            // has buggy behavior if it is present, using the wrong weight when drawing
            // multiple times with different weights
            if (!p51.prototype._isSafari()) {
                this._setCanvasStyleProperty('font-variation-settings', `"wght" ${weight}`);
            }
            return;
        }
        // the getter
        return this.states.fontWeight;
    };
    /**
   * @param {*} size - the size of the text, can be a number or a css-style string
   * @private
   */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype.textSize = function(size) {
        // the setter
        if (typeof size !== 'undefined') {
            this._setTextSize(size);
            return this._applyTextProperties();
        }
        // the getter
        return this.states.textSize;
    };
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype.textStyle = function(style) {
        // the setter
        if (typeof style !== 'undefined') {
            this.states.setValue('fontStyle', style);
            return this._applyTextProperties();
        }
        // the getter
        return this.states.fontStyle;
    };
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype.textWrap = function(wrapStyle) {
        if (wrapStyle === fn.WORD || wrapStyle === fn.CHAR) {
            this.states.setValue('textWrap', wrapStyle);
            // no need to apply text properties here as not a context property
            return this._pInst;
        }
        return this.states.textWrap;
    };
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype.textDirection = function(direction) {
        if (typeof direction !== 'undefined') {
            this.states.setValue('direction', direction);
            return this._applyTextProperties();
        }
        return this.states.direction;
    };
    /**
   * Sets/gets a single text property for the renderer (eg. fontStyle, fontStretch, etc.)
   * The property to be set can be a mapped or unmapped property on `this.states` or a property
   * on `this.textDrawingContext()` or on `this.canvas.style`
   * The property to get can exist in `this.states` or `this.textDrawingContext()` or `this.canvas.style`
   * @private
   */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype.textProperty = function(prop, value, opts) {
        let modified = false, debug = opts?.debug || false;
        // getter: return option from this.states or this.textDrawingContext()
        if (typeof value === 'undefined') {
            let props = this.textProperties();
            if (prop in props) return props[prop];
            throw Error('Unknown text option "' + prop + '"'); // FES?
        }
        // set the option in this.states if it exists
        if (prop in this.states && this.states[prop] !== value) {
            this.states[prop] = value;
            modified = true;
            if (debug) {
                console.log('this.states.' + prop + '="' + options[prop] + '"');
            }
        } else if (prop in this.textDrawingContext()) {
            this._setContextProperty(prop, value, debug);
            modified = true;
        } else if (prop in this.textCanvas().style) {
            this._setCanvasStyleProperty(prop, value, debug);
            modified = true;
        } else {
            console.warn('Ignoring unknown text option: "' + prop + '"\n'); // FES?
        }
        return modified ? this._applyTextProperties() : this._pInst;
    };
    /**
   * Batch set/get text properties for the renderer.
   * The properties can be either on `states` or `drawingContext`
   * @private
   */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype.textProperties = function(properties) {
        // setter
        if (typeof properties !== 'undefined') {
            Object.keys(properties).forEach((opt)=>{
                this.textProperty(opt, properties[opt]);
            });
            return this._pInst;
        }
        // getter: get props from drawingContext
        let context = this.textDrawingContext();
        properties = ContextTextProps.reduce((props, p)=>{
            props[p] = context[p];
            return props;
        }, {});
        // add renderer props
        Object.keys(RendererTextProps).forEach((p)=>{
            if (RendererTextProps[p]?.type === 'Context2d') {
                properties[p] = context[p];
            } else {
                if (p === 'textFont') {
                    // avoid circular ref. inside textFont
                    let current = this._currentTextFont();
                    if (typeof current === 'object' && '_pInst' in current) {
                        current = Object.assign({}, current);
                        delete current._pInst;
                    }
                    properties[p] = current;
                } else {
                    properties[p] = this.states[p];
                }
            }
        });
        return properties;
    };
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype.textMode = function() {};
    /////////////////////////////// end API ////////////////////////////////
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._currentTextFont = function() {
        return this.states.textFont.font || this.states.textFont.family;
    };
    /*
    Compute the bounds for a block of text based on the specified
    measure function, either _textBoundsSingle or _fontBoundsSingle
   * @private
  */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._computeBounds = function(type, str, x, y, width, height, opts) {
        let context = this.textDrawingContext();
        let setBaseline = context.textBaseline;
        let { textLeading, textAlign } = this.states;
        // adjust width, height based on current rectMode
        ({ width, height } = this._rectModeAdjust(x, y, width, height));
        // parse the lines according to the width & linebreaks
        let lines = this._processLines(str, width, height);
        // get the adjusted positions [x,y] for each line
        let boxes = lines.map((line, i)=>this[type].bind(this)(line, x, y + i * textLeading));
        // adjust the bounding boxes based on horiz. text alignment
        if (lines.length > 1) {
            // Call the 2D mode version: the WebGL mode version does additional
            // alignment adjustments to account for how WebGL renders text.
            boxes.forEach((bb)=>bb.x += p51.Renderer2D.prototype._xAlignOffset.call(this, textAlign, width));
        }
        // adjust the bounding boxes based on vert. text alignment
        if (typeof height !== 'undefined') {
            // Call the 2D mode version: the WebGL mode version does additional
            // alignment adjustments to account for how WebGL renders text.
            p51.Renderer2D.prototype._yAlignOffset.call(this, boxes, height);
        }
        // get the bounds for the text block
        let bounds = boxes[0];
        if (lines.length > 1) {
            // get the bounds for the multi-line text block
            bounds = this._aggregateBounds(boxes);
            // align the multi-line bounds
            if (!opts?.ignoreRectMode) {
                this._rectModeAlign(bounds, width || 0, height || 0);
            }
        }
        context.textBaseline = setBaseline; // restore baseline
        return {
            bounds,
            lines
        };
    };
    /*
    Adjust width, height of bounds based on current rectMode
   * @private
  */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._rectModeAdjust = function(x, y, width, height) {
        if (typeof width !== 'undefined') {
            switch(this.states.rectMode){
                case fn.CENTER:
                    break;
                case fn.CORNERS:
                    width -= x;
                    height -= y;
                    break;
                case fn.RADIUS:
                    width *= 2;
                    height *= 2;
                    break;
            }
        }
        return {
            x,
            y,
            width,
            height
        };
    };
    /*
    Attempts to set a property directly on the canvas.style object
   * @private
  */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._setCanvasStyleProperty = function(opt, val, debug) {
        let value = val.toString(); // ensure its a string
        if (debug) console.log('canvas.style.' + opt + '="' + value + '"');
        // handle variable fonts options
        if (opt === FontVariationSettings) {
            this._handleFontVariationSettings(value);
        }
        // lets try to set it on the canvas style
        this.textCanvas().style[opt] = value;
        // check if the value was set successfully
        if (this.textCanvas().style[opt] !== value) ;
    };
    /*
    Parses the fontVariationSettings string and sets the font properties, only font-weight
    working consistently across browsers at present
   * @private
  */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._handleFontVariationSettings = function(value, debug = false) {
        // check if the value is a string or an object
        if (typeof value === 'object') {
            value = Object.keys(value).map((k)=>k + ' ' + value[k]).join(', ');
        }
        let values = value.split(CommaDelimRe);
        values.forEach((v)=>{
            v = v.replace(/["']/g, ''); // remove quotes
            let matches = VariableAxesRe.exec(v);
            //console.log('matches: ', matches);
            if (matches && matches.length) {
                let axis = matches[0];
                // get the value to 3 digits of precision with no trailing zeros
                let val = parseFloat(parseFloat(v.replace(axis, '').trim()).toFixed(3));
                switch(axis){
                    case 'wght':
                        if (debug) console.log('setting font-weight=' + val);
                        // manually set the font-weight via the font string
                        if (this.states.fontWeight !== val) this.textWeight(val);
                        return val;
                    case 'wdth':
                        break;
                    case 'ital':
                        if (debug) console.log('setting font-style=' + (val ? 'italic' : 'normal'));
                        break;
                    case 'slnt':
                        if (debug) console.log('setting font-style=' + (val ? 'oblique' : 'normal'));
                        break;
                    case 'opsz':
                        if (debug) console.log('setting font-optical-size=' + val);
                        break;
                }
            }
        });
    };
    /*
    For properties not directly managed by the renderer in this.states
      we check if it has a mapping to a property in this.states
    Otherwise, add the property to the context-queue for later application
  */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._setContextProperty = function(prop, val, debug = false) {
        // check if the value is actually different, else short-circuit
        if (this.textDrawingContext()[prop] === val) {
            return this._pInst;
        }
        // otherwise, we will set the property directly on the `this.textDrawingContext()`
        // by adding [property, value] to context-queue for later application
        (contextQueue ??= []).push([
            prop,
            val
        ]);
        if (debug) console.log('queued context2d.' + prop + '="' + val + '"');
    };
    /*
     Adjust parameters (x,y,w,h) based on current rectMode
  */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._handleRectMode = function(x, y, width, height) {
        let rectMode = this.states.rectMode;
        if (typeof width !== 'undefined') {
            switch(rectMode){
                case fn.RADIUS:
                    width *= 2;
                    x -= width / 2;
                    if (typeof height !== 'undefined') {
                        height *= 2;
                        y -= height / 2;
                    }
                    break;
                case fn.CENTER:
                    x -= width / 2;
                    if (typeof height !== 'undefined') {
                        y -= height / 2;
                    }
                    break;
                case fn.CORNERS:
                    width -= x;
                    if (typeof height !== 'undefined') {
                        height -= y;
                    }
                    break;
            }
        }
        return {
            x,
            y,
            width,
            height
        };
    };
    /*
    Get the computed font-size in pixels for a given size string
    @param {String} size - the font-size string to compute
    @returns {number} - the computed font-size in pixels
   * @private
   */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._fontSizePx = function(theSize, { family } = this.states.textFont) {
        const isNumString = (num)=>!isNaN(num) && num.trim() !== '';
        // check for a number in a string, eg '12'
        if (isNumString(theSize)) {
            return parseFloat(theSize);
        }
        let ele = this._cachedDiv({
            fontSize: theSize
        });
        ele.style.fontSize = theSize;
        ele.style.fontFamily = family;
        let fontSizeStr = getComputedStyle(ele).fontSize;
        let fontSize = parseFloat(fontSizeStr);
        if (typeof fontSize !== 'number') {
            throw Error('textSize: invalid font-size');
        }
        return fontSize;
    };
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._cachedDiv = function(props) {
        if (typeof cachedDiv === 'undefined') {
            let ele = document.createElement('div');
            ele.ariaHidden = 'true';
            ele.style.display = 'none';
            Object.entries(props).forEach(([prop, val])=>{
                ele.style[prop] = val;
            });
            this.textCanvas().appendChild(ele);
            cachedDiv = ele;
        }
        return cachedDiv;
    };
    /*
    Aggregate the bounding boxes of multiple lines of text
    @param {Array} bboxes - the bounding boxes to aggregate
    @returns {object} - the aggregated bounding box
   * @private
  */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._aggregateBounds = function(bboxes) {
        // loop over the bounding boxes to get the min/max x/y values
        let minX = Math.min(...bboxes.map((b)=>b.x));
        let minY = Math.min(...bboxes.map((b)=>b.y));
        let maxY = Math.max(...bboxes.map((b)=>b.y + b.h));
        let maxX = Math.max(...bboxes.map((b)=>b.x + b.w));
        return {
            x: minX,
            y: minY,
            w: maxX - minX,
            h: maxY - minY
        };
    };
    // Renderer.prototype._aggregateBounds = function (tx, ty, bboxes) {
    //   let x = Math.min(...bboxes.map(b => b.x));
    //   let y = Math.min(...bboxes.map(b => b.y));
    //   // the width is the max of the x-offset + the box width
    //   let w = Math.max(...bboxes.map(b => (b.x - tx) + b.w));
    //   let h = bboxes[bboxes.length - 1].y - bboxes[0].y + bboxes[bboxes.length - 1].h;
    //   return { x, y, w, h };
    // };
    /*
    Process the text string to handle line-breaks and text wrapping
    @param {String} str - the text to process
    @param {Number} width - the width to wrap the text to
    @returns {array} - the processed lines of text
   * @private
  */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._processLines = function(str, width, height) {
        if (typeof width !== 'undefined') {
            let drawingContext = this.textDrawingContext();
            if (drawingContext.textBaseline === fn.BASELINE) {
                this.drawingContext.textBaseline = fn.TOP;
            }
        }
        let lines = this._splitOnBreaks(str.toString());
        let hasLineBreaks = lines.length > 1;
        let hasWidth = typeof width !== 'undefined';
        let exceedsWidth = hasWidth && lines.some((l)=>this._textWidthSingle(l) > width);
        let { textLeading: leading, textWrap } = this.states;
        //if (!hasLineBreaks && !exceedsWidth) return lines; // a single-line
        if (hasLineBreaks || exceedsWidth) {
            if (hasWidth) lines = this._lineate(textWrap, lines, width);
        }
        // handle height truncation
        if (hasWidth && typeof height !== 'undefined') {
            if (typeof leading === 'undefined') {
                throw Error('leading is required if height is specified');
            }
            // truncate lines that exceed the height
            for(let i = 0; i < lines.length; i++){
                let lh = leading * (i + 1);
                if (lh > height) {
                    //console.log('TRUNCATING: ', i, '-', lines.length, '"' + lines.slice(i) + '"');
                    lines = lines.slice(0, i);
                    break;
                }
            }
        }
        return lines;
    };
    /*
    Get the x-offset for text given the width and textAlign property
  */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._xAlignOffset = function(textAlign, width) {
        switch(textAlign){
            case fn.LEFT:
                return 0;
            case fn.CENTER:
                return width / 2;
            case fn.RIGHT:
                return width;
            case textCoreConstants.START:
                return 0;
            case textCoreConstants.END:
                throw new Error('textBounds: END not yet supported for textAlign');
            default:
                return 0;
        }
    };
    /*
    Align the bounding box based on the current rectMode setting
  */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._rectModeAlign = function(bb, width, height) {
        if (typeof width !== 'undefined') {
            switch(this.states.rectMode){
                case fn.CENTER:
                    bb.x -= (width - bb.w) / 2;
                    bb.y -= (height - bb.h) / 2;
                    break;
                case fn.CORNERS:
                    bb.w += bb.x;
                    bb.h += bb.y;
                    break;
                case fn.RADIUS:
                    bb.x -= (width - bb.w) / 2;
                    bb.y -= (height - bb.h) / 2;
                    bb.w /= 2;
                    bb.h /= 2;
                    break;
            }
            return bb;
        }
    };
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._rectModeAlignRevert = function(bb, width, height) {
        if (typeof width !== 'undefined') {
            switch(this.states.rectMode){
                case fn.CENTER:
                    bb.x += (width - bb.w) / 2;
                    bb.y += (height - bb.h) / 2;
                    break;
                case fn.CORNERS:
                    bb.w -= bb.x;
                    bb.h -= bb.y;
                    break;
                case fn.RADIUS:
                    bb.x += (width - bb.w) / 2;
                    bb.y += (height - bb.h) / 2;
                    bb.w *= 2;
                    bb.h *= 2;
                    break;
            }
            return bb;
        }
    };
    /*
    Get the (tight) width of a single line of text
  */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._textWidthSingle = function(s) {
        let metrics = this.textDrawingContext().measureText(s);
        let abl = metrics.actualBoundingBoxLeft;
        let abr = metrics.actualBoundingBoxRight;
        return abr + abl;
    };
    /*
    Get the (loose) width of a single line of text as specified by the font
  */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._fontWidthSingle = function(s) {
        return this.textDrawingContext().measureText(s).width;
    };
    /*
    Get the (tight) bounds of a single line of text based on its actual bounding box
  */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._textBoundsSingle = function(s, x = 0, y = 0) {
        let metrics = this.textDrawingContext().measureText(s);
        let asc = metrics.actualBoundingBoxAscent;
        let desc = metrics.actualBoundingBoxDescent;
        let abl = metrics.actualBoundingBoxLeft;
        let abr = metrics.actualBoundingBoxRight;
        return {
            x: x - abl,
            y: y - asc,
            w: abr + abl,
            h: asc + desc
        };
    };
    /*
    Get the (loose) bounds of a single line of text based on its font's bounding box
  */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._fontBoundsSingle = function(s, x = 0, y = 0) {
        let metrics = this.textDrawingContext().measureText(s);
        let asc = metrics.fontBoundingBoxAscent;
        let desc = metrics.fontBoundingBoxDescent;
        x -= this._xAlignOffset(this.states.textAlign, metrics.width);
        return {
            x,
            y: y - asc,
            w: metrics.width,
            h: asc + desc
        };
    };
    /*
    Set the textSize property in `this.states` if it has changed
    @param {number | string} theSize - the font-size to set
    @returns {boolean} - true if the size was changed, false otherwise
   */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._setTextSize = function(theSize) {
        if (typeof theSize === 'string') {
            // parse the size string via computed style, eg '2em'
            theSize = this._fontSizePx(theSize);
        }
        // should be a number now
        if (typeof theSize === 'number') {
            // set it in `this.states` if its been changed
            if (this.states.textSize !== theSize) {
                this.states.setValue('textSize', theSize);
                // handle leading here, if not set otherwise
                if (!this.states.leadingSet) {
                    this.states.setValue('textLeading', this.states.textSize * LeadingScale);
                }
                return true; // size was changed
            }
        } else {
            console.warn('textSize: invalid size: ' + theSize);
        }
        return false;
    };
    /*
    Split the lines of text based on the width and the textWrap property
    @param {Array} lines - the lines of text to split
    @param {Number} maxWidth - the maximum width of the lines
    @param {Object} opts - additional options for splitting the lines
    @returns {array} - the split lines of text
   * @private
  */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._lineate = function(textWrap, lines, maxWidth = Infinity, opts = {}) {
        let splitter = opts.splitChar ?? (textWrap === fn.WORD ? ' ' : '');
        let line, testLine, testWidth, words, newLines = [];
        for(let lidx = 0; lidx < lines.length; lidx++){
            line = '';
            words = lines[lidx].split(splitter);
            for(let widx = 0; widx < words.length; widx++){
                testLine = `${line + words[widx]}` + splitter;
                testWidth = this._textWidthSingle(testLine);
                if (line.length > 0 && testWidth > maxWidth) {
                    newLines.push(line.trim());
                    line = `${words[widx]}` + splitter;
                } else {
                    line = testLine;
                }
            }
            newLines.push(line.trim());
        }
        return newLines;
    };
    /*
    Split the text into lines based on line-breaks and tabs
  */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._splitOnBreaks = function(s) {
        if (!s || s.length === 0) return [
            ''
        ];
        return s.replace(TabsRe, '  ').split(LinebreakRe);
    };
    /*
    Parse the font-family string to handle complex names, fallbacks, etc.
  */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._parseFontFamily = function(familyStr) {
        let parts = familyStr.split(CommaDelimRe);
        let family = parts.map((part)=>{
            part = part.trim();
            if (part.indexOf(' ') > -1 && !QuotedRe.test(part)) {
                part = `"${part}"`; // quote font names with spaces
            }
            return part;
        }).join(', ');
        return family;
    };
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._applyFontString = function() {
        /*
      Create the font-string according to the CSS font-string specification:
      If font is specified as a shorthand for several font-related properties, then:
      - it must include values for: <font-size> and <font-family>
      - it may optionally include values for:
          [<font-style>, <font-variant>, <font-weight>, <font-stretch>, <line-height>]
      Format:
      - font-style, font-variant and font-weight must precede font-size
      - font-variant may only specify the values defined in CSS 2.1, that is 'normal' and 'small-caps'.
      - font-stretch may only be a single keyword value.
      - line-height must immediately follow font-size, preceded by "/", eg 16px/3.
      - font-family must be the last value specified.
    */ let { textFont, textSize, lineHeight, fontStyle, fontWeight, fontVariant } = this.states;
        let drawingContext = this.textDrawingContext();
        let family = this._parseFontFamily(textFont.family);
        let style = fontStyle !== fn.NORMAL ? `${fontStyle} ` : '';
        let weight = fontWeight !== fn.NORMAL ? `${fontWeight} ` : '';
        let variant = fontVariant !== fn.NORMAL ? `${fontVariant} ` : '';
        let fsize = `${textSize}px` + (lineHeight !== fn.NORMAL ? `/${lineHeight} ` : ' ');
        let fontString = `${style}${variant}${weight}${fsize}${family}`.trim();
        //console.log('fontString="' + fontString + '"');
        // set the font string on the context
        drawingContext.font = fontString;
        // verify that it was set successfully
        if (drawingContext.font !== fontString) {
            let expected = fontString;
            let actual = drawingContext.font;
            if (expected !== actual) {
                //console.warn(`Unable to set font property on context2d. It may not be supported.`);
                //console.log('Expected "' + expected + '" but got: "' + actual + '"'); // TMP
                return false;
            }
        }
        return true;
    };
    /*
    Apply the text properties in `this.states` to the `this.textDrawingContext()`
    Then apply any properties in the context-queue
   */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._applyTextProperties = function(debug = false) {
        this._applyFontString();
        // set these after the font so they're not overridden
        let context = this.textDrawingContext();
        context.direction = this.states.direction;
        context.textAlign = this.states.textAlign;
        context.textBaseline = this.states.textBaseline;
        // set manually as (still) not fully supported as part of font-string
        let stretch = this.states.fontStretch;
        if (FontStretchKeys.includes(stretch) && context.fontStretch !== stretch) {
            context.fontStretch = stretch;
        }
        // apply each property in queue after the font so they're not overridden
        while(contextQueue?.length){
            let [prop, val] = contextQueue.shift();
            if (debug) console.log('apply context property "' + prop + '" = "' + val + '"');
            context[prop] = val;
            // check if the value was set successfully
            if (context[prop] !== val) {
                console.warn(`Unable to set '${prop}' property on context2d. It may not be supported.`); // FES?
                console.log('Expected "' + val + '" but got: "' + context[prop] + '"');
            }
        }
        return this._pInst;
    };
    if (p51.Renderer2D) {
        p51.Renderer2D.prototype.textCanvas = function() {
            return this.canvas;
        };
        p51.Renderer2D.prototype.textDrawingContext = function() {
            return this.drawingContext;
        };
        p51.Renderer2D.prototype._renderText = function(text, x, y, maxY, minY) {
            let states = this.states;
            let context = this.textDrawingContext();
            if (y < minY || y >= maxY) {
                return; // don't render lines beyond minY/maxY
            }
            this.push();
            // no stroke unless specified by user
            if (states.strokeColor && states.strokeSet) {
                context.strokeText(text, x, y);
            }
            if (!this._clipping && states.fillColor) {
                // if fill hasn't been set by user, use default text fill
                if (!states.fillSet) {
                    this._setFill(DefaultFill);
                }
                context.fillText(text, x, y);
            }
            this.pop();
        };
        /*
      Position the lines of text based on their textAlign/textBaseline properties
    */ p51.Renderer2D.prototype._positionLines = function(x, y, width, height, lines) {
            let { textLeading, textAlign } = this.states;
            let adjustedX, lineData = new Array(lines.length);
            let adjustedW = typeof width === 'undefined' ? 0 : width;
            let adjustedH = typeof height === 'undefined' ? 0 : height;
            for(let i = 0; i < lines.length; i++){
                switch(textAlign){
                    case textCoreConstants.START:
                        throw new Error('textBounds: START not yet supported for textAlign'); // default to LEFT
                    case fn.LEFT:
                        adjustedX = x;
                        break;
                    case fn.CENTER:
                        adjustedX = x + adjustedW / 2;
                        break;
                    case fn.RIGHT:
                        adjustedX = x + adjustedW;
                        break;
                    case textCoreConstants.END:
                        throw new Error('textBounds: END not yet supported for textAlign');
                }
                lineData[i] = {
                    text: lines[i],
                    x: adjustedX,
                    y: y + i * textLeading
                };
            }
            return this._yAlignOffset(lineData, adjustedH);
        };
        /*
      Get the y-offset for text given the height, leading, line-count and textBaseline property
    */ p51.Renderer2D.prototype._yAlignOffset = function(dataArr, height) {
            if (typeof height === 'undefined') {
                throw Error('_yAlignOffset: height is required');
            }
            let { textLeading, textBaseline } = this.states;
            let yOff = 0, numLines = dataArr.length;
            let ydiff = height - textLeading * (numLines - 1);
            switch(textBaseline){
                case fn.TOP:
                    break; // ??
                case fn.BASELINE:
                    break;
                case textCoreConstants._CTX_MIDDLE:
                    yOff = ydiff / 2;
                    break;
                case fn.BOTTOM:
                    yOff = ydiff;
                    break;
                case textCoreConstants.IDEOGRAPHIC:
                    console.warn('textBounds: IDEOGRAPHIC not yet supported for textBaseline'); // FES?
                    break;
                case textCoreConstants.HANGING:
                    console.warn('textBounds: HANGING not yet supported for textBaseline'); // FES?
                    break;
            }
            dataArr.forEach((ele)=>ele.y += yOff);
            return dataArr;
        };
    }
    if (p51.RendererGL) {
        p51.RendererGL.prototype.textCanvas = function() {
            if (!this._textCanvas) {
                this._textCanvas = document.createElement('canvas');
                this._textCanvas.width = 1;
                this._textCanvas.height = 1;
                this._textCanvas.style.display = 'none';
                // Has to be added to the DOM for measureText to work properly!
                this.canvas.parentElement.insertBefore(this._textCanvas, this.canvas);
            }
            return this._textCanvas;
        };
        p51.RendererGL.prototype.textDrawingContext = function() {
            if (!this._textDrawingContext) {
                const textCanvas = this.textCanvas();
                this._textDrawingContext = textCanvas.getContext('2d');
            }
            return this._textDrawingContext;
        };
        const oldRemove = p51.RendererGL.prototype.remove;
        p51.RendererGL.prototype.remove = function() {
            if (this._textCanvas) {
                this._textCanvas.parentElement.removeChild(this._textCanvas);
            }
            oldRemove.call(this);
        };
        p51.RendererGL.prototype._positionLines = function(x, y, width, height, lines) {
            let { textLeading, textAlign } = this.states;
            const widths = lines.map((line)=>this._fontWidthSingle(line));
            let adjustedX, lineData = new Array(lines.length);
            let adjustedW = typeof width === 'undefined' ? Math.max(0, ...widths) : width;
            let adjustedH = typeof height === 'undefined' ? 0 : height;
            for(let i = 0; i < lines.length; i++){
                switch(textAlign){
                    case textCoreConstants.START:
                        throw new Error('textBounds: START not yet supported for textAlign'); // default to LEFT
                    case fn.LEFT:
                        adjustedX = x;
                        break;
                    case fn.CENTER:
                        adjustedX = x + (adjustedW - widths[i]) / 2 - adjustedW / 2 + (width || 0) / 2;
                        break;
                    case fn.RIGHT:
                        adjustedX = x + adjustedW - widths[i] - adjustedW + (width || 0);
                        break;
                    case textCoreConstants.END:
                        throw new Error('textBounds: END not yet supported for textAlign');
                }
                lineData[i] = {
                    text: lines[i],
                    x: adjustedX,
                    y: y + i * textLeading
                };
            }
            return this._yAlignOffset(lineData, adjustedH);
        };
        p51.RendererGL.prototype._yAlignOffset = function(dataArr, height) {
            if (typeof height === 'undefined') {
                throw Error('_yAlignOffset: height is required');
            }
            let { textLeading, textBaseline, textSize, textFont } = this.states;
            let yOff = 0, numLines = dataArr.length;
            let totalHeight = textSize * numLines + (textLeading - textSize) * (numLines - 1);
            switch(textBaseline){
                case fn.TOP:
                    yOff = textSize;
                    break;
                case fn.BASELINE:
                    break;
                case textCoreConstants._CTX_MIDDLE:
                    yOff = -totalHeight / 2 + textSize + (height || 0) / 2;
                    break;
                case fn.BOTTOM:
                    yOff = -(totalHeight - textSize) + (height || 0);
                    break;
                default:
                    console.warn(`${textBaseline} is not supported in WebGL mode.`); // FES?
                    break;
            }
            yOff += this.states.textFont.font?._verticalAlign(textSize) || 0; // Does this function exist?
            dataArr.forEach((ele)=>ele.y += yOff);
            return dataArr;
        };
    }
}
if (typeof p5 !== 'undefined') {
    textCore(p5, p5.prototype);
}
;
}}),
"[project]/node_modules/p5/dist/type/unicodeRanges.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// From https://github.com/radiovisual/unicode-range-json,
// with decimal ranges removed to save space, and with category
// names converted to lowercase ahead of time
__turbopack_context__.s({
    "unicodeRanges": (()=>unicodeRanges)
});
const unicodeRanges = [
    {
        category: "control character",
        hexrange: [
            "0000",
            "001f"
        ]
    },
    {
        category: "basic latin",
        hexrange: [
            "0000",
            "007f"
        ]
    },
    {
        category: "latin-1 supplement",
        hexrange: [
            "0080",
            "00ff"
        ]
    },
    {
        category: "latin extended-a",
        hexrange: [
            "0100",
            "017f"
        ]
    },
    {
        category: "latin extended-b",
        hexrange: [
            "0180",
            "024f"
        ]
    },
    {
        category: "ipa extensions",
        hexrange: [
            "0250",
            "02af"
        ]
    },
    {
        category: "spacing modifier letters",
        hexrange: [
            "02b0",
            "02ff"
        ]
    },
    {
        category: "combining diacritical marks",
        hexrange: [
            "0300",
            "036f"
        ]
    },
    {
        category: "greek and coptic",
        hexrange: [
            "0370",
            "03ff"
        ]
    },
    {
        category: "cyrillic",
        hexrange: [
            "0400",
            "04ff"
        ]
    },
    {
        category: "cyrillic supplement",
        hexrange: [
            "0500",
            "052f"
        ]
    },
    {
        category: "armenian",
        hexrange: [
            "0530",
            "058f"
        ]
    },
    {
        category: "hebrew",
        hexrange: [
            "0590",
            "05ff"
        ]
    },
    {
        category: "arabic",
        hexrange: [
            "0600",
            "06ff"
        ]
    },
    {
        category: "syriac",
        hexrange: [
            "0700",
            "074f"
        ]
    },
    {
        category: "arabic supplement",
        hexrange: [
            "0750",
            "077f"
        ]
    },
    {
        category: "thaana",
        hexrange: [
            "0780",
            "07bf"
        ]
    },
    {
        category: "nko",
        hexrange: [
            "07c0",
            "07ff"
        ]
    },
    {
        category: "samaritan",
        hexrange: [
            "0800",
            "083f"
        ]
    },
    {
        category: "mandaic",
        hexrange: [
            "0840",
            "085f"
        ]
    },
    {
        category: "syriac supplement",
        hexrange: [
            "0860",
            "086f"
        ]
    },
    {
        category: "arabic extended-b",
        hexrange: [
            "0870",
            "089f"
        ]
    },
    {
        category: "arabic extended-a",
        hexrange: [
            "08a0",
            "08ff"
        ]
    },
    {
        category: "devanagari",
        hexrange: [
            "0900",
            "097f"
        ]
    },
    {
        category: "bengali",
        hexrange: [
            "0980",
            "09ff"
        ]
    },
    {
        category: "gurmukhi",
        hexrange: [
            "0a00",
            "0a7f"
        ]
    },
    {
        category: "gujarati",
        hexrange: [
            "0a80",
            "0aff"
        ]
    },
    {
        category: "oriya",
        hexrange: [
            "0b00",
            "0b7f"
        ]
    },
    {
        category: "tamil",
        hexrange: [
            "0b80",
            "0bff"
        ]
    },
    {
        category: "telugu",
        hexrange: [
            "0c00",
            "0c7f"
        ]
    },
    {
        category: "kannada",
        hexrange: [
            "0c80",
            "0cff"
        ]
    },
    {
        category: "malayalam",
        hexrange: [
            "0d00",
            "0d7f"
        ]
    },
    {
        category: "sinhala",
        hexrange: [
            "0d80",
            "0dff"
        ]
    },
    {
        category: "thai",
        hexrange: [
            "0e00",
            "0e7f"
        ]
    },
    {
        category: "lao",
        hexrange: [
            "0e80",
            "0eff"
        ]
    },
    {
        category: "tibetan",
        hexrange: [
            "0f00",
            "0fff"
        ]
    },
    {
        category: "myanmar",
        hexrange: [
            "1000",
            "109f"
        ]
    },
    {
        category: "georgian",
        hexrange: [
            "10a0",
            "10ff"
        ]
    },
    {
        category: "hangul jamo",
        hexrange: [
            "1100",
            "11ff"
        ]
    },
    {
        category: "ethiopic",
        hexrange: [
            "1200",
            "137f"
        ]
    },
    {
        category: "ethiopic supplement",
        hexrange: [
            "1380",
            "139f"
        ]
    },
    {
        category: "cherokee",
        hexrange: [
            "13a0",
            "13ff"
        ]
    },
    {
        category: "unified canadian aboriginal syllabics",
        hexrange: [
            "1400",
            "167f"
        ]
    },
    {
        category: "ogham",
        hexrange: [
            "1680",
            "169f"
        ]
    },
    {
        category: "runic",
        hexrange: [
            "16a0",
            "16ff"
        ]
    },
    {
        category: "tagalog",
        hexrange: [
            "1700",
            "171f"
        ]
    },
    {
        category: "hanunoo",
        hexrange: [
            "1720",
            "173f"
        ]
    },
    {
        category: "buhid",
        hexrange: [
            "1740",
            "175f"
        ]
    },
    {
        category: "tagbanwa",
        hexrange: [
            "1760",
            "177f"
        ]
    },
    {
        category: "khmer",
        hexrange: [
            "1780",
            "17ff"
        ]
    },
    {
        category: "mongolian",
        hexrange: [
            "1800",
            "18af"
        ]
    },
    {
        category: "unified canadian aboriginal syllabics extended",
        hexrange: [
            "18b0",
            "18ff"
        ]
    },
    {
        category: "limbu",
        hexrange: [
            "1900",
            "194f"
        ]
    },
    {
        category: "tai le",
        hexrange: [
            "1950",
            "197f"
        ]
    },
    {
        category: "new tai lue",
        hexrange: [
            "1980",
            "19df"
        ]
    },
    {
        category: "khmer symbols",
        hexrange: [
            "19e0",
            "19ff"
        ]
    },
    {
        category: "buginese",
        hexrange: [
            "1a00",
            "1a1f"
        ]
    },
    {
        category: "tai tham",
        hexrange: [
            "1a20",
            "1aaf"
        ]
    },
    {
        category: "combining diacritical marks extended",
        hexrange: [
            "1ab0",
            "1aff"
        ]
    },
    {
        category: "balinese",
        hexrange: [
            "1b00",
            "1b7f"
        ]
    },
    {
        category: "sundanese",
        hexrange: [
            "1b80",
            "1bbf"
        ]
    },
    {
        category: "batak",
        hexrange: [
            "1bc0",
            "1bff"
        ]
    },
    {
        category: "lepcha",
        hexrange: [
            "1c00",
            "1c4f"
        ]
    },
    {
        category: "ol chiki",
        hexrange: [
            "1c50",
            "1c7f"
        ]
    },
    {
        category: "cyrillic extended-c",
        hexrange: [
            "1c80",
            "1c8f"
        ]
    },
    {
        category: "georgian extended",
        hexrange: [
            "1c90",
            "1cbf"
        ]
    },
    {
        category: "sundanese supplement",
        hexrange: [
            "1cc0",
            "1ccf"
        ]
    },
    {
        category: "vedic extensions",
        hexrange: [
            "1cd0",
            "1cff"
        ]
    },
    {
        category: "phonetic extensions",
        hexrange: [
            "1d00",
            "1d7f"
        ]
    },
    {
        category: "phonetic extensions supplement",
        hexrange: [
            "1d80",
            "1dbf"
        ]
    },
    {
        category: "combining diacritical marks supplement",
        hexrange: [
            "1dc0",
            "1dff"
        ]
    },
    {
        category: "latin extended additional",
        hexrange: [
            "1e00",
            "1eff"
        ]
    },
    {
        category: "greek extended",
        hexrange: [
            "1f00",
            "1fff"
        ]
    },
    {
        category: "general punctuation",
        hexrange: [
            "2000",
            "206f"
        ]
    },
    {
        category: "superscripts and subscripts",
        hexrange: [
            "2070",
            "209f"
        ]
    },
    {
        category: "currency symbols",
        hexrange: [
            "20a0",
            "20cf"
        ]
    },
    {
        category: "combining diacritical marks for symbols",
        hexrange: [
            "20d0",
            "20ff"
        ]
    },
    {
        category: "letterlike symbols",
        hexrange: [
            "2100",
            "214f"
        ]
    },
    {
        category: "number forms",
        hexrange: [
            "2150",
            "218f"
        ]
    },
    {
        category: "arrows",
        hexrange: [
            "2190",
            "21ff"
        ]
    },
    {
        category: "mathematical operators",
        hexrange: [
            "2200",
            "22ff"
        ]
    },
    {
        category: "miscellaneous technical",
        hexrange: [
            "2300",
            "23ff"
        ]
    },
    {
        category: "control pictures",
        hexrange: [
            "2400",
            "243f"
        ]
    },
    {
        category: "optical character recognition",
        hexrange: [
            "2440",
            "245f"
        ]
    },
    {
        category: "enclosed alphanumerics",
        hexrange: [
            "2460",
            "24ff"
        ]
    },
    {
        category: "box drawing",
        hexrange: [
            "2500",
            "257f"
        ]
    },
    {
        category: "block elements",
        hexrange: [
            "2580",
            "259f"
        ]
    },
    {
        category: "geometric shapes",
        hexrange: [
            "25a0",
            "25ff"
        ]
    },
    {
        category: "miscellaneous symbols",
        hexrange: [
            "2600",
            "26ff"
        ]
    },
    {
        category: "dingbats",
        hexrange: [
            "2700",
            "27bf"
        ]
    },
    {
        category: "miscellaneous mathematical symbols-a",
        hexrange: [
            "27c0",
            "27ef"
        ]
    },
    {
        category: "supplemental arrows-a",
        hexrange: [
            "27f0",
            "27ff"
        ]
    },
    {
        category: "braille patterns",
        hexrange: [
            "2800",
            "28ff"
        ]
    },
    {
        category: "supplemental arrows-b",
        hexrange: [
            "2900",
            "297f"
        ]
    },
    {
        category: "miscellaneous mathematical symbols-b",
        hexrange: [
            "2980",
            "29ff"
        ]
    },
    {
        category: "supplemental mathematical operators",
        hexrange: [
            "2a00",
            "2aff"
        ]
    },
    {
        category: "miscellaneous symbols and arrows",
        hexrange: [
            "2b00",
            "2bff"
        ]
    },
    {
        category: "glagolitic",
        hexrange: [
            "2c00",
            "2c5f"
        ]
    },
    {
        category: "latin extended-c",
        hexrange: [
            "2c60",
            "2c7f"
        ]
    },
    {
        category: "coptic",
        hexrange: [
            "2c80",
            "2cff"
        ]
    },
    {
        category: "georgian supplement",
        hexrange: [
            "2d00",
            "2d2f"
        ]
    },
    {
        category: "tifinagh",
        hexrange: [
            "2d30",
            "2d7f"
        ]
    },
    {
        category: "ethiopic extended",
        hexrange: [
            "2d80",
            "2ddf"
        ]
    },
    {
        category: "cyrillic extended-a",
        hexrange: [
            "2de0",
            "2dff"
        ]
    },
    {
        category: "supplemental punctuation",
        hexrange: [
            "2e00",
            "2e7f"
        ]
    },
    {
        category: "cjk radicals supplement",
        hexrange: [
            "2e80",
            "2eff"
        ]
    },
    {
        category: "kangxi radicals",
        hexrange: [
            "2f00",
            "2fdf"
        ]
    },
    {
        category: "ideographic description characters",
        hexrange: [
            "2ff0",
            "2fff"
        ]
    },
    {
        category: "cjk symbols and punctuation",
        hexrange: [
            "3000",
            "303f"
        ]
    },
    {
        category: "hiragana",
        hexrange: [
            "3040",
            "309f"
        ]
    },
    {
        category: "katakana",
        hexrange: [
            "30a0",
            "30ff"
        ]
    },
    {
        category: "bopomofo",
        hexrange: [
            "3100",
            "312f"
        ]
    },
    {
        category: "hangul compatibility jamo",
        hexrange: [
            "3130",
            "318f"
        ]
    },
    {
        category: "kanbun",
        hexrange: [
            "3190",
            "319f"
        ]
    },
    {
        category: "bopomofo extended",
        hexrange: [
            "31a0",
            "31bf"
        ]
    },
    {
        category: "cjk strokes",
        hexrange: [
            "31c0",
            "31ef"
        ]
    },
    {
        category: "katakana phonetic extensions",
        hexrange: [
            "31f0",
            "31ff"
        ]
    },
    {
        category: "enclosed cjk letters and months",
        hexrange: [
            "3200",
            "32ff"
        ]
    },
    {
        category: "cjk compatibility",
        hexrange: [
            "3300",
            "33ff"
        ]
    },
    {
        category: "cjk unified ideographs extension a",
        hexrange: [
            "3400",
            "4dbf"
        ]
    },
    {
        category: "yijing hexagram symbols",
        hexrange: [
            "4dc0",
            "4dff"
        ]
    },
    {
        category: "cjk unified ideographs",
        hexrange: [
            "4e00",
            "9fff"
        ]
    },
    {
        category: "yi syllables",
        hexrange: [
            "a000",
            "a48f"
        ]
    },
    {
        category: "yi radicals",
        hexrange: [
            "a490",
            "a4cf"
        ]
    },
    {
        category: "lisu",
        hexrange: [
            "a4d0",
            "a4ff"
        ]
    },
    {
        category: "vai",
        hexrange: [
            "a500",
            "a63f"
        ]
    },
    {
        category: "cyrillic extended-b",
        hexrange: [
            "a640",
            "a69f"
        ]
    },
    {
        category: "bamum",
        hexrange: [
            "a6a0",
            "a6ff"
        ]
    },
    {
        category: "modifier tone letters",
        hexrange: [
            "a700",
            "a71f"
        ]
    },
    {
        category: "latin extended-d",
        hexrange: [
            "a720",
            "a7ff"
        ]
    },
    {
        category: "syloti nagri",
        hexrange: [
            "a800",
            "a82f"
        ]
    },
    {
        category: "common indic number forms",
        hexrange: [
            "a830",
            "a83f"
        ]
    },
    {
        category: "phags-pa",
        hexrange: [
            "a840",
            "a87f"
        ]
    },
    {
        category: "saurashtra",
        hexrange: [
            "a880",
            "a8df"
        ]
    },
    {
        category: "devanagari extended",
        hexrange: [
            "a8e0",
            "a8ff"
        ]
    },
    {
        category: "kayah li",
        hexrange: [
            "a900",
            "a92f"
        ]
    },
    {
        category: "rejang",
        hexrange: [
            "a930",
            "a95f"
        ]
    },
    {
        category: "hangul jamo extended-a",
        hexrange: [
            "a960",
            "a97f"
        ]
    },
    {
        category: "javanese",
        hexrange: [
            "a980",
            "a9df"
        ]
    },
    {
        category: "myanmar extended-b",
        hexrange: [
            "a9e0",
            "a9ff"
        ]
    },
    {
        category: "cham",
        hexrange: [
            "aa00",
            "aa5f"
        ]
    },
    {
        category: "myanmar extended-a",
        hexrange: [
            "aa60",
            "aa7f"
        ]
    },
    {
        category: "tai viet",
        hexrange: [
            "aa80",
            "aadf"
        ]
    },
    {
        category: "meetei mayek extensions",
        hexrange: [
            "aae0",
            "aaff"
        ]
    },
    {
        category: "ethiopic extended-a",
        hexrange: [
            "ab00",
            "ab2f"
        ]
    },
    {
        category: "latin extended-e",
        hexrange: [
            "ab30",
            "ab6f"
        ]
    },
    {
        category: "cherokee supplement",
        hexrange: [
            "ab70",
            "abbf"
        ]
    },
    {
        category: "meetei mayek",
        hexrange: [
            "abc0",
            "abff"
        ]
    },
    {
        category: "hangul syllables",
        hexrange: [
            "ac00",
            "d7af"
        ]
    },
    {
        category: "hangul jamo extended-b",
        hexrange: [
            "d7b0",
            "d7ff"
        ]
    },
    {
        category: "high surrogates",
        hexrange: [
            "d800",
            "db7f"
        ]
    },
    {
        category: "high private use surrogates",
        hexrange: [
            "db80",
            "dbff"
        ]
    },
    {
        category: "low surrogates",
        hexrange: [
            "dc00",
            "dfff"
        ]
    },
    {
        category: "private use area",
        hexrange: [
            "e000",
            "f8ff"
        ]
    },
    {
        category: "cjk compatibility ideographs",
        hexrange: [
            "f900",
            "faff"
        ]
    },
    {
        category: "alphabetic presentation forms",
        hexrange: [
            "fb00",
            "fb4f"
        ]
    },
    {
        category: "arabic presentation forms-a",
        hexrange: [
            "fb50",
            "fdff"
        ]
    },
    {
        category: "variation selectors",
        hexrange: [
            "fe00",
            "fe0f"
        ]
    },
    {
        category: "vertical forms",
        hexrange: [
            "fe10",
            "fe1f"
        ]
    },
    {
        category: "combining half marks",
        hexrange: [
            "fe20",
            "fe2f"
        ]
    },
    {
        category: "cjk compatibility forms",
        hexrange: [
            "fe30",
            "fe4f"
        ]
    },
    {
        category: "small form variants",
        hexrange: [
            "fe50",
            "fe6f"
        ]
    },
    {
        category: "arabic presentation forms-b",
        hexrange: [
            "fe70",
            "feff"
        ]
    },
    {
        category: "halfwidth and fullwidth forms",
        hexrange: [
            "ff00",
            "ffef"
        ]
    },
    {
        category: "specials",
        hexrange: [
            "fff0",
            "ffff"
        ]
    },
    {
        category: "linear b syllabary",
        hexrange: [
            "10000",
            "1007f"
        ]
    },
    {
        category: "linear b ideograms",
        hexrange: [
            "10080",
            "100ff"
        ]
    },
    {
        category: "aegean numbers",
        hexrange: [
            "10100",
            "1013f"
        ]
    },
    {
        category: "ancient greek numbers",
        hexrange: [
            "10140",
            "1018f"
        ]
    },
    {
        category: "ancient symbols",
        hexrange: [
            "10190",
            "101cf"
        ]
    },
    {
        category: "phaistos disc",
        hexrange: [
            "101d0",
            "101ff"
        ]
    },
    {
        category: "lycian",
        hexrange: [
            "10280",
            "1029f"
        ]
    },
    {
        category: "carian",
        hexrange: [
            "102a0",
            "102df"
        ]
    },
    {
        category: "coptic epact numbers",
        hexrange: [
            "102e0",
            "102ff"
        ]
    },
    {
        category: "old italic",
        hexrange: [
            "10300",
            "1032f"
        ]
    },
    {
        category: "gothic",
        hexrange: [
            "10330",
            "1034f"
        ]
    },
    {
        category: "old permic",
        hexrange: [
            "10350",
            "1037f"
        ]
    },
    {
        category: "ugaritic",
        hexrange: [
            "10380",
            "1039f"
        ]
    },
    {
        category: "old persian",
        hexrange: [
            "103a0",
            "103df"
        ]
    },
    {
        category: "deseret",
        hexrange: [
            "10400",
            "1044f"
        ]
    },
    {
        category: "shavian",
        hexrange: [
            "10450",
            "1047f"
        ]
    },
    {
        category: "osmanya",
        hexrange: [
            "10480",
            "104af"
        ]
    },
    {
        category: "osage",
        hexrange: [
            "104b0",
            "104ff"
        ]
    },
    {
        category: "elbasan",
        hexrange: [
            "10500",
            "1052f"
        ]
    },
    {
        category: "caucasian albanian",
        hexrange: [
            "10530",
            "1056f"
        ]
    },
    {
        category: "vithkuqi",
        hexrange: [
            "10570",
            "105bf"
        ]
    },
    {
        category: "linear a",
        hexrange: [
            "10600",
            "1077f"
        ]
    },
    {
        category: "latin extended-f",
        hexrange: [
            "10780",
            "107bf"
        ]
    },
    {
        category: "cypriot syllabary",
        hexrange: [
            "10800",
            "1083f"
        ]
    },
    {
        category: "imperial aramaic",
        hexrange: [
            "10840",
            "1085f"
        ]
    },
    {
        category: "palmyrene",
        hexrange: [
            "10860",
            "1087f"
        ]
    },
    {
        category: "nabataean",
        hexrange: [
            "10880",
            "108af"
        ]
    },
    {
        category: "hatran",
        hexrange: [
            "108e0",
            "108ff"
        ]
    },
    {
        category: "phoenician",
        hexrange: [
            "10900",
            "1091f"
        ]
    },
    {
        category: "lydian",
        hexrange: [
            "10920",
            "1093f"
        ]
    },
    {
        category: "meroitic hieroglyphs",
        hexrange: [
            "10980",
            "1099f"
        ]
    },
    {
        category: "meroitic cursive",
        hexrange: [
            "109a0",
            "109ff"
        ]
    },
    {
        category: "kharoshthi",
        hexrange: [
            "10a00",
            "10a5f"
        ]
    },
    {
        category: "old south arabian",
        hexrange: [
            "10a60",
            "10a7f"
        ]
    },
    {
        category: "old north arabian",
        hexrange: [
            "10a80",
            "10a9f"
        ]
    },
    {
        category: "manichaean",
        hexrange: [
            "10ac0",
            "10aff"
        ]
    },
    {
        category: "avestan",
        hexrange: [
            "10b00",
            "10b3f"
        ]
    },
    {
        category: "inscriptional parthian",
        hexrange: [
            "10b40",
            "10b5f"
        ]
    },
    {
        category: "inscriptional pahlavi",
        hexrange: [
            "10b60",
            "10b7f"
        ]
    },
    {
        category: "psalter pahlavi",
        hexrange: [
            "10b80",
            "10baf"
        ]
    },
    {
        category: "old turkic",
        hexrange: [
            "10c00",
            "10c4f"
        ]
    },
    {
        category: "old hungarian",
        hexrange: [
            "10c80",
            "10cff"
        ]
    },
    {
        category: "hanifi rohingya",
        hexrange: [
            "10d00",
            "10d3f"
        ]
    },
    {
        category: "rumi numeral symbols",
        hexrange: [
            "10e60",
            "10e7f"
        ]
    },
    {
        category: "yezidi",
        hexrange: [
            "10e80",
            "10ebf"
        ]
    },
    {
        category: "arabic extended-c",
        hexrange: [
            "10ec0",
            "10eff"
        ]
    },
    {
        category: "old sogdian",
        hexrange: [
            "10f00",
            "10f2f"
        ]
    },
    {
        category: "sogdian",
        hexrange: [
            "10f30",
            "10f6f"
        ]
    },
    {
        category: "old uyghur",
        hexrange: [
            "10f70",
            "10faf"
        ]
    },
    {
        category: "chorasmian",
        hexrange: [
            "10fb0",
            "10fdf"
        ]
    },
    {
        category: "elymaic",
        hexrange: [
            "10fe0",
            "10fff"
        ]
    },
    {
        category: "brahmi",
        hexrange: [
            "11000",
            "1107f"
        ]
    },
    {
        category: "kaithi",
        hexrange: [
            "11080",
            "110cf"
        ]
    },
    {
        category: "sora sompeng",
        hexrange: [
            "110d0",
            "110ff"
        ]
    },
    {
        category: "chakma",
        hexrange: [
            "11100",
            "1114f"
        ]
    },
    {
        category: "mahajani",
        hexrange: [
            "11150",
            "1117f"
        ]
    },
    {
        category: "sharada",
        hexrange: [
            "11180",
            "111df"
        ]
    },
    {
        category: "sinhala archaic numbers",
        hexrange: [
            "111e0",
            "111ff"
        ]
    },
    {
        category: "khojki",
        hexrange: [
            "11200",
            "1124f"
        ]
    },
    {
        category: "multani",
        hexrange: [
            "11280",
            "112af"
        ]
    },
    {
        category: "khudawadi",
        hexrange: [
            "112b0",
            "112ff"
        ]
    },
    {
        category: "grantha",
        hexrange: [
            "11300",
            "1137f"
        ]
    },
    {
        category: "newa",
        hexrange: [
            "11400",
            "1147f"
        ]
    },
    {
        category: "tirhuta",
        hexrange: [
            "11480",
            "114df"
        ]
    },
    {
        category: "siddham",
        hexrange: [
            "11580",
            "115ff"
        ]
    },
    {
        category: "modi",
        hexrange: [
            "11600",
            "1165f"
        ]
    },
    {
        category: "mongolian supplement",
        hexrange: [
            "11660",
            "1167f"
        ]
    },
    {
        category: "takri",
        hexrange: [
            "11680",
            "116cf"
        ]
    },
    {
        category: "ahom",
        hexrange: [
            "11700",
            "1174f"
        ]
    },
    {
        category: "dogra",
        hexrange: [
            "11800",
            "1184f"
        ]
    },
    {
        category: "warang citi",
        hexrange: [
            "118a0",
            "118ff"
        ]
    },
    {
        category: "dives akuru",
        hexrange: [
            "11900",
            "1195f"
        ]
    },
    {
        category: "nandinagari",
        hexrange: [
            "119a0",
            "119ff"
        ]
    },
    {
        category: "zanabazar square",
        hexrange: [
            "11a00",
            "11a4f"
        ]
    },
    {
        category: "soyombo",
        hexrange: [
            "11a50",
            "11aaf"
        ]
    },
    {
        category: "unified canadian aboriginal syllabics extended-a",
        hexrange: [
            "11ab0",
            "11abf"
        ]
    },
    {
        category: "pau cin hau",
        hexrange: [
            "11ac0",
            "11aff"
        ]
    },
    {
        category: "devanagari extended-a",
        hexrange: [
            "11b00",
            "11b5f"
        ]
    },
    {
        category: "bhaiksuki",
        hexrange: [
            "11c00",
            "11c6f"
        ]
    },
    {
        category: "marchen",
        hexrange: [
            "11c70",
            "11cbf"
        ]
    },
    {
        category: "masaram gondi",
        hexrange: [
            "11d00",
            "11d5f"
        ]
    },
    {
        category: "gunjala gondi",
        hexrange: [
            "11d60",
            "11daf"
        ]
    },
    {
        category: "makasar",
        hexrange: [
            "11ee0",
            "11eff"
        ]
    },
    {
        category: "kawi",
        hexrange: [
            "11f00",
            "11f5f"
        ]
    },
    {
        category: "lisu supplement",
        hexrange: [
            "11fb0",
            "11fbf"
        ]
    },
    {
        category: "tamil supplement",
        hexrange: [
            "11fc0",
            "11fff"
        ]
    },
    {
        category: "cuneiform",
        hexrange: [
            "12000",
            "123ff"
        ]
    },
    {
        category: "cuneiform numbers and punctuation",
        hexrange: [
            "12400",
            "1247f"
        ]
    },
    {
        category: "early dynastic cuneiform",
        hexrange: [
            "12480",
            "1254f"
        ]
    },
    {
        category: "cypro-minoan",
        hexrange: [
            "12f90",
            "12fff"
        ]
    },
    {
        category: "egyptian hieroglyphs",
        hexrange: [
            "13000",
            "1342f"
        ]
    },
    {
        category: "egyptian hieroglyph format controls",
        hexrange: [
            "13430",
            "1345f"
        ]
    },
    {
        category: "anatolian hieroglyphs",
        hexrange: [
            "14400",
            "1467f"
        ]
    },
    {
        category: "bamum supplement",
        hexrange: [
            "16800",
            "16a3f"
        ]
    },
    {
        category: "mro",
        hexrange: [
            "16a40",
            "16a6f"
        ]
    },
    {
        category: "tangsa",
        hexrange: [
            "16a70",
            "16acf"
        ]
    },
    {
        category: "bassa vah",
        hexrange: [
            "16ad0",
            "16aff"
        ]
    },
    {
        category: "pahawh hmong",
        hexrange: [
            "16b00",
            "16b8f"
        ]
    },
    {
        category: "medefaidrin",
        hexrange: [
            "16e40",
            "16e9f"
        ]
    },
    {
        category: "miao",
        hexrange: [
            "16f00",
            "16f9f"
        ]
    },
    {
        category: "ideographic symbols and punctuation",
        hexrange: [
            "16fe0",
            "16fff"
        ]
    },
    {
        category: "tangut",
        hexrange: [
            "17000",
            "187ff"
        ]
    },
    {
        category: "tangut components",
        hexrange: [
            "18800",
            "18aff"
        ]
    },
    {
        category: "khitan small script",
        hexrange: [
            "18b00",
            "18cff"
        ]
    },
    {
        category: "tangut supplement",
        hexrange: [
            "18d00",
            "18d7f"
        ]
    },
    {
        category: "kana extended-b",
        hexrange: [
            "1aff0",
            "1afff"
        ]
    },
    {
        category: "kana supplement",
        hexrange: [
            "1b000",
            "1b0ff"
        ]
    },
    {
        category: "kana extended-a",
        hexrange: [
            "1b100",
            "1b12f"
        ]
    },
    {
        category: "small kana extension",
        hexrange: [
            "1b130",
            "1b16f"
        ]
    },
    {
        category: "nushu",
        hexrange: [
            "1b170",
            "1b2ff"
        ]
    },
    {
        category: "duployan",
        hexrange: [
            "1bc00",
            "1bc9f"
        ]
    },
    {
        category: "shorthand format controls",
        hexrange: [
            "1bca0",
            "1bcaf"
        ]
    },
    {
        category: "znamenny musical notation",
        hexrange: [
            "1cf00",
            "1cfcf"
        ]
    },
    {
        category: "byzantine musical symbols",
        hexrange: [
            "1d000",
            "1d0ff"
        ]
    },
    {
        category: "musical symbols",
        hexrange: [
            "1d100",
            "1d1ff"
        ]
    },
    {
        category: "ancient greek musical notation",
        hexrange: [
            "1d200",
            "1d24f"
        ]
    },
    {
        category: "kaktovik numerals",
        hexrange: [
            "1d2c0",
            "1d2df"
        ]
    },
    {
        category: "mayan numerals",
        hexrange: [
            "1d2e0",
            "1d2ff"
        ]
    },
    {
        category: "tai xuan jing symbols",
        hexrange: [
            "1d300",
            "1d35f"
        ]
    },
    {
        category: "counting rod numerals",
        hexrange: [
            "1d360",
            "1d37f"
        ]
    },
    {
        category: "mathematical alphanumeric symbols",
        hexrange: [
            "1d400",
            "1d7ff"
        ]
    },
    {
        category: "sutton signwriting",
        hexrange: [
            "1d800",
            "1daaf"
        ]
    },
    {
        category: "latin extended-g",
        hexrange: [
            "1df00",
            "1dfff"
        ]
    },
    {
        category: "glagolitic supplement",
        hexrange: [
            "1e000",
            "1e02f"
        ]
    },
    {
        category: "cyrillic extended-d",
        hexrange: [
            "1e030",
            "1e08f"
        ]
    },
    {
        category: "nyiakeng puachue hmong",
        hexrange: [
            "1e100",
            "1e14f"
        ]
    },
    {
        category: "toto",
        hexrange: [
            "1e290",
            "1e2bf"
        ]
    },
    {
        category: "wancho",
        hexrange: [
            "1e2c0",
            "1e2ff"
        ]
    },
    {
        category: "nag mundari",
        hexrange: [
            "1e4d0",
            "1e4ff"
        ]
    },
    {
        category: "ethiopic extended-b",
        hexrange: [
            "1e7e0",
            "1e7ff"
        ]
    },
    {
        category: "mende kikakui",
        hexrange: [
            "1e800",
            "1e8df"
        ]
    },
    {
        category: "adlam",
        hexrange: [
            "1e900",
            "1e95f"
        ]
    },
    {
        category: "indic siyaq numbers",
        hexrange: [
            "1ec70",
            "1ecbf"
        ]
    },
    {
        category: "ottoman siyaq numbers",
        hexrange: [
            "1ed00",
            "1ed4f"
        ]
    },
    {
        category: "arabic mathematical alphabetic symbols",
        hexrange: [
            "1ee00",
            "1eeff"
        ]
    },
    {
        category: "mahjong tiles",
        hexrange: [
            "1f000",
            "1f02f"
        ]
    },
    {
        category: "domino tiles",
        hexrange: [
            "1f030",
            "1f09f"
        ]
    },
    {
        category: "playing cards",
        hexrange: [
            "1f0a0",
            "1f0ff"
        ]
    },
    {
        category: "enclosed alphanumeric supplement",
        hexrange: [
            "1f100",
            "1f1ff"
        ]
    },
    {
        category: "enclosed ideographic supplement",
        hexrange: [
            "1f200",
            "1f2ff"
        ]
    },
    {
        category: "miscellaneous symbols and pictographs",
        hexrange: [
            "1f300",
            "1f5ff"
        ]
    },
    {
        category: "emoticons (emoji)",
        hexrange: [
            "1f600",
            "1f64f"
        ]
    },
    {
        category: "ornamental dingbats",
        hexrange: [
            "1f650",
            "1f67f"
        ]
    },
    {
        category: "transport and map symbols",
        hexrange: [
            "1f680",
            "1f6ff"
        ]
    },
    {
        category: "alchemical symbols",
        hexrange: [
            "1f700",
            "1f77f"
        ]
    },
    {
        category: "geometric shapes extended",
        hexrange: [
            "1f780",
            "1f7ff"
        ]
    },
    {
        category: "supplemental arrows-c",
        hexrange: [
            "1f800",
            "1f8ff"
        ]
    },
    {
        category: "supplemental symbols and pictographs",
        hexrange: [
            "1f900",
            "1f9ff"
        ]
    },
    {
        category: "chess symbols",
        hexrange: [
            "1fa00",
            "1fa6f"
        ]
    },
    {
        category: "symbols and pictographs extended-a",
        hexrange: [
            "1fa70",
            "1faff"
        ]
    },
    {
        category: "symbols for legacy computing",
        hexrange: [
            "1fb00",
            "1fbff"
        ]
    },
    {
        category: "cjk unified ideographs extension b",
        hexrange: [
            "20000",
            "2a6df"
        ]
    },
    {
        category: "cjk unified ideographs extension c",
        hexrange: [
            "2a700",
            "2b73f"
        ]
    },
    {
        category: "cjk unified ideographs extension d",
        hexrange: [
            "2b740",
            "2b81f"
        ]
    },
    {
        category: "cjk unified ideographs extension e",
        hexrange: [
            "2b820",
            "2ceaf"
        ]
    },
    {
        category: "cjk unified ideographs extension f",
        hexrange: [
            "2ceb0",
            "2ebef"
        ]
    },
    {
        category: "cjk unified ideographs extension i",
        hexrange: [
            "2ebf0",
            "2ee5f"
        ]
    },
    {
        category: "cjk compatibility ideographs supplement",
        hexrange: [
            "2f800",
            "2fa1f"
        ]
    },
    {
        category: "cjk unified ideographs extension g",
        hexrange: [
            "30000",
            "3134f"
        ]
    },
    {
        category: "cjk unified ideographs extension h",
        hexrange: [
            "31350",
            "323af"
        ]
    },
    {
        category: "tags",
        hexrange: [
            "e0000",
            "e007f"
        ]
    },
    {
        category: "variation selectors supplement",
        hexrange: [
            "e0100",
            "e01ef"
        ]
    },
    {
        category: "supplementary private use area-a",
        hexrange: [
            "f0000",
            "fffff"
        ]
    },
    {
        category: "supplementary private use area-b",
        hexrange: [
            "100000",
            "10ffff"
        ]
    }
];
;
}}),
"[project]/node_modules/p5/dist/type/lib/Typr.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>Typr)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pako$2f$dist$2f$pako$2e$esm$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pako/dist/pako.esm.mjs [app-ssr] (ecmascript)");
;
// Mocking the pako module to just have inflate for a smaller package size
const pako = {
    inflate: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pako$2f$dist$2f$pako$2e$esm$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["inflate"]
};
var Typr = {};
Typr["parse"] = function(buff) {
    var bin = Typr["B"];
    var readFont = function(data, idx, offset, tmap) {
        var T = Typr["T"];
        var prsr = {
            "cmap": T.cmap,
            "head": T.head,
            "hhea": T.hhea,
            "maxp": T.maxp,
            "hmtx": T.hmtx,
            "name": T.name,
            "OS/2": T.OS2,
            "post": T.post,
            "loca": T.loca,
            "kern": T.kern,
            "glyf": T.glyf,
            "CFF ": T.CFF,
            /*
      "GPOS",
      "GSUB",
      "GDEF",*/ "GSUB": T.GSUB,
            "CBLC": T.CBLC,
            "CBDT": T.CBDT,
            "SVG ": T.SVG,
            "COLR": T.colr,
            "CPAL": T.cpal,
            "sbix": T.sbix,
            "fvar": T.fvar,
            "gvar": T.gvar,
            "avar": T.avar,
            "HVAR": T.HVAR
        };
        var obj = {
            "_data": data,
            "_index": idx,
            "_offset": offset
        };
        for(var t in prsr){
            var tab = Typr["findTable"](data, t, offset);
            if (tab) {
                var off = tab[0], tobj = tmap[off];
                if (tobj == null) tobj = prsr[t].parseTab(data, off, tab[1], obj);
                obj[t] = tmap[off] = tobj;
            }
        }
        return obj;
    };
    function woffToOtf(data) {
        var numTables = bin.readUshort(data, 12);
        var totalSize = bin.readUint(data, 16);
        var otf = new Uint8Array(totalSize), toff = 12 + numTables * 16;
        bin.writeASCII(otf, 0, "OTTO");
        bin.writeUshort(otf, 4, numTables);
        var off = 44;
        for(var i = 0; i < numTables; i++){
            var tag = bin.readASCII(data, off, 4);
            var tof = bin.readUint(data, off + 4);
            var cLe = bin.readUint(data, off + 8);
            var oLe = bin.readUint(data, off + 12);
            off += 20;
            //console.log(i, ":::", tag,tof,oLe);
            var tab = data.slice(tof, tof + cLe);
            if (cLe != oLe) tab = pako["inflate"](tab);
            var to = 12 + i * 16;
            bin.writeASCII(otf, to, tag);
            bin.writeUint(otf, to + 8, toff);
            bin.writeUint(otf, to + 12, oLe);
            otf.set(tab, toff);
            toff += oLe;
        }
        //console.log(otf);
        return otf;
    }
    var data = new Uint8Array(buff);
    // PATCHED: keep around the compressed data if we inflate it
    let compressedData;
    if (data[0] == 0x77) {
        compressedData = data;
        data = woffToOtf(data);
    }
    var tmap = {};
    var tag = bin.readASCII(data, 0, 4);
    if (tag == "ttcf") {
        var offset = 4;
        bin.readUshort(data, offset);
        offset += 2;
        bin.readUshort(data, offset);
        offset += 2;
        var numF = bin.readUint(data, offset);
        offset += 4;
        var fnts = [];
        for(var i = 0; i < numF; i++){
            var foff = bin.readUint(data, offset);
            offset += 4;
            fnts.push(readFont(data, i, foff, tmap));
        }
        return fnts;
    }
    var fnt = readFont(data, 0, 0, tmap); //console.log(fnt);  throw "e";
    fnt._compressedData = compressedData; // PATCH: make compressed data accessible
    var fvar = fnt["fvar"];
    if (fvar) {
        var out = [
            fnt
        ];
        for(var i = 0; i < fvar[1].length; i++){
            var fv = fvar[1][i];
            var obj = {};
            out.push(obj);
            for(var p in fnt)obj[p] = fnt[p];
            obj["_index"] = i;
            var name = obj["name"] = JSON.parse(JSON.stringify(obj["name"]));
            name["fontSubfamily"] = fv[0];
            if (fv[3] == null) fv[3] = (name["fontFamily"] + "-" + name["fontSubfamily"])["replaceAll"](" ", "");
            name["postScriptName"] = fv[3];
        }
        return out;
    }
    return [
        fnt
    ];
};
Typr["findTable"] = function(data, tab, foff) {
    var bin = Typr["B"];
    var numTables = bin.readUshort(data, foff + 4);
    var offset = foff + 12;
    for(var i = 0; i < numTables; i++){
        var tag = bin.readASCII(data, offset, 4); //console.log(tag);
        bin.readUint(data, offset + 4);
        var toffset = bin.readUint(data, offset + 8);
        var length = bin.readUint(data, offset + 12);
        if (tag == tab) return [
            toffset,
            length
        ];
        offset += 16;
    }
    return null;
};
/*
Typr["splitBy"] = function(data,tag) {
  data = new Uint8Array(data);  console.log(data.slice(0,64));
  var bin = Typr["B"];
  var ttcf = bin.readASCII(data, 0, 4);  if(ttcf!="ttcf") return {};

  var offset = 8;
  var numF = bin.readUint  (data, offset);  offset+=4;
  var colls = [], used={};
  for(var i=0; i<numF; i++) {
    var foff = bin.readUint  (data, offset);  offset+=4;
    var toff = Typr["findTable"](data,tag,foff)[0];
    if(used[toff]==null) used[toff] = [];
    used[toff].push([foff,bin.readUshort(data,foff+4)]);  // font offset, numTables
  }
  for(var toff in used) {
    var offs = used[toff];
    var hlen = 12+4*offs.length;
    var out = new Uint8Array(hlen);
    for(var i=0; i<8; i++) out[i]=data[i];
    bin.writeUint(out,8,offs.length);

    for(var i=0; i<offs.length; i++) hlen += 12+offs[i][1]*16;

    var hdrs = [out], tabs = [], hoff=out.length, toff=hlen, noffs={};
    for(var i=0; i<offs.length; i++) {
      bin.writeUint(out, 12+i*4, hoff);  hoff+=12+offs[i][1]*16;
      toff = Typr["_cutFont"](data, offs[i][0], hdrs, tabs, toff, noffs);
    }
    colls.push(Typr["_joinArrs"](hdrs.concat(tabs)));
  }
  return colls;
}

Typr["splitFonts"] = function(data) {
  data = new Uint8Array(data);
  var bin = Typr["B"];
  var ttcf = bin.readASCII(data, 0, 4);  if(ttcf!="ttcf") return {};

  var offset = 8;
  var numF = bin.readUint  (data, offset);  offset+=4;
  var fnts = [];
  for(var i=0; i<numF; i++) {
    var foff = bin.readUint  (data, offset);  offset+=4;
    fnts.push(Typr._cutFont(data, foff));
    break;
  }
  return fnts;
}

Typr["_cutFont"] = function(data,foff,hdrs,tabs,toff, noffs) {
  var bin = Typr["B"];
  var numTables = bin.readUshort(data, foff+4);

  var out = new Uint8Array(12+numTables*16);  hdrs.push(out);
  for(var i=0; i<12; i++) out[i]=data[foff+i];  //console.log(out);

  var off = 12;
  for(var i=0; i<numTables; i++)
  {
    var tag      = bin.readASCII(data, foff+off, 4);
    var checkSum = bin.readUint (data, foff+off+ 4);
    var toffset  = bin.readUint (data, foff+off+ 8);
    var length   = bin.readUint (data, foff+off+12);

    while((length&3)!=0) length++;

    for(var j=0; j<16; j++) out[off+j]=data[foff+off+j];

    if(noffs[toffset]!=null) bin.writeUint(out,off+8,noffs[toffset]);
    else {
      noffs[toffset] = toff;
      bin.writeUint(out, off+8, toff);
      tabs.push(new Uint8Array(data.buffer, toffset, length));  toff+=length;
    }
    off+=16;
  }
  return toff;
}
Typr["_joinArrs"] = function(tabs) {
  var len = 0;
  for(var i=0; i<tabs.length; i++) len+=tabs[i].length;
  var out = new Uint8Array(len), ooff=0;
  for(var i=0; i<tabs.length; i++) {
    var tab = tabs[i];
    for(var j=0; j<tab.length; j++) out[ooff+j]=tab[j];
    ooff+=tab.length;
  }
  return out;
}
*/ Typr["T"] = {};
Typr["B"] = {
    readFixed: function(data, o) {
        return (data[o] << 8 | data[o + 1]) + (data[o + 2] << 8 | data[o + 3]) / (256 * 256 + 4);
    },
    readF2dot14: function(data, o) {
        var num = Typr["B"].readShort(data, o);
        return num / 16384;
    },
    readInt: function(buff, p) {
        //if(p>=buff.length) throw "error";
        var a = Typr["B"].t.uint8;
        a[0] = buff[p + 3];
        a[1] = buff[p + 2];
        a[2] = buff[p + 1];
        a[3] = buff[p];
        return Typr["B"].t.int32[0];
    },
    readInt8: function(buff, p) {
        //if(p>=buff.length) throw "error";
        var a = Typr["B"].t.uint8;
        a[0] = buff[p];
        return Typr["B"].t.int8[0];
    },
    readShort: function(buff, p) {
        //if(p>=buff.length) throw "error";
        var a = Typr["B"].t.uint16;
        a[0] = buff[p] << 8 | buff[p + 1];
        return Typr["B"].t.int16[0];
    },
    readUshort: function(buff, p) {
        //if(p>=buff.length) throw "error";
        return buff[p] << 8 | buff[p + 1];
    },
    writeUshort: function(buff, p, n) {
        buff[p] = n >> 8 & 255;
        buff[p + 1] = n & 255;
    },
    readUshorts: function(buff, p, len) {
        var arr = [];
        for(var i = 0; i < len; i++){
            var v = Typr["B"].readUshort(buff, p + i * 2); //if(v==932) console.log(p+i*2);
            arr.push(v);
        }
        return arr;
    },
    readUint: function(buff, p) {
        //if(p>=buff.length) throw "error";
        var a = Typr["B"].t.uint8;
        a[3] = buff[p];
        a[2] = buff[p + 1];
        a[1] = buff[p + 2];
        a[0] = buff[p + 3];
        return Typr["B"].t.uint32[0];
    },
    writeUint: function(buff, p, n) {
        buff[p] = n >> 24 & 255;
        buff[p + 1] = n >> 16 & 255;
        buff[p + 2] = n >> 8 & 255;
        buff[p + 3] = n >> 0 & 255;
    },
    readUint64: function(buff, p) {
        //if(p>=buff.length) throw "error";
        return Typr["B"].readUint(buff, p) * (0xffffffff + 1) + Typr["B"].readUint(buff, p + 4);
    },
    readASCII: function(buff, p, l) {
        //if(p>=buff.length) throw "error";
        var s = "";
        for(var i = 0; i < l; i++)s += String.fromCharCode(buff[p + i]);
        return s;
    },
    writeASCII: function(buff, p, s) {
        for(var i = 0; i < s.length; i++)buff[p + i] = s.charCodeAt(i);
    },
    readUnicode: function(buff, p, l) {
        //if(p>=buff.length) throw "error";
        var s = "";
        for(var i = 0; i < l; i++){
            var c = buff[p++] << 8 | buff[p++];
            s += String.fromCharCode(c);
        }
        return s;
    },
    _tdec: window["TextDecoder"] ? new window["TextDecoder"]() : null,
    readUTF8: function(buff, p, l) {
        var tdec = Typr["B"]._tdec;
        if (tdec && p == 0 && l == buff.length) return tdec["decode"](buff);
        return Typr["B"].readASCII(buff, p, l);
    },
    readBytes: function(buff, p, l) {
        //if(p>=buff.length) throw "error";
        var arr = [];
        for(var i = 0; i < l; i++)arr.push(buff[p + i]);
        return arr;
    },
    readASCIIArray: function(buff, p, l) {
        //if(p>=buff.length) throw "error";
        var s = [];
        for(var i = 0; i < l; i++)s.push(String.fromCharCode(buff[p + i]));
        return s;
    },
    t: function() {
        var ab = new ArrayBuffer(8);
        return {
            buff: ab,
            int8: new Int8Array(ab),
            uint8: new Uint8Array(ab),
            int16: new Int16Array(ab),
            uint16: new Uint16Array(ab),
            int32: new Int32Array(ab),
            uint32: new Uint32Array(ab)
        };
    }()
};
Typr["T"].CFF = {
    parseTab: function(data, offset, length) {
        var bin = Typr["B"];
        var CFF = Typr["T"].CFF;
        data = new Uint8Array(data.buffer, offset, length);
        offset = 0;
        // Header
        data[offset];
        offset++;
        data[offset];
        offset++;
        data[offset];
        offset++;
        data[offset];
        offset++;
        //console.log(major, minor, hdrSize, offsize);
        // Name INDEX
        var ninds = [];
        offset = CFF.readIndex(data, offset, ninds);
        var names = [];
        for(var i = 0; i < ninds.length - 1; i++)names.push(bin.readASCII(data, offset + ninds[i], ninds[i + 1] - ninds[i]));
        offset += ninds[ninds.length - 1];
        // Top DICT INDEX
        var tdinds = [];
        offset = CFF.readIndex(data, offset, tdinds); //console.log(tdinds);
        // Top DICT Data
        var topDicts = [];
        for(var i = 0; i < tdinds.length - 1; i++)topDicts.push(CFF.readDict(data, offset + tdinds[i], offset + tdinds[i + 1]));
        offset += tdinds[tdinds.length - 1];
        var topdict = topDicts[0];
        //console.log(topdict);
        // String INDEX
        var sinds = [];
        offset = CFF.readIndex(data, offset, sinds);
        // String Data
        var strings = [];
        for(var i = 0; i < sinds.length - 1; i++)strings.push(bin.readASCII(data, offset + sinds[i], sinds[i + 1] - sinds[i]));
        offset += sinds[sinds.length - 1];
        // Global Subr INDEX  (subroutines)
        CFF.readSubrs(data, offset, topdict);
        // charstrings
        if (topdict["CharStrings"]) topdict["CharStrings"] = CFF.readBytes(data, topdict["CharStrings"]);
        // CID font
        if (topdict["ROS"]) {
            offset = topdict["FDArray"];
            var fdind = [];
            offset = CFF.readIndex(data, offset, fdind);
            topdict["FDArray"] = [];
            for(var i = 0; i < fdind.length - 1; i++){
                var dict = CFF.readDict(data, offset + fdind[i], offset + fdind[i + 1]);
                CFF._readFDict(data, dict, strings);
                topdict["FDArray"].push(dict);
            }
            offset += fdind[fdind.length - 1];
            offset = topdict["FDSelect"];
            topdict["FDSelect"] = [];
            var fmt = data[offset];
            offset++;
            if (fmt == 3) {
                var rns = bin.readUshort(data, offset);
                offset += 2;
                for(var i = 0; i < rns + 1; i++){
                    topdict["FDSelect"].push(bin.readUshort(data, offset), data[offset + 2]);
                    offset += 3;
                }
            } else throw fmt;
        }
        // Encoding
        //if(topdict["Encoding"]) topdict["Encoding"] = CFF.readEncoding(data, topdict["Encoding"], topdict["CharStrings"].length);
        // charset
        if (topdict["charset"]) topdict["charset"] = CFF.readCharset(data, topdict["charset"], topdict["CharStrings"].length);
        CFF._readFDict(data, topdict, strings);
        return topdict;
    },
    _readFDict: function(data, dict, ss) {
        var CFF = Typr["T"].CFF;
        var offset;
        if (dict["Private"]) {
            offset = dict["Private"][1];
            dict["Private"] = CFF.readDict(data, offset, offset + dict["Private"][0]);
            if (dict["Private"]["Subrs"]) CFF.readSubrs(data, offset + dict["Private"]["Subrs"], dict["Private"]);
        }
        for(var p in dict)if ([
            "FamilyName",
            "FontName",
            "FullName",
            "Notice",
            "version",
            "Copyright"
        ].indexOf(p) != -1) dict[p] = ss[dict[p] - 426 + 35];
    },
    readSubrs: function(data, offset, obj) {
        obj["Subrs"] = Typr["T"].CFF.readBytes(data, offset);
        var bias, nSubrs = obj["Subrs"].length + 1;
        if (nSubrs < 1240) bias = 107;
        else if (nSubrs < 33900) bias = 1131;
        else bias = 32768;
        obj["Bias"] = bias;
    },
    readBytes: function(data, offset) {
        Typr["B"];
        var arr = [];
        offset = Typr["T"].CFF.readIndex(data, offset, arr);
        var subrs = [], arl = arr.length - 1, no = data.byteOffset + offset;
        for(var i = 0; i < arl; i++){
            var ari = arr[i];
            subrs.push(new Uint8Array(data.buffer, no + ari, arr[i + 1] - ari));
        }
        return subrs;
    },
    tableSE: [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        28,
        29,
        30,
        31,
        32,
        33,
        34,
        35,
        36,
        37,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        59,
        60,
        61,
        62,
        63,
        64,
        65,
        66,
        67,
        68,
        69,
        70,
        71,
        72,
        73,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        82,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        91,
        92,
        93,
        94,
        95,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        96,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        0,
        111,
        112,
        113,
        114,
        0,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        0,
        123,
        0,
        124,
        125,
        126,
        127,
        128,
        129,
        130,
        131,
        0,
        132,
        133,
        0,
        134,
        135,
        136,
        137,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        138,
        0,
        139,
        0,
        0,
        0,
        0,
        140,
        141,
        142,
        143,
        0,
        0,
        0,
        0,
        0,
        144,
        0,
        0,
        0,
        145,
        0,
        0,
        146,
        147,
        148,
        149,
        0,
        0,
        0,
        0
    ],
    glyphByUnicode: function(cff, code) {
        for(var i = 0; i < cff["charset"].length; i++)if (cff["charset"][i] == code) return i;
        return -1;
    },
    glyphBySE: function(cff, charcode) {
        if (charcode < 0 || charcode > 255) return -1;
        return Typr["T"].CFF.glyphByUnicode(cff, Typr["T"].CFF.tableSE[charcode]);
    },
    /*readEncoding : function(data, offset, num)
  {
    var bin = Typr["B"];

    var array = ['.notdef'];
    var format = data[offset];  offset++;
    //console.log("Encoding");
    //console.log(format);

    if(format==0)
    {
      var nCodes = data[offset];  offset++;
      for(var i=0; i<nCodes; i++)  array.push(data[offset+i]);
    }
    /*
    else if(format==1 || format==2)
    {
      while(charset.length<num)
      {
        var first = bin.readUshort(data, offset);  offset+=2;
        var nLeft=0;
        if(format==1) {  nLeft = data[offset];  offset++;  }
        else          {  nLeft = bin.readUshort(data, offset);  offset+=2;  }
        for(var i=0; i<=nLeft; i++)  {  charset.push(first);  first++;  }
      }
    }

    else throw "error: unknown encoding format: " + format;

    return array;
  },*/ readCharset: function(data, offset, num) {
        var bin = Typr["B"];
        var charset = [
            '.notdef'
        ];
        var format = data[offset];
        offset++;
        if (format == 0) {
            for(var i = 0; i < num; i++){
                var first = bin.readUshort(data, offset);
                offset += 2;
                charset.push(first);
            }
        } else if (format == 1 || format == 2) {
            while(charset.length < num){
                var first = bin.readUshort(data, offset);
                offset += 2;
                var nLeft = 0;
                if (format == 1) {
                    nLeft = data[offset];
                    offset++;
                } else {
                    nLeft = bin.readUshort(data, offset);
                    offset += 2;
                }
                for(var i = 0; i <= nLeft; i++){
                    charset.push(first);
                    first++;
                }
            }
        } else throw "error: format: " + format;
        return charset;
    },
    readIndex: function(data, offset, inds) {
        var bin = Typr["B"];
        var count = bin.readUshort(data, offset) + 1;
        offset += 2;
        var offsize = data[offset];
        offset++;
        if (offsize == 1) for(var i = 0; i < count; i++)inds.push(data[offset + i]);
        else if (offsize == 2) for(var i = 0; i < count; i++)inds.push(bin.readUshort(data, offset + i * 2));
        else if (offsize == 3) for(var i = 0; i < count; i++)inds.push(bin.readUint(data, offset + i * 3 - 1) & 0x00ffffff);
        else if (offsize == 4) for(var i = 0; i < count; i++)inds.push(bin.readUint(data, offset + i * 4));
        else if (count != 1) throw "unsupported offset size: " + offsize + ", count: " + count;
        offset += count * offsize;
        return offset - 1;
    },
    getCharString: function(data, offset, o) {
        var bin = Typr["B"];
        var b0 = data[offset], b1 = data[offset + 1];
        data[offset + 2];
        data[offset + 3];
        data[offset + 4];
        var vs = 1;
        var op = null, val = null;
        // operand
        if (b0 <= 20) {
            op = b0;
            vs = 1;
        }
        if (b0 == 12) {
            op = b0 * 100 + b1;
            vs = 2;
        }
        //if(b0==19 || b0==20) { op = b0/*+" "+b1*/;  vs=2; }
        if (21 <= b0 && b0 <= 27) {
            op = b0;
            vs = 1;
        }
        if (b0 == 28) {
            val = bin.readShort(data, offset + 1);
            vs = 3;
        }
        if (29 <= b0 && b0 <= 31) {
            op = b0;
            vs = 1;
        }
        if (32 <= b0 && b0 <= 246) {
            val = b0 - 139;
            vs = 1;
        }
        if (247 <= b0 && b0 <= 250) {
            val = (b0 - 247) * 256 + b1 + 108;
            vs = 2;
        }
        if (251 <= b0 && b0 <= 254) {
            val = -(b0 - 251) * 256 - b1 - 108;
            vs = 2;
        }
        if (b0 == 255) {
            val = bin.readInt(data, offset + 1) / 0xffff;
            vs = 5;
        }
        o.val = val != null ? val : "o" + op;
        o.size = vs;
    },
    readCharString: function(data, offset, length) {
        var end = offset + length;
        var bin = Typr["B"];
        var arr = [];
        while(offset < end){
            var b0 = data[offset], b1 = data[offset + 1];
            data[offset + 2];
            data[offset + 3];
            data[offset + 4];
            var vs = 1;
            var op = null, val = null;
            // operand
            if (b0 <= 20) {
                op = b0;
                vs = 1;
            }
            if (b0 == 12) {
                op = b0 * 100 + b1;
                vs = 2;
            }
            if (b0 == 19 || b0 == 20) {
                op = b0 /*+" "+b1*/ ;
                vs = 2;
            }
            if (21 <= b0 && b0 <= 27) {
                op = b0;
                vs = 1;
            }
            if (b0 == 28) {
                val = bin.readShort(data, offset + 1);
                vs = 3;
            }
            if (29 <= b0 && b0 <= 31) {
                op = b0;
                vs = 1;
            }
            if (32 <= b0 && b0 <= 246) {
                val = b0 - 139;
                vs = 1;
            }
            if (247 <= b0 && b0 <= 250) {
                val = (b0 - 247) * 256 + b1 + 108;
                vs = 2;
            }
            if (251 <= b0 && b0 <= 254) {
                val = -(b0 - 251) * 256 - b1 - 108;
                vs = 2;
            }
            if (b0 == 255) {
                val = bin.readInt(data, offset + 1) / 0xffff;
                vs = 5;
            }
            arr.push(val != null ? val : "o" + op);
            offset += vs;
        //var cv = arr[arr.length-1];
        //if(cv==undefined) throw "error";
        //console.log()
        }
        return arr;
    },
    readDict: function(data, offset, end) {
        var bin = Typr["B"];
        //var dict = [];
        var dict = {};
        var carr = [];
        while(offset < end){
            var b0 = data[offset], b1 = data[offset + 1];
            data[offset + 2];
            data[offset + 3];
            data[offset + 4];
            var vs = 1;
            var key = null, val = null;
            // operand
            if (b0 == 28) {
                val = bin.readShort(data, offset + 1);
                vs = 3;
            }
            if (b0 == 29) {
                val = bin.readInt(data, offset + 1);
                vs = 5;
            }
            if (32 <= b0 && b0 <= 246) {
                val = b0 - 139;
                vs = 1;
            }
            if (247 <= b0 && b0 <= 250) {
                val = (b0 - 247) * 256 + b1 + 108;
                vs = 2;
            }
            if (251 <= b0 && b0 <= 254) {
                val = -(b0 - 251) * 256 - b1 - 108;
                vs = 2;
            }
            if (b0 == 255) {
                val = bin.readInt(data, offset + 1) / 0xffff;
                vs = 5;
                throw "unknown number";
            }
            if (b0 == 30) {
                var nibs = [];
                vs = 1;
                while(true){
                    var b = data[offset + vs];
                    vs++;
                    var nib0 = b >> 4, nib1 = b & 0xf;
                    if (nib0 != 0xf) nibs.push(nib0);
                    if (nib1 != 0xf) nibs.push(nib1);
                    if (nib1 == 0xf) break;
                }
                var s = "";
                var chars = [
                    0,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    ".",
                    "e",
                    "e-",
                    "reserved",
                    "-",
                    "endOfNumber"
                ];
                for(var i = 0; i < nibs.length; i++)s += chars[nibs[i]];
                //console.log(nibs);
                val = parseFloat(s);
            }
            if (b0 <= 21) {
                var keys = [
                    "version",
                    "Notice",
                    "FullName",
                    "FamilyName",
                    "Weight",
                    "FontBBox",
                    "BlueValues",
                    "OtherBlues",
                    "FamilyBlues",
                    "FamilyOtherBlues",
                    "StdHW",
                    "StdVW",
                    "escape",
                    "UniqueID",
                    "XUID",
                    "charset",
                    "Encoding",
                    "CharStrings",
                    "Private",
                    "Subrs",
                    "defaultWidthX",
                    "nominalWidthX"
                ];
                key = keys[b0];
                vs = 1;
                if (b0 == 12) {
                    var keys = [
                        "Copyright",
                        "isFixedPitch",
                        "ItalicAngle",
                        "UnderlinePosition",
                        "UnderlineThickness",
                        "PaintType",
                        "CharstringType",
                        "FontMatrix",
                        "StrokeWidth",
                        "BlueScale",
                        "BlueShift",
                        "BlueFuzz",
                        "StemSnapH",
                        "StemSnapV",
                        "ForceBold",
                        "",
                        "",
                        "LanguageGroup",
                        "ExpansionFactor",
                        "initialRandomSeed",
                        "SyntheticBase",
                        "PostScript",
                        "BaseFontName",
                        "BaseFontBlend",
                        "",
                        "",
                        "",
                        "",
                        "",
                        "",
                        "ROS",
                        "CIDFontVersion",
                        "CIDFontRevision",
                        "CIDFontType",
                        "CIDCount",
                        "UIDBase",
                        "FDArray",
                        "FDSelect",
                        "FontName"
                    ];
                    key = keys[b1];
                    vs = 2;
                }
            }
            if (key != null) {
                dict[key] = carr.length == 1 ? carr[0] : carr;
                carr = [];
            } else carr.push(val);
            offset += vs;
        }
        return dict;
    }
};
Typr["T"].cmap = {
    parseTab: function(data, offset, length) {
        var obj = {
            tables: [],
            ids: {},
            off: offset
        };
        data = new Uint8Array(data.buffer, offset, length);
        offset = 0;
        var bin = Typr["B"], rU = bin.readUshort, cmap = Typr["T"].cmap;
        rU(data, offset);
        offset += 2;
        var numTables = rU(data, offset);
        offset += 2;
        //console.log(version, numTables);
        var offs = [];
        for(var i = 0; i < numTables; i++){
            var platformID = rU(data, offset);
            offset += 2;
            var encodingID = rU(data, offset);
            offset += 2;
            var noffset = bin.readUint(data, offset);
            offset += 4;
            var id = "p" + platformID + "e" + encodingID;
            //console.log("cmap subtable", platformID, encodingID, noffset);
            var tind = offs.indexOf(noffset);
            if (tind == -1) {
                tind = obj.tables.length;
                var subt = {};
                offs.push(noffset);
                //var time = Date.now();
                var format = subt.format = rU(data, noffset);
                if (format == 0) subt = cmap.parse0(data, noffset, subt);
                else if (format == 4) subt = cmap.parse4(data, noffset, subt);
                else if (format == 6) subt = cmap.parse6(data, noffset, subt);
                else if (format == 12) subt = cmap.parse12(data, noffset, subt);
                //console.log(format, Date.now()-time);
                //else console.log("unknown format: "+format, platformID, encodingID, noffset);
                obj.tables.push(subt);
            }
            if (obj.ids[id] != null) console.log("multiple tables for one platform+encoding: " + id);
            obj.ids[id] = tind;
        }
        return obj;
    },
    parse0: function(data, offset, obj) {
        var bin = Typr["B"];
        offset += 2;
        var len = bin.readUshort(data, offset);
        offset += 2;
        bin.readUshort(data, offset);
        offset += 2;
        obj.map = [];
        for(var i = 0; i < len - 6; i++)obj.map.push(data[offset + i]);
        return obj;
    },
    parse4: function(data, offset, obj) {
        var bin = Typr["B"], rU = bin.readUshort, rUs = bin.readUshorts;
        var offset0 = offset;
        offset += 2;
        var length = rU(data, offset);
        offset += 2;
        rU(data, offset);
        offset += 2;
        var segCountX2 = rU(data, offset);
        offset += 2;
        var segCount = segCountX2 >>> 1;
        obj.searchRange = rU(data, offset);
        offset += 2;
        obj.entrySelector = rU(data, offset);
        offset += 2;
        obj.rangeShift = rU(data, offset);
        offset += 2;
        obj.endCount = rUs(data, offset, segCount);
        offset += segCount * 2;
        offset += 2;
        obj.startCount = rUs(data, offset, segCount);
        offset += segCount * 2;
        obj.idDelta = [];
        for(var i = 0; i < segCount; i++){
            obj.idDelta.push(bin.readShort(data, offset));
            offset += 2;
        }
        obj.idRangeOffset = rUs(data, offset, segCount);
        offset += segCount * 2;
        obj.glyphIdArray = rUs(data, offset, offset0 + length - offset >> 1); //offset += segCount*2;
        return obj;
    },
    parse6: function(data, offset, obj) {
        var bin = Typr["B"];
        offset += 2;
        bin.readUshort(data, offset);
        offset += 2;
        bin.readUshort(data, offset);
        offset += 2;
        obj.firstCode = bin.readUshort(data, offset);
        offset += 2;
        var entryCount = bin.readUshort(data, offset);
        offset += 2;
        obj.glyphIdArray = [];
        for(var i = 0; i < entryCount; i++){
            obj.glyphIdArray.push(bin.readUshort(data, offset));
            offset += 2;
        }
        return obj;
    },
    parse12: function(data, offset, obj) {
        var bin = Typr["B"], rU = bin.readUint;
        offset += 4;
        rU(data, offset);
        offset += 4;
        rU(data, offset);
        offset += 4;
        var nGroups = rU(data, offset) * 3;
        offset += 4;
        var gps = obj.groups = new Uint32Array(nGroups); //new Uint32Array(data.slice(offset, offset+nGroups*12).buffer);
        for(var i = 0; i < nGroups; i += 3){
            gps[i] = rU(data, offset + (i << 2));
            gps[i + 1] = rU(data, offset + (i << 2) + 4);
            gps[i + 2] = rU(data, offset + (i << 2) + 8);
        }
        return obj;
    }
};
Typr["T"].CBLC = {
    parseTab: function(data, offset, length) {
        var bin = Typr["B"], ooff = offset;
        bin.readUshort(data, offset);
        offset += 2;
        bin.readUshort(data, offset);
        offset += 2;
        var numSizes = bin.readUint(data, offset);
        offset += 4;
        var out = [];
        for(var i = 0; i < numSizes; i++){
            var off = bin.readUint(data, offset);
            offset += 4; // indexSubTableArrayOffset
            bin.readUint(data, offset);
            offset += 4; // indexTablesSize
            bin.readUint(data, offset);
            offset += 4; // numberOfIndexSubTables
            offset += 4;
            offset += 2 * 12;
            bin.readUshort(data, offset);
            offset += 2;
            bin.readUshort(data, offset);
            offset += 2;
            //console.log(off,siz,num, sGlyph, eGlyph);
            offset += 4;
            var coff = ooff + off;
            for(var j = 0; j < 3; j++){
                var fgI = bin.readUshort(data, coff);
                coff += 2;
                var lgI = bin.readUshort(data, coff);
                coff += 2;
                var nxt = bin.readUint(data, coff);
                coff += 4;
                var gcnt = lgI - fgI + 1;
                //console.log(fgI, lgI, nxt);   //if(nxt==0) break;
                var ioff = ooff + off + nxt;
                var inF = bin.readUshort(data, ioff);
                ioff += 2;
                if (inF != 1) throw inF;
                var imF = bin.readUshort(data, ioff);
                ioff += 2;
                var imgo = bin.readUint(data, ioff);
                ioff += 4;
                var oarr = [];
                for(var gi = 0; gi < gcnt; gi++){
                    var sbitO = bin.readUint(data, ioff + gi * 4);
                    oarr.push(imgo + sbitO);
                //console.log("--",sbitO);
                }
                out.push([
                    fgI,
                    lgI,
                    imF,
                    oarr
                ]);
            }
        }
        return out;
    }
};
Typr["T"].CBDT = {
    parseTab: function(data, offset, length) {
        Typr["B"];
        //var maj = bin.readUshort(data,offset);  offset+=2;
        //var min = bin.readUshort(data,offset);  offset+=2;
        return new Uint8Array(data.buffer, data.byteOffset + offset, length);
    }
};
Typr["T"].glyf = {
    parseTab: function(data, offset, length, font) {
        var obj = [], ng = font["maxp"]["numGlyphs"];
        for(var g = 0; g < ng; g++)obj.push(null);
        return obj;
    },
    _parseGlyf: function(font, g) {
        var bin = Typr["B"];
        var data = font["_data"], loca = font["loca"];
        if (loca[g] == loca[g + 1]) return null;
        var offset = Typr["findTable"](data, "glyf", font["_offset"])[0] + loca[g];
        var gl = {};
        gl.noc = bin.readShort(data, offset);
        offset += 2; // number of contours
        gl.xMin = bin.readShort(data, offset);
        offset += 2;
        gl.yMin = bin.readShort(data, offset);
        offset += 2;
        gl.xMax = bin.readShort(data, offset);
        offset += 2;
        gl.yMax = bin.readShort(data, offset);
        offset += 2;
        if (gl.xMin >= gl.xMax || gl.yMin >= gl.yMax) return null;
        if (gl.noc > 0) {
            gl.endPts = [];
            for(var i = 0; i < gl.noc; i++){
                gl.endPts.push(bin.readUshort(data, offset));
                offset += 2;
            }
            var instructionLength = bin.readUshort(data, offset);
            offset += 2;
            if (data.length - offset < instructionLength) return null;
            gl.instructions = bin.readBytes(data, offset, instructionLength);
            offset += instructionLength;
            var crdnum = gl.endPts[gl.noc - 1] + 1;
            gl.flags = [];
            for(var i = 0; i < crdnum; i++){
                var flag = data[offset];
                offset++;
                gl.flags.push(flag);
                if ((flag & 8) != 0) {
                    var rep = data[offset];
                    offset++;
                    for(var j = 0; j < rep; j++){
                        gl.flags.push(flag);
                        i++;
                    }
                }
            }
            gl.xs = [];
            for(var i = 0; i < crdnum; i++){
                var i8 = (gl.flags[i] & 2) != 0, same = (gl.flags[i] & 16) != 0;
                if (i8) {
                    gl.xs.push(same ? data[offset] : -data[offset]);
                    offset++;
                } else {
                    if (same) gl.xs.push(0);
                    else {
                        gl.xs.push(bin.readShort(data, offset));
                        offset += 2;
                    }
                }
            }
            gl.ys = [];
            for(var i = 0; i < crdnum; i++){
                var i8 = (gl.flags[i] & 4) != 0, same = (gl.flags[i] & 32) != 0;
                if (i8) {
                    gl.ys.push(same ? data[offset] : -data[offset]);
                    offset++;
                } else {
                    if (same) gl.ys.push(0);
                    else {
                        gl.ys.push(bin.readShort(data, offset));
                        offset += 2;
                    }
                }
            }
            var x = 0, y = 0;
            for(var i = 0; i < crdnum; i++){
                x += gl.xs[i];
                y += gl.ys[i];
                gl.xs[i] = x;
                gl.ys[i] = y;
            }
        //console.log(endPtsOfContours, instructionLength, instructions, flags, xCoordinates, yCoordinates);
        } else {
            var ARG_1_AND_2_ARE_WORDS = 1 << 0;
            var ARGS_ARE_XY_VALUES = 1 << 1;
            var WE_HAVE_A_SCALE = 1 << 3;
            var MORE_COMPONENTS = 1 << 5;
            var WE_HAVE_AN_X_AND_Y_SCALE = 1 << 6;
            var WE_HAVE_A_TWO_BY_TWO = 1 << 7;
            var WE_HAVE_INSTRUCTIONS = 1 << 8;
            gl.parts = [];
            var flags;
            do {
                flags = bin.readUshort(data, offset);
                offset += 2;
                var part = {
                    m: {
                        a: 1,
                        b: 0,
                        c: 0,
                        d: 1,
                        tx: 0,
                        ty: 0
                    },
                    p1: -1,
                    p2: -1
                };
                gl.parts.push(part);
                part.glyphIndex = bin.readUshort(data, offset);
                offset += 2;
                if (flags & ARG_1_AND_2_ARE_WORDS) {
                    var arg1 = bin.readShort(data, offset);
                    offset += 2;
                    var arg2 = bin.readShort(data, offset);
                    offset += 2;
                } else {
                    var arg1 = bin.readInt8(data, offset);
                    offset++;
                    var arg2 = bin.readInt8(data, offset);
                    offset++;
                }
                if (flags & ARGS_ARE_XY_VALUES) {
                    part.m.tx = arg1;
                    part.m.ty = arg2;
                } else {
                    part.p1 = arg1;
                    part.p2 = arg2;
                }
                //part.m.tx = arg1;  part.m.ty = arg2;
                //else { throw "params are not XY values"; }
                if (flags & WE_HAVE_A_SCALE) {
                    part.m.a = part.m.d = bin.readF2dot14(data, offset);
                    offset += 2;
                } else if (flags & WE_HAVE_AN_X_AND_Y_SCALE) {
                    part.m.a = bin.readF2dot14(data, offset);
                    offset += 2;
                    part.m.d = bin.readF2dot14(data, offset);
                    offset += 2;
                } else if (flags & WE_HAVE_A_TWO_BY_TWO) {
                    part.m.a = bin.readF2dot14(data, offset);
                    offset += 2;
                    part.m.b = bin.readF2dot14(data, offset);
                    offset += 2;
                    part.m.c = bin.readF2dot14(data, offset);
                    offset += 2;
                    part.m.d = bin.readF2dot14(data, offset);
                    offset += 2;
                }
            }while (flags & MORE_COMPONENTS)
            if (flags & WE_HAVE_INSTRUCTIONS) {
                var numInstr = bin.readUshort(data, offset);
                offset += 2;
                gl.instr = [];
                for(var i = 0; i < numInstr; i++){
                    gl.instr.push(data[offset]);
                    offset++;
                }
            }
        }
        return gl;
    }
};
Typr["T"].head = {
    parseTab: function(data, offset, length) {
        var bin = Typr["B"];
        var obj = {};
        bin.readFixed(data, offset);
        offset += 4;
        obj["fontRevision"] = bin.readFixed(data, offset);
        offset += 4;
        bin.readUint(data, offset);
        offset += 4;
        bin.readUint(data, offset);
        offset += 4;
        obj["flags"] = bin.readUshort(data, offset);
        offset += 2;
        obj["unitsPerEm"] = bin.readUshort(data, offset);
        offset += 2;
        obj["created"] = bin.readUint64(data, offset);
        offset += 8;
        obj["modified"] = bin.readUint64(data, offset);
        offset += 8;
        obj["xMin"] = bin.readShort(data, offset);
        offset += 2;
        obj["yMin"] = bin.readShort(data, offset);
        offset += 2;
        obj["xMax"] = bin.readShort(data, offset);
        offset += 2;
        obj["yMax"] = bin.readShort(data, offset);
        offset += 2;
        obj["macStyle"] = bin.readUshort(data, offset);
        offset += 2;
        obj["lowestRecPPEM"] = bin.readUshort(data, offset);
        offset += 2;
        obj["fontDirectionHint"] = bin.readShort(data, offset);
        offset += 2;
        obj["indexToLocFormat"] = bin.readShort(data, offset);
        offset += 2;
        obj["glyphDataFormat"] = bin.readShort(data, offset);
        offset += 2;
        return obj;
    }
};
Typr["T"].hhea = {
    parseTab: function(data, offset, length) {
        var bin = Typr["B"];
        var obj = {};
        bin.readFixed(data, offset);
        offset += 4;
        var keys = [
            "ascender",
            "descender",
            "lineGap",
            "advanceWidthMax",
            "minLeftSideBearing",
            "minRightSideBearing",
            "xMaxExtent",
            "caretSlopeRise",
            "caretSlopeRun",
            "caretOffset",
            "res0",
            "res1",
            "res2",
            "res3",
            "metricDataFormat",
            "numberOfHMetrics"
        ];
        for(var i = 0; i < keys.length; i++){
            var key = keys[i];
            var func = key == "advanceWidthMax" || key == "numberOfHMetrics" ? bin.readUshort : bin.readShort;
            obj[key] = func(data, offset + i * 2);
        }
        return obj;
    }
};
Typr["T"].hmtx = {
    parseTab: function(data, offset, length, font) {
        var bin = Typr["B"];
        var aWidth = [];
        var lsBearing = [];
        var nG = font["maxp"]["numGlyphs"], nH = font["hhea"]["numberOfHMetrics"];
        var aw = 0, lsb = 0, i = 0;
        while(i < nH){
            aw = bin.readUshort(data, offset + (i << 2));
            lsb = bin.readShort(data, offset + (i << 2) + 2);
            aWidth.push(aw);
            lsBearing.push(lsb);
            i++;
        }
        while(i < nG){
            aWidth.push(aw);
            lsBearing.push(lsb);
            i++;
        }
        return {
            aWidth: aWidth,
            lsBearing: lsBearing
        };
    }
};
Typr["T"].kern = {
    parseTab: function(data, offset, length, font) {
        var bin = Typr["B"], kern = Typr["T"].kern;
        var version = bin.readUshort(data, offset);
        if (version == 1) return kern.parseV1(data, offset, length, font);
        var nTables = bin.readUshort(data, offset + 2);
        offset += 4;
        var map = {
            glyph1: [],
            rval: []
        };
        for(var i = 0; i < nTables; i++){
            offset += 2; // skip version
            var length = bin.readUshort(data, offset);
            offset += 2;
            var coverage = bin.readUshort(data, offset);
            offset += 2;
            var format = coverage >>> 8;
            /* I have seen format 128 once, that's why I do */ format &= 0xf;
            if (format == 0) offset = kern.readFormat0(data, offset, map);
        //else throw "unknown kern table format: "+format;
        }
        return map;
    },
    parseV1: function(data, offset, length, font) {
        var bin = Typr["B"], kern = Typr["T"].kern;
        bin.readFixed(data, offset); // 0x00010000
        var nTables = bin.readUint(data, offset + 4);
        offset += 8;
        var map = {
            glyph1: [],
            rval: []
        };
        for(var i = 0; i < nTables; i++){
            bin.readUint(data, offset);
            offset += 4;
            var coverage = bin.readUshort(data, offset);
            offset += 2;
            bin.readUshort(data, offset);
            offset += 2;
            var format = coverage & 0xff;
            if (format == 0) offset = kern.readFormat0(data, offset, map);
        //else throw "unknown kern table format: "+format;
        }
        return map;
    },
    readFormat0: function(data, offset, map) {
        var bin = Typr["B"], rUs = bin.readUshort;
        var pleft = -1;
        var nPairs = rUs(data, offset);
        rUs(data, offset + 2);
        rUs(data, offset + 4);
        rUs(data, offset + 6);
        offset += 8;
        for(var j = 0; j < nPairs; j++){
            var left = rUs(data, offset);
            offset += 2;
            var right = rUs(data, offset);
            offset += 2;
            var value = bin.readShort(data, offset);
            offset += 2;
            if (left != pleft) {
                map.glyph1.push(left);
                map.rval.push({
                    glyph2: [],
                    vals: []
                });
            }
            var rval = map.rval[map.rval.length - 1];
            rval.glyph2.push(right);
            rval.vals.push(value);
            pleft = left;
        }
        return offset;
    }
};
Typr["T"].loca = {
    parseTab: function(data, offset, length, font) {
        var bin = Typr["B"];
        var obj = [];
        var ver = font["head"]["indexToLocFormat"];
        var len = font["maxp"]["numGlyphs"] + 1;
        if (ver == 0) for(var i = 0; i < len; i++)obj.push(bin.readUshort(data, offset + (i << 1)) << 1);
        if (ver == 1) for(var i = 0; i < len; i++)obj.push(bin.readUint(data, offset + (i << 2)));
        return obj;
    }
};
Typr["T"].maxp = {
    parseTab: function(data, offset, length) {
        //console.log(data.length, offset, length);
        var bin = Typr["B"], rU = bin.readUshort;
        var obj = {};
        // both versions 0.5 and 1.0
        bin.readUint(data, offset);
        offset += 4;
        obj["numGlyphs"] = rU(data, offset);
        offset += 2;
        // only 1.0
        /*
    if(ver == 0x00010000) {
      obj.maxPoints             = rU(data, offset);  offset += 2;
      obj.maxContours           = rU(data, offset);  offset += 2;
      obj.maxCompositePoints    = rU(data, offset);  offset += 2;
      obj.maxCompositeContours  = rU(data, offset);  offset += 2;
      obj.maxZones              = rU(data, offset);  offset += 2;
      obj.maxTwilightPoints     = rU(data, offset);  offset += 2;
      obj.maxStorage            = rU(data, offset);  offset += 2;
      obj.maxFunctionDefs       = rU(data, offset);  offset += 2;
      obj.maxInstructionDefs    = rU(data, offset);  offset += 2;
      obj.maxStackElements      = rU(data, offset);  offset += 2;
      obj.maxSizeOfInstructions = rU(data, offset);  offset += 2;
      obj.maxComponentElements  = rU(data, offset);  offset += 2;
      obj.maxComponentDepth     = rU(data, offset);  offset += 2;
    }
    */ return obj;
    }
};
Typr["T"].name = {
    parseTab: function(data, offset, length) {
        var bin = Typr["B"];
        var obj = {};
        bin.readUshort(data, offset);
        offset += 2;
        var count = bin.readUshort(data, offset);
        offset += 2;
        var stringOffset = bin.readUshort(data, offset);
        offset += 2;
        var ooo = offset - 6 + stringOffset;
        //console.log(format,count);
        var names = [
            "copyright",
            "fontFamily",
            "fontSubfamily",
            "ID",
            "fullName",
            "version",
            "postScriptName",
            "trademark",
            "manufacturer",
            "designer",
            "description",
            "urlVendor",
            "urlDesigner",
            "licence",
            "licenceURL",
            "---",
            "typoFamilyName",
            "typoSubfamilyName",
            "compatibleFull",
            "sampleText",
            "postScriptCID",
            "wwsFamilyName",
            "wwsSubfamilyName",
            "lightPalette",
            "darkPalette"
        ];
        var rU = bin.readUshort;
        for(var i = 0; i < count; i++){
            var platformID = rU(data, offset);
            offset += 2;
            var encodingID = rU(data, offset);
            offset += 2;
            var languageID = rU(data, offset);
            offset += 2;
            var nameID = rU(data, offset);
            offset += 2;
            var slen = rU(data, offset);
            offset += 2;
            var noffset = rU(data, offset);
            offset += 2;
            //console.log(platformID, encodingID, languageID.toString(16), nameID, length, noffset);
            var soff = ooo + noffset;
            var str;
            if (platformID == 0) str = bin.readUnicode(data, soff, slen / 2);
            else if (platformID == 3 && encodingID == 0) str = bin.readUnicode(data, soff, slen / 2);
            else if (platformID == 1 && encodingID == 25) str = bin.readUnicode(data, soff, slen / 2);
            else if (encodingID == 0) str = bin.readASCII(data, soff, slen);
            else if (encodingID == 1) str = bin.readUnicode(data, soff, slen / 2);
            else if (encodingID == 3) str = bin.readUnicode(data, soff, slen / 2);
            else if (encodingID == 4) str = bin.readUnicode(data, soff, slen / 2);
            else if (encodingID == 5) str = bin.readUnicode(data, soff, slen / 2);
            else if (encodingID == 10) str = bin.readUnicode(data, soff, slen / 2);
            else if (platformID == 1) {
                str = bin.readASCII(data, soff, slen);
                console.log("reading unknown MAC encoding " + encodingID + " as ASCII");
            } else {
                console.log("unknown encoding " + encodingID + ", platformID: " + platformID);
                str = bin.readASCII(data, soff, slen);
            }
            var tid = "p" + platformID + "," + languageID.toString(16); //Typr._platforms[platformID];
            if (obj[tid] == null) obj[tid] = {};
            var name = names[nameID];
            if (name == null) name = "_" + nameID;
            obj[tid][name] = str;
            obj[tid]["_lang"] = languageID;
        //console.log(tid, obj[tid]);
        }
        /*
    if(format == 1)
    {
      var langTagCount = bin.readUshort(data, offset);  offset += 2;
      for(var i=0; i<langTagCount; i++)
      {
        var length  = bin.readUshort(data, offset);  offset += 2;
        var noffset = bin.readUshort(data, offset);  offset += 2;
      }
    }
    */ var out = Typr["T"].name.selectOne(obj), ff = "fontFamily";
        if (out[ff] == null) {
            for(var p in obj)if (obj[p][ff] != null) out[ff] = obj[p][ff];
        }
        return out;
    },
    selectOne: function(obj) {
        //console.log(obj);
        var psn = "postScriptName";
        for(var p in obj)if (obj[p][psn] != null && obj[p]["_lang"] == 0x0409) return obj[p]; // United States
        for(var p in obj)if (obj[p][psn] != null && obj[p]["_lang"] == 0x0000) return obj[p]; // Universal
        for(var p in obj)if (obj[p][psn] != null && obj[p]["_lang"] == 0x0c0c) return obj[p]; // Canada
        for(var p in obj)if (obj[p][psn] != null) return obj[p];
        var out;
        for(var p in obj){
            out = obj[p];
            break;
        }
        console.log("returning name table with languageID " + out._lang);
        if (out[psn] == null && out["ID"] != null) out[psn] = out["ID"];
        return out;
    }
};
Typr["T"].OS2 = {
    parseTab: function(data, offset, length) {
        var bin = Typr["B"];
        var ver = bin.readUshort(data, offset);
        offset += 2;
        var OS2 = Typr["T"].OS2;
        var obj = {};
        if (ver == 0) OS2.version0(data, offset, obj);
        else if (ver == 1) OS2.version1(data, offset, obj);
        else if (ver == 2 || ver == 3 || ver == 4) OS2.version2(data, offset, obj);
        else if (ver == 5) OS2.version5(data, offset, obj);
        else throw "unknown OS/2 table version: " + ver;
        return obj;
    },
    version0: function(data, offset, obj) {
        var bin = Typr["B"];
        obj["xAvgCharWidth"] = bin.readShort(data, offset);
        offset += 2;
        obj["usWeightClass"] = bin.readUshort(data, offset);
        offset += 2;
        obj["usWidthClass"] = bin.readUshort(data, offset);
        offset += 2;
        obj["fsType"] = bin.readUshort(data, offset);
        offset += 2;
        obj["ySubscriptXSize"] = bin.readShort(data, offset);
        offset += 2;
        obj["ySubscriptYSize"] = bin.readShort(data, offset);
        offset += 2;
        obj["ySubscriptXOffset"] = bin.readShort(data, offset);
        offset += 2;
        obj["ySubscriptYOffset"] = bin.readShort(data, offset);
        offset += 2;
        obj["ySuperscriptXSize"] = bin.readShort(data, offset);
        offset += 2;
        obj["ySuperscriptYSize"] = bin.readShort(data, offset);
        offset += 2;
        obj["ySuperscriptXOffset"] = bin.readShort(data, offset);
        offset += 2;
        obj["ySuperscriptYOffset"] = bin.readShort(data, offset);
        offset += 2;
        obj["yStrikeoutSize"] = bin.readShort(data, offset);
        offset += 2;
        obj["yStrikeoutPosition"] = bin.readShort(data, offset);
        offset += 2;
        obj["sFamilyClass"] = bin.readShort(data, offset);
        offset += 2;
        obj["panose"] = bin.readBytes(data, offset, 10);
        offset += 10;
        obj["ulUnicodeRange1"] = bin.readUint(data, offset);
        offset += 4;
        obj["ulUnicodeRange2"] = bin.readUint(data, offset);
        offset += 4;
        obj["ulUnicodeRange3"] = bin.readUint(data, offset);
        offset += 4;
        obj["ulUnicodeRange4"] = bin.readUint(data, offset);
        offset += 4;
        obj["achVendID"] = bin.readASCII(data, offset, 4);
        offset += 4;
        obj["fsSelection"] = bin.readUshort(data, offset);
        offset += 2;
        obj["usFirstCharIndex"] = bin.readUshort(data, offset);
        offset += 2;
        obj["usLastCharIndex"] = bin.readUshort(data, offset);
        offset += 2;
        obj["sTypoAscender"] = bin.readShort(data, offset);
        offset += 2;
        obj["sTypoDescender"] = bin.readShort(data, offset);
        offset += 2;
        obj["sTypoLineGap"] = bin.readShort(data, offset);
        offset += 2;
        obj["usWinAscent"] = bin.readUshort(data, offset);
        offset += 2;
        obj["usWinDescent"] = bin.readUshort(data, offset);
        offset += 2;
        return offset;
    },
    version1: function(data, offset, obj) {
        var bin = Typr["B"];
        offset = Typr["T"].OS2.version0(data, offset, obj);
        obj["ulCodePageRange1"] = bin.readUint(data, offset);
        offset += 4;
        obj["ulCodePageRange2"] = bin.readUint(data, offset);
        offset += 4;
        return offset;
    },
    version2: function(data, offset, obj) {
        var bin = Typr["B"], rU = bin.readUshort;
        offset = Typr["T"].OS2.version1(data, offset, obj);
        obj["sxHeight"] = bin.readShort(data, offset);
        offset += 2;
        obj["sCapHeight"] = bin.readShort(data, offset);
        offset += 2;
        obj["usDefault"] = rU(data, offset);
        offset += 2;
        obj["usBreak"] = rU(data, offset);
        offset += 2;
        obj["usMaxContext"] = rU(data, offset);
        offset += 2;
        return offset;
    },
    version5: function(data, offset, obj) {
        var rU = Typr["B"].readUshort;
        offset = Typr["T"].OS2.version2(data, offset, obj);
        obj["usLowerOpticalPointSize"] = rU(data, offset);
        offset += 2;
        obj["usUpperOpticalPointSize"] = rU(data, offset);
        offset += 2;
        return offset;
    }
};
Typr["T"].post = {
    parseTab: function(data, offset, length) {
        var bin = Typr["B"];
        var obj = {};
        obj["version"] = bin.readFixed(data, offset);
        offset += 4;
        obj["italicAngle"] = bin.readFixed(data, offset);
        offset += 4;
        obj["underlinePosition"] = bin.readShort(data, offset);
        offset += 2;
        obj["underlineThickness"] = bin.readShort(data, offset);
        offset += 2;
        return obj;
    }
};
Typr["T"].SVG = {
    parseTab: function(data, offset, length) {
        var bin = Typr["B"];
        var obj = {
            entries: [],
            svgs: []
        };
        var offset0 = offset;
        bin.readUshort(data, offset);
        offset += 2;
        var svgDocIndexOffset = bin.readUint(data, offset);
        offset += 4;
        bin.readUint(data, offset);
        offset += 4;
        offset = svgDocIndexOffset + offset0;
        var numEntries = bin.readUshort(data, offset);
        offset += 2;
        for(var i = 0; i < numEntries; i++){
            var startGlyphID = bin.readUshort(data, offset);
            offset += 2;
            var endGlyphID = bin.readUshort(data, offset);
            offset += 2;
            var svgDocOffset = bin.readUint(data, offset);
            offset += 4;
            var svgDocLength = bin.readUint(data, offset);
            offset += 4;
            var sbuf = new Uint8Array(data.buffer, offset0 + svgDocOffset + svgDocIndexOffset, svgDocLength);
            if (sbuf[0] == 0x1f && sbuf[1] == 0x8b && sbuf[2] == 0x08) sbuf = pako["inflate"](sbuf);
            var svg = bin.readUTF8(sbuf, 0, sbuf.length);
            for(var f = startGlyphID; f <= endGlyphID; f++){
                obj.entries[f] = obj.svgs.length;
            }
            obj.svgs.push(svg);
        }
        return obj;
    }
};
Typr["T"].sbix = {
    parseTab: function(data, offset, length, obj) {
        var numGlyphs = obj["maxp"]["numGlyphs"];
        var ooff = offset;
        var bin = Typr["B"];
        //var ver = bin.readUshort(data,offset);  offset+=2;
        //var flg = bin.readUshort(data,offset);  offset+=2;
        var numStrikes = bin.readUint(data, offset + 4);
        var out = [];
        for(var si = numStrikes - 1; si < numStrikes; si++){
            var off = ooff + bin.readUint(data, offset + 8 + si * 4);
            //var ppem = bin.readUshort(data,off);  off+=2;
            //var ppi  = bin.readUshort(data,off);  off+=2;
            for(var gi = 0; gi < numGlyphs; gi++){
                var aoff = bin.readUint(data, off + 4 + gi * 4);
                var noff = bin.readUint(data, off + 4 + gi * 4 + 4);
                if (aoff == noff) {
                    out[gi] = null;
                    continue;
                }
                var go = off + aoff;
                //var ooX = bin.readUshort(data,go);
                //var ooY = bin.readUshort(data,go+2);
                var tag = bin.readASCII(data, go + 4, 4);
                if (tag != "png ") throw tag;
                out[gi] = new Uint8Array(data.buffer, data.byteOffset + go + 8, noff - aoff - 8);
            }
        }
        return out;
    }
};
Typr["T"].colr = {
    parseTab: function(data, offset, length) {
        var bin = Typr["B"];
        var ooff = offset;
        offset += 2;
        var num = bin.readUshort(data, offset);
        offset += 2;
        var boff = bin.readUint(data, offset);
        offset += 4;
        var loff = bin.readUint(data, offset);
        offset += 4;
        var lnum = bin.readUshort(data, offset);
        offset += 2;
        //console.log(num,boff,loff,lnum);
        var base = {};
        var coff = ooff + boff;
        for(var i = 0; i < num; i++){
            base["g" + bin.readUshort(data, coff)] = [
                bin.readUshort(data, coff + 2),
                bin.readUshort(data, coff + 4)
            ];
            coff += 6;
        }
        var lays = [];
        coff = ooff + loff;
        for(var i = 0; i < lnum; i++){
            lays.push(bin.readUshort(data, coff), bin.readUshort(data, coff + 2));
            coff += 4;
        }
        return [
            base,
            lays
        ];
    }
};
Typr["T"].cpal = {
    parseTab: function(data, offset, length) {
        var bin = Typr["B"];
        var ooff = offset;
        var vsn = bin.readUshort(data, offset);
        offset += 2;
        if (vsn == 0) {
            bin.readUshort(data, offset);
            offset += 2;
            bin.readUshort(data, offset);
            offset += 2;
            var tot = bin.readUshort(data, offset);
            offset += 2;
            var fst = bin.readUint(data, offset);
            offset += 4;
            return new Uint8Array(data.buffer, ooff + fst, tot * 4);
        /*
      var coff=ooff+fst;

      for(var i=0; i<tot; i++) {
        console.log(data[coff],data[coff+1],data[coff+2],data[coff+3]);
        coff+=4;
      }

      console.log(ets,pts,tot); */ } else throw vsn; //console.log("unknown color palette",vsn);
    }
};
Typr["T"].GSUB = {
    parseTab: function(data, offset, length, obj) {
        //console.log(obj.name.ID);
        var bin = Typr["B"], rU = bin.readUshort;
        bin.readUint;
        var off = offset;
        rU(data, off);
        off += 2;
        rU(data, off);
        off += 2;
        rU(data, off);
        off += 2;
        var flO = rU(data, off);
        off += 2;
        rU(data, off);
        off += 2;
        //console.log(maj,min,slO,flO,llO);
        off = offset + flO;
        var fmap = {};
        var cnt = rU(data, off);
        off += 2;
        for(var i = 0; i < cnt; i++){
            var tag = bin.readASCII(data, off, 4);
            off += 4;
            rU(data, off);
            off += 2;
            fmap[tag] = true;
        }
        //console.log(fmap);
        return fmap;
    }
};
Typr["T"].fvar = {
    parseTab: function(data, offset, length, obj) {
        var name = obj["name"];
        var off = offset;
        var bin = Typr["B"];
        var axes = [], inst = [];
        off += 8;
        var acnt = bin.readUshort(data, off);
        off += 2;
        off += 2;
        var icnt = bin.readUshort(data, off);
        off += 2;
        var isiz = bin.readUshort(data, off);
        off += 2;
        for(var i = 0; i < acnt; i++){
            var tag = bin.readASCII(data, off, 4);
            var min = bin.readFixed(data, off + 4);
            var def = bin.readFixed(data, off + 8);
            var max = bin.readFixed(data, off + 12);
            var flg = bin.readUshort(data, off + 16);
            var nid = bin.readUshort(data, off + 18);
            axes.push([
                tag,
                min,
                def,
                max,
                flg,
                name["_" + nid]
            ]);
            //console.log(tag,min,def,max,flg,nid);
            off += 20;
        }
        for(var i = 0; i < icnt; i++){
            var snid = bin.readUshort(data, off), pnid = null;
            var flg = bin.readUshort(data, off + 2);
            var crd = [];
            for(var j = 0; j < acnt; j++)crd.push(bin.readFixed(data, off + 4 + j * 4));
            off += 4 + acnt * 4;
            if ((isiz & 3) == 2) {
                pnid = bin.readUshort(data, off);
                off += 2;
            }
            inst.push([
                name["_" + snid],
                flg,
                crd,
                pnid
            ]);
        //console.log(snid,flg, crd);
        }
        return [
            axes,
            inst
        ];
    }
};
Typr["T"].gvar = function() {
    var EMBEDDED_PEAK_TUPLE = 0x8000;
    var INTERMEDIATE_REGION = 0x4000;
    var PRIVATE_POINT_NUMBERS = 0x2000;
    var DELTAS_ARE_ZERO = 0x80;
    var DELTAS_ARE_WORDS = 0x40;
    var POINTS_ARE_WORDS = 0x80;
    var SHARED_POINT_NUMBERS = 0x8000;
    var bin = Typr["B"];
    function readTuple(data, o, acnt) {
        var tup = [];
        for(var j = 0; j < acnt; j++)tup.push(bin.readF2dot14(data, o + j * 2));
        return tup;
    }
    function readTupleVarHeader(data, off, vcnt, acnt, eoff) {
        var out = [];
        for(var j = 0; j < vcnt; j++){
            var dsiz = bin.readUshort(data, off);
            off += 2;
            var tind = bin.readUshort(data, off), flag = tind & 0xf000;
            tind = tind & 0xfff;
            off += 2;
            //console.log(j, dsiz,tind, flag.toString(16));
            var peak = null, start = null, end = null;
            if (flag & EMBEDDED_PEAK_TUPLE) {
                peak = readTuple(data, off, acnt);
                off += acnt * 2;
            }
            if (flag & INTERMEDIATE_REGION) {
                start = readTuple(data, off, acnt);
                off += acnt * 2;
            }
            if (flag & INTERMEDIATE_REGION) {
                end = readTuple(data, off, acnt);
                off += acnt * 2;
            }
            out.push([
                dsiz,
                tind,
                flag,
                start,
                peak,
                end
            ]);
        }
        return out;
    }
    // Packed "point" numbers
    function readPointNumbers(data, off, gid) {
        var cnt = data[off];
        off++;
        if (cnt == 0) return [
            [],
            off
        ];
        if (127 < cnt) {
            cnt = (cnt & 127) << 8 | data[off++];
        }
        //if(gid==116) console.log("---",cnt);
        var pts = [], last = 0; // point number data runs
        while(pts.length < cnt){
            var v = data[off];
            off++;
            var wds = (v & POINTS_ARE_WORDS) != 0;
            v = (v & 127) + 1;
            //if(gid==116) console.log("-",v);
            for(var i = 0; i < v; i++){
                var dif = 0;
                if (wds) {
                    dif = bin.readUshort(data, off);
                    off += 2;
                } else {
                    dif = data[off];
                    off++;
                }
                //if(gid==116) console.log(dif);
                last += dif;
                pts.push(last);
            }
        }
        //console.log(pts);
        return [
            pts,
            off
        ];
    //throw "e";
    }
    function parseTab(data, offset, length, obj) {
        var off = offset + 4;
        var acnt = bin.readUshort(data, off);
        off += 2;
        var tcnt = bin.readUshort(data, off);
        off += 2;
        var toff = bin.readUint(data, off);
        off += 4;
        var gcnt = bin.readUshort(data, off);
        off += 2;
        bin.readUshort(data, off);
        off += 2;
        var goff = bin.readUint(data, off);
        off += 4;
        // glyphVariationDataOffsets
        var offs = [];
        for(var i = 0; i < gcnt + 1; i++)offs.push(bin.readUint(data, off + i * 4));
        // sharedTuples
        var tups = [], mins = [], maxs = [];
        off = offset + toff;
        for(var i = 0; i < tcnt; i++){
            var peak = readTuple(data, off + i * acnt * 2, acnt), imin = [], imax = [];
            tups.push(peak);
            mins.push(imin);
            maxs.push(imax);
            for(var k = 0; k < acnt; k++){
                imin[k] = Math.min(peak[k], 0);
                imax[k] = Math.max(peak[k], 0);
            }
        }
        //console.log(tups);
        //console.log(acnt,stcnt,stoff,gcnt,flgs,goff);
        var i8 = new Int8Array(data.buffer);
        // GlyphVariationData table array
        var tabs = [];
        for(var i = 0; i < gcnt; i++){
            //console.log("-------",i);
            off = offset + goff + offs[i];
            // tupleVariationCount
            var vcnt = bin.readUshort(data, off);
            off += 2; //if((vcnt>>>12)!=0) throw "e";
            var snum = vcnt & SHARED_POINT_NUMBERS;
            vcnt &= 0xfff;
            //  offset to the serialized data
            var soff = bin.readUshort(data, off);
            off += 2;
            var hdr = readTupleVarHeader(data, off, vcnt, acnt);
            var tab = [];
            tabs.push(tab);
            // Serialized Data
            off = offset + goff + offs[i] + soff;
            var sind = null;
            if (snum) {
                var oo = readPointNumbers(data, off);
                sind = oo[0];
                off = oo[1];
            }
            for(var j = 0; j < vcnt; j++){
                var vr = hdr[j], end = off + vr[0]; //console.log(vr);  console.log(data.slice(off,off+vr[0]));
                var ind = sind;
                if (vr[2] & PRIVATE_POINT_NUMBERS) {
                    var oo = readPointNumbers(data, off);
                    ind = oo[0];
                    off = oo[1];
                }
                // read packed deltas (delta runs)
                var ds = [];
                while(off < end){
                    var cb = data[off++]; // control byte;
                    var cnt = (cb & 0x3f) + 1;
                    if (cb & DELTAS_ARE_ZERO) {
                        for(var k = 0; k < cnt; k++)ds.push(0);
                    } else if (cb & DELTAS_ARE_WORDS) {
                        for(var k = 0; k < cnt; k++)ds.push(bin.readShort(data, off + k * 2));
                        off += cnt * 2;
                    } else {
                        for(var k = 0; k < cnt; k++)ds.push(i8[off + k]);
                        off += cnt;
                    }
                }
                //if(ind) console.log(ind, ds);
                var ti = vr[1];
                tab.push([
                    [
                        vr[3] ? vr[3] : mins[ti],
                        vr[4] ? vr[4] : tups[ti],
                        vr[5] ? vr[5] : maxs[ti]
                    ],
                    ds,
                    ind.length == 0 ? null : ind
                ]);
                if (ind.length != 0 && ind.length * 2 != ds.length) throw "e";
            //if(i==116) console.log(ind, ds);
            }
        }
        return tabs;
    }
    return {
        parseTab: parseTab
    };
}();
Typr["T"].avar = {
    parseTab: function(data, offset, length, obj) {
        var off = offset;
        var bin = Typr["B"], out = [];
        off += 6;
        var acnt = bin.readUshort(data, off);
        off += 2;
        for(var ai = 0; ai < acnt; ai++){
            var cnt = bin.readUshort(data, off);
            off += 2;
            var poly = [];
            out.push(poly);
            for(var i = 0; i < cnt; i++){
                var x = bin.readF2dot14(data, off);
                var y = bin.readF2dot14(data, off + 2);
                off += 4;
                poly.push(x, y);
            }
        }
        return out;
    }
};
Typr["T"].HVAR = {
    parseTab: function(data, offset, length, obj) {
        var off = offset, oo = offset;
        var bin = Typr["B"];
        //console.log(data.slice(off));
        off += 4;
        var varO = bin.readUint(data, off);
        off += 4;
        var advO = bin.readUint(data, off);
        off += 4;
        var lsbO = bin.readUint(data, off);
        off += 4;
        var rsbO = bin.readUint(data, off);
        off += 4;
        if (lsbO != 0 || rsbO != 0) throw lsbO;
        //console.log(varO,advO,lsbO,rsbO);
        off = oo + varO; // item variation store
        // ItemVariationStore
        var ioff = off;
        var fmt = bin.readUshort(data, off);
        off += 2;
        if (fmt != 1) throw "e";
        var vregO = bin.readUint(data, off);
        off += 4;
        // itemVariationDataCount
        var vcnt = bin.readUshort(data, off);
        off += 2;
        var offs = [];
        for(var i = 0; i < vcnt; i++)offs.push(bin.readUint(data, off + i * 4));
        off += vcnt * 4; //if(offs.length!=1) throw "e";
        //console.log(vregO,vcnt,offs);
        off = ioff + vregO;
        var acnt = bin.readUshort(data, off);
        off += 2;
        var rcnt = bin.readUshort(data, off);
        off += 2;
        var regs = [];
        for(var i = 0; i < rcnt; i++){
            var crd = [
                [],
                [],
                []
            ];
            regs.push(crd);
            for(var j = 0; j < acnt; j++){
                crd[0].push(bin.readF2dot14(data, off + 0));
                crd[1].push(bin.readF2dot14(data, off + 2));
                crd[2].push(bin.readF2dot14(data, off + 4));
                off += 6;
            }
        }
        //console.log(acnt, rcnt, regs);
        var i8 = new Int8Array(data.buffer);
        var varStore = [];
        for(var i = 0; i < offs.length; i++){
            // ItemVariationData
            off = oo + varO + offs[i];
            var vdata = [];
            varStore.push(vdata);
            var icnt = bin.readUshort(data, off);
            off += 2; // itemCount
            var dcnt = bin.readUshort(data, off);
            off += 2;
            if (dcnt & 0x8000) throw "e";
            var rcnt = bin.readUshort(data, off);
            off += 2;
            var ixs = [];
            for(var j = 0; j < rcnt; j++)ixs.push(bin.readUshort(data, off + j * 2));
            off += rcnt * 2;
            //console.log(icnt,dcnt,rcnt,ixs);
            //console.log(data.slice(off));
            for(var k = 0; k < icnt; k++){
                var deltaData = []; //vdata.push(deltaData);
                for(var ri = 0; ri < rcnt; ri++){
                    deltaData.push(ri < dcnt ? bin.readShort(data, off) : i8[off]);
                    off += ri < dcnt ? 2 : 1;
                }
                var dd = new Array(regs.length);
                dd.fill(0);
                vdata.push(dd);
                for(var j = 0; j < ixs.length; j++)dd[ixs[j]] = deltaData[j];
            }
        }
        //console.log(varStore);
        // VariationRegionList
        off = oo + advO; // advance widths
        // DeltaSetIndexMap
        var fmt = data[off++];
        if (fmt != 0) throw "e";
        var entryFormat = data[off++];
        var mapCount = bin.readUshort(data, off);
        off += 2;
        var INNER_INDEX_BIT_COUNT_MASK = 0x0f;
        var MAP_ENTRY_SIZE_MASK = 0x30;
        var entrySize = ((entryFormat & MAP_ENTRY_SIZE_MASK) >> 4) + 1; //if(entrySize!=1) throw entrySize;
        //console.log(fmt, entryFormat, mapCount, entrySize);
        var dfs = [];
        for(var i = 0; i < mapCount; i++){
            var entry = 0;
            if (entrySize == 1) entry = data[off++];
            else {
                entry = bin.readUshort(data, off);
                off += 2;
            }
            var outerIndex = entry >> (entryFormat & INNER_INDEX_BIT_COUNT_MASK) + 1;
            var innerIndex = entry & (1 << (entryFormat & INNER_INDEX_BIT_COUNT_MASK) + 1) - 1;
            //map.push(outerIndex,innerIndex);
            dfs.push(varStore[outerIndex][innerIndex]);
        //console.log(outerIndex,innerIndex);
        //console.log(i,varStore[outerIndex][innerIndex]);
        }
        return [
            regs,
            dfs
        ];
    }
};
Typr["U"] = function() {
    var P = {
        MoveTo: function(p, x, y) {
            p.cmds.push("M");
            p.crds.push(x, y);
        },
        LineTo: function(p, x, y) {
            p.cmds.push("L");
            p.crds.push(x, y);
        },
        CurveTo: function(p, a, b, c, d, e, f) {
            p.cmds.push("C");
            p.crds.push(a, b, c, d, e, f);
        },
        qCurveTo: function(p, a, b, c, d) {
            p.cmds.push("Q");
            p.crds.push(a, b, c, d);
        },
        ClosePath: function(p) {
            p.cmds.push("Z");
        }
    };
    function getGlyphPosition(font, gls, i1, ltr) {
        var g1 = gls[i1], g2 = gls[i1 + 1], kern = font["kern"];
        if (kern) {
            var ind1 = kern.glyph1.indexOf(g1);
            if (ind1 != -1) {
                var ind2 = kern.rval[ind1].glyph2.indexOf(g2);
                if (ind2 != -1) return [
                    0,
                    0,
                    kern.rval[ind1].vals[ind2],
                    0
                ];
            }
        }
        //console.log("no kern");
        return [
            0,
            0,
            0,
            0
        ];
    }
    function shape(font, str, prm) {
        if (prm == null) prm = {};
        prm["ltr"];
        prm["fts"];
        var axs = prm["axs"];
        if (font["fvar"] && axs == null) axs = font["fvar"][1][font["_index"]][2];
        var HVAR = font["HVAR"]; //console.log(HVAR);
        if (axs && HVAR) {
            axs = _normalizeAxis(font, axs);
        } //console.log(S,axs);
        var gls = [];
        for(var i = 0; i < str.length; i++){
            var cc = str.codePointAt(i);
            if (cc > 0xffff) i++;
            gls.push(codeToGlyph(font, cc));
        }
        var shape = [];
        for(var i = 0; i < gls.length; i++){
            var padj = getGlyphPosition(font, gls, i);
            var gid = gls[i]; //console.log(gid);
            var ax = font["hmtx"].aWidth[gid] + padj[2];
            if (HVAR && HVAR[1][gid]) {
                var difs = HVAR[1][gid]; //console.log(difs);
                for(var j = 0; j < HVAR[0].length; j++){
                    ax += _interpolate(HVAR[0][j], axs) * difs[j];
                }
            }
            shape.push({
                "g": gid,
                "cl": i,
                "dx": 0,
                "dy": 0,
                "ax": ax,
                "ay": 0
            });
        }
        return shape;
    }
    function shapeToPath(font, shape, prm) {
        var tpath = {
            cmds: [],
            crds: []
        };
        var x = 0, y = 0, clr, axs;
        if (prm) {
            clr = prm["clr"];
            axs = prm["axs"];
        }
        for(var i = 0; i < shape.length; i++){
            var it = shape[i];
            var path = glyphToPath(font, it["g"], false, axs), crds = path["crds"];
            for(var j = 0; j < crds.length; j += 2){
                tpath.crds.push(crds[j] + x + it["dx"]);
                tpath.crds.push(crds[j + 1] + y + it["dy"]);
            }
            if (clr) tpath.cmds.push(clr);
            for(var j = 0; j < path["cmds"].length; j++)tpath.cmds.push(path["cmds"][j]);
            var clen = tpath.cmds.length;
            if (clr) {
                if (clen != 0 && tpath.cmds[clen - 1] != "X") tpath.cmds.push("X"); // SVG fonts might contain "X". Then, nothing would stroke non-SVG glyphs.
            }
            x += it["ax"];
            y += it["ay"];
        }
        return {
            "cmds": tpath.cmds,
            "crds": tpath.crds
        };
    }
    // find the greatest index with a value <=v
    function arrSearch(arr, k, v) {
        var l = 0, r = ~~(arr.length / k);
        while(l + 1 != r){
            var mid = l + (r - l >>> 1);
            if (arr[mid * k] <= v) l = mid;
            else r = mid;
        }
        //var mi = 0;  for(var i=0; i<arr.length; i+=k) if(arr[i]<=v) mi=i;  if(mi!=l*k) throw "e";
        return l * k;
    }
    var wha = [
        0x9,
        0xa,
        0xb,
        0xc,
        0xd,
        0x20,
        0x85,
        0xa0,
        0x1680,
        0x180e,
        0x2028,
        0x2029,
        0x202f,
        0x2060,
        0x3000,
        0xfeff
    ], whm = {};
    for(var i = 0; i < wha.length; i++)whm[wha[i]] = 1;
    for(var i = 0x2000; i <= 0x200d; i++)whm[i] = 1;
    function codeToGlyph(font, code) {
        //console.log(cmap);
        // "p3e10" for NotoEmoji-Regular.ttf
        //console.log(cmap);
        if (font["_ctab"] == null) {
            var cmap = font["cmap"];
            var tind = -1, pps = [
                "p3e10",
                "p0e4",
                "p3e1",
                "p1e0",
                "p0e3",
                "p0e1" /*,"p3e3"*/ ,
                "p3e0" /*Hebrew*/ ,
                "p3e5" /*Korean*/ 
            ];
            for(var i = 0; i < pps.length; i++)if (cmap.ids[pps[i]] != null) {
                tind = cmap.ids[pps[i]];
                break;
            }
            if (tind == -1) throw "no familiar platform and encoding!";
            font["_ctab"] = cmap.tables[tind];
        }
        var tab = font["_ctab"], fmt = tab.format, gid = -1; //console.log(fmt); throw "e";
        if (fmt == 0) {
            if (code >= tab.map.length) gid = 0;
            else gid = tab.map[code];
        } else if (fmt == 4) {
            var ec = tab.endCount;
            gid = 0;
            if (code <= ec[ec.length - 1]) {
                // smallest index with code <= value
                var sind = arrSearch(ec, 1, code);
                if (ec[sind] < code) sind++;
                if (code >= tab.startCount[sind]) {
                    var gli = 0;
                    if (tab.idRangeOffset[sind] != 0) gli = tab.glyphIdArray[code - tab.startCount[sind] + (tab.idRangeOffset[sind] >> 1) - (tab.idRangeOffset.length - sind)];
                    else gli = code + tab.idDelta[sind];
                    gid = gli & 0xFFFF;
                }
            }
        } else if (fmt == 6) {
            var off = code - tab.firstCode, arr = tab.glyphIdArray;
            if (off < 0 || off >= arr.length) gid = 0;
            else gid = arr[off];
        } else if (fmt == 12) {
            var grp = tab.groups;
            gid = 0; //console.log(grp);  throw "e";
            if (code <= grp[grp.length - 2]) {
                var i = arrSearch(grp, 3, code);
                if (grp[i] <= code && code <= grp[i + 1]) {
                    gid = grp[i + 2] + (code - grp[i]);
                }
            }
        } else throw "unknown cmap table format " + tab.format;
        //*
        var SVG = font["SVG "], loca = font["loca"];
        // if the font claims to have a Glyph for a character, but the glyph is empty, and the character is not "white", it is a lie!
        if (gid != 0 && font["CFF "] == null && (SVG == null || SVG.entries[gid] == null) && loca && loca[gid] == loca[gid + 1] // loca not present in CFF or SVG fonts
         && whm[code] == null) gid = 0;
        //*/
        return gid;
    }
    function glyphToPath(font, gid, noColor, axs) {
        var path = {
            cmds: [],
            crds: []
        };
        if (font["fvar"]) {
            if (axs == null) axs = font["fvar"][1][font["_index"]][2];
            axs = _normalizeAxis(font, axs);
        }
        var SVG = font["SVG "], CFF = font["CFF "], COLR = font["COLR"], CBLC = font["CBLC"], CBDT = font["CBDT"], sbix = font["sbix"], upng = window["UPNG"];
        var strike = null;
        if (CBLC && upng) {
            for(var i = 0; i < CBLC.length; i++)if (CBLC[i][0] <= gid && gid <= CBLC[i][1]) strike = CBLC[i];
        }
        if (strike || sbix && sbix[gid]) {
            if (strike && strike[2] != 17) throw "not a PNG";
            if (font["__tmp"] == null) font["__tmp"] = {};
            var cmd = font["__tmp"]["g" + gid];
            if (cmd == null) {
                var bmp, len;
                if (sbix) {
                    bmp = sbix[gid];
                    len = bmp.length;
                } else {
                    var boff = strike[3][gid - strike[0]] + 5; // smallGlyphMetrics
                    len = CBDT[boff + 1] << 16 | CBDT[boff + 2] << 8 | CBDT[boff + 3];
                    boff += 4;
                    bmp = new Uint8Array(CBDT.buffer, CBDT.byteOffset + boff, len);
                }
                var str = "";
                for(var i = 0; i < len; i++)str += String.fromCharCode(bmp[i]);
                cmd = font["__tmp"]["g" + gid] = "data:image/png;base64," + btoa(str);
            }
            path.cmds.push(cmd);
            var upe = font["head"]["unitsPerEm"] * 1.15;
            var gw = Math.round(upe), gh = Math.round(upe), dy = Math.round(-gh * 0.15);
            path.crds.push(0, gh + dy, gw, gh + dy, gw, dy, 0, dy); //*/
        } else if (SVG && SVG.entries[gid]) {
            var p = SVG.entries[gid];
            if (p != null) {
                if (typeof p == "number") {
                    var svg = SVG.svgs[p];
                    if (typeof svg == "string") {
                        var prsr = new DOMParser();
                        var doc = prsr["parseFromString"](svg, "image/svg+xml");
                        svg = SVG.svgs[p] = doc.getElementsByTagName("svg")[0];
                    }
                    p = Typr["U"]["SVG"].toPath(svg, gid);
                    SVG.entries[gid] = p;
                }
                path = p;
            }
        } else if (noColor != true && COLR && COLR[0]["g" + gid] && COLR[0]["g" + gid][1] > 1) {
            function toHex(n) {
                var o = n.toString(16);
                return (o.length == 1 ? "0" : "") + o;
            }
            var CPAL = font["CPAL"], gl = COLR[0]["g" + gid];
            for(var i = 0; i < gl[1]; i++){
                var lid = gl[0] + i;
                var cgl = COLR[1][2 * lid], pid = COLR[1][2 * lid + 1] * 4;
                var pth = glyphToPath(font, cgl, cgl == gid);
                var col = "#" + toHex(CPAL[pid + 2]) + toHex(CPAL[pid + 1]) + toHex(CPAL[pid + 0]);
                path.cmds.push(col);
                path.cmds = path.cmds.concat(pth["cmds"]);
                path.crds = path.crds.concat(pth["crds"]);
                //console.log(gid, cgl,pid,col);
                path.cmds.push("X");
            }
        } else if (CFF) {
            var pdct = CFF["Private"];
            var state = {
                x: 0,
                y: 0,
                stack: [],
                nStems: 0,
                haveWidth: false,
                width: pdct ? pdct["defaultWidthX"] : 0,
                open: false
            };
            if (CFF["ROS"]) {
                var gi = 0;
                while(CFF["FDSelect"][gi + 2] <= gid)gi += 2;
                pdct = CFF["FDArray"][CFF["FDSelect"][gi + 1]]["Private"];
            }
            _drawCFF(CFF["CharStrings"][gid], state, CFF, pdct, path);
        } else if (font["glyf"]) {
            _drawGlyf(gid, font, path, axs);
        }
        return {
            "cmds": path.cmds,
            "crds": path.crds
        };
    }
    function _drawGlyf(gid, font, path, axs) {
        var gl = font["glyf"][gid];
        if (gl == null) gl = font["glyf"][gid] = Typr["T"].glyf._parseGlyf(font, gid);
        if (gl != null) {
            if (gl.noc > -1) _simpleGlyph(gl, font, gid, path, axs);
            else _compoGlyph(gl, font, gid, path, axs);
        }
    }
    function _interpolate(axs, v) {
        v.length;
        var S = 1;
        var s = axs[0]; // start
        var p = axs[1]; // peak
        var e = axs[2]; // end
        for(var i = 0; i < v.length; i++){
            var AS = 1;
            if (s[i] > p[i] || p[i] > e[i]) AS = 1;
            else if (s[i] < 0 && e[i] > 0 && p[i] != 0) AS = 1;
            else if (p[i] == 0) AS = 1;
            else if (v[i] < s[i] || v[i] > e[i]) AS = 0;
            else {
                if (v[i] == p[i]) AS = 1;
                else if (v[i] < p[i]) AS = (v[i] - s[i]) / (p[i] - s[i]);
                else AS = (e[i] - v[i]) / (e[i] - p[i]);
            }
            S = S * AS;
        }
        return S;
    }
    function _normalizeAxis(font, vv) {
        var fvar = font["fvar"], avar = font["avar"];
        var fv = fvar ? fvar[0] : null;
        var nv = [];
        for(var i = 0; i < fv.length; i++){
            var min = fv[i][1], def = fv[i][2], max = fv[i][3], v = Math.max(min, Math.min(max, vv[i]));
            if (v < def) nv[i] = (def - v) / (min - def);
            else if (v > def) nv[i] = (v - def) / (max - def);
            else nv[i] = 0;
            if (avar && nv[i] != -1) {
                var av = avar[i], j = 0;
                for(; j < av.length; j += 2)if (av[j] >= nv[i]) break;
                var f = (nv[i] - av[j - 2]) / (av[j] - av[j - 2]);
                nv[i] = f * av[j + 1] + (1 - f) * av[j - 1];
            }
        }
        return nv;
    }
    function interpolateDeltas(dfs, ind, xs, ys, endPts) {
        var N = xs.length, ndfs = new Array(N * 2 + 8);
        ndfs.fill(0);
        for(var i = 0; i < N; i++){
            var dx = 0, dy = 0, ii = ind.indexOf(i);
            if (ii != -1) {
                dx = dfs[ii];
                dy = dfs[ind.length + ii];
            } else {
                var cmp = 0;
                while(endPts[cmp] < i)cmp++;
                var cmp0 = cmp == 0 ? 0 : endPts[cmp - 1] + 1;
                var cmp1 = endPts[cmp];
                var i0 = -1, i1 = -1;
                for(var j = 0; j < ind.length; j++){
                    var v = ind[j];
                    if (v < cmp0 || v > cmp1 || v >= N) continue;
                    i0 = j;
                    if (i1 == -1) i1 = j;
                }
                for(var j = 0; j < ind.length; j++){
                    var v = ind[j];
                    if (v < cmp0 || v > cmp1 || v >= N) continue;
                    if (v < i) i0 = j;
                    if (i < v) {
                        i1 = j;
                        break;
                    }
                }
                //var i0 = ind.length-1, i1=0;  if(ind[i0]>=N) i0--;
                //for(var j=0; j<ind.length; j++) {  var v=ind[j];  if(v<N) { if(v<i) i0=j;  if(i<v) {  i1=j;  break;  }  }  }
                for(var ax = 0; ax < 2; ax++){
                    var crd = ax == 0 ? xs : ys, ofs = ax * ind.length, dlt = 0;
                    var c0 = crd[ind[i0]], c1 = crd[ind[i1]], cC = crd[i];
                    var d0 = dfs[ofs + i0], d1 = dfs[ofs + i1];
                    if (c0 == c1) {
                        if (d0 == d1) dlt = d0;
                        else dlt = 0;
                    } else {
                        if (cC <= Math.min(c0, c1)) {
                            if (c0 < c1) dlt = d0;
                            else dlt = d1;
                        } else if (Math.max(c0, c1) <= cC) {
                            if (c0 < c1) dlt = d1;
                            else dlt = d0;
                        } else {
                            var prop = (cC - c0) / (c1 - c0); //if(prop<0) throw "e";
                            dlt = prop * d1 + (1 - prop) * d0;
                        }
                    }
                    if (ax == 0) dx = dlt;
                    else dy = dlt;
                }
            }
            ndfs[i] = dx;
            ndfs[N + 4 + i] = dy;
        }
        return ndfs;
    }
    function _simpleGlyph(gl, font, gid, p, axs) {
        var xs = gl.xs, ys = gl.ys;
        //*
        if (font["fvar"] && axs) {
            xs = xs.slice(0);
            ys = ys.slice(0);
            var gvar = font["gvar"];
            var gv = gvar ? gvar[gid] : null;
            for(var vi = 0; vi < gv.length; vi++){
                var axv = gv[vi][0]; //console.log(axs);
                var S = _interpolate(axv, axs);
                if (S < 1e-9) continue;
                var dfs = gv[vi][1], ind = gv[vi][2]; //if(dfs.length!=2*xs.length+8) throw "e";
                //console.log(vi,S,axv,ind,dfs);
                if (ind) {
                    dfs = gv[vi][1] = interpolateDeltas(dfs, ind, xs, ys, gl.endPts);
                    gv[vi][2] = null;
                }
                //if(ind==null)
                if (dfs.length == xs.length * 2 + 8) for(var i = 0; i < xs.length; i++){
                    xs[i] += S * dfs[i];
                    ys[i] += S * dfs[i + xs.length + 4];
                }
            }
        } //*/
        for(var c = 0; c < gl.noc; c++){
            var i0 = c == 0 ? 0 : gl.endPts[c - 1] + 1;
            var il = gl.endPts[c];
            for(var i = i0; i <= il; i++){
                var pr = i == i0 ? il : i - 1;
                var nx = i == il ? i0 : i + 1;
                var onCurve = gl.flags[i] & 1;
                var prOnCurve = gl.flags[pr] & 1;
                var nxOnCurve = gl.flags[nx] & 1;
                var x = xs[i], y = ys[i];
                if (i == i0) {
                    if (onCurve) {
                        if (prOnCurve) P.MoveTo(p, xs[pr], ys[pr]);
                        else {
                            P.MoveTo(p, x, y);
                            continue; /*  will do CurveTo at il  */ 
                        }
                    } else {
                        if (prOnCurve) P.MoveTo(p, xs[pr], ys[pr]);
                        else P.MoveTo(p, Math.floor((xs[pr] + x) * 0.5), Math.floor((ys[pr] + y) * 0.5));
                    }
                }
                if (onCurve) {
                    if (prOnCurve) P.LineTo(p, x, y);
                } else {
                    if (nxOnCurve) P.qCurveTo(p, x, y, xs[nx], ys[nx]);
                    else P.qCurveTo(p, x, y, Math.floor((x + xs[nx]) * 0.5), Math.floor((y + ys[nx]) * 0.5));
                }
            }
            P.ClosePath(p);
        }
    }
    function _compoGlyph(gl, font, gid, p, axs) {
        var dx = [
            0,
            0,
            0,
            0,
            0,
            0
        ], dy = [
            0,
            0,
            0,
            0,
            0,
            0
        ], ccnt = gl.parts.length;
        if (font["fvar"] && axs) {
            var gvar = font["gvar"];
            var gv = gvar ? gvar[gid] : null;
            for(var vi = 0; vi < gv.length; vi++){
                var axv = gv[vi][0]; //console.log(axs);
                var S = _interpolate(axv, axs);
                if (S < 1e-6) continue;
                var dfs = gv[vi][1], ind = gv[vi][2]; //if(dfs.length!=2*ccnt+8) throw "e";
                if (ind == null) for(var i = 0; i < ccnt; i++){
                    dx[i] += S * dfs[i];
                    dy[i] += S * dfs[i + ccnt + 4];
                }
                else for(var j = 0; j < ind.length; j++){
                    var i = ind[j];
                    dx[i] += S * dfs[0];
                    dy[i] += S * dfs[0 + ccnt];
                }
            }
        }
        for(var j = 0; j < ccnt; j++){
            var path = {
                cmds: [],
                crds: []
            };
            var prt = gl.parts[j];
            _drawGlyf(prt.glyphIndex, font, path, axs);
            var m = prt.m, tx = m.tx + dx[j], ty = m.ty + dy[j];
            for(var i = 0; i < path.crds.length; i += 2){
                var x = path.crds[i], y = path.crds[i + 1];
                p.crds.push(x * m.a + y * m.c + tx); // not sure, probably right
                p.crds.push(x * m.b + y * m.d + ty);
            }
            for(var i = 0; i < path.cmds.length; i++)p.cmds.push(path.cmds[i]);
        }
    }
    function pathToSVG(path, prec) {
        var cmds = path["cmds"], crds = path["crds"];
        if (prec == null) prec = 5;
        function num(v) {
            return parseFloat(v.toFixed(prec));
        }
        function merge(o) {
            var no = [], lstF = false, lstC = "";
            for(var i = 0; i < o.length; i++){
                var it = o[i], isF = typeof it == "number";
                if (!isF) {
                    if (it == lstC && it.length == 1 && it != "m") continue;
                    lstC = it;
                } // move should not be merged (it actually means lineTo)
                if (lstF && isF && it >= 0) no.push(" ");
                no.push(it);
                lstF = isF;
            }
            return no.join("");
        }
        var out = [], co = 0, lmap = {
            "M": 2,
            "L": 2,
            "Q": 4,
            "C": 6
        };
        var x = 0, y = 0, //dx=0, dy=0, // relative perfect coords
        //rx=0, ry=0, // relative rounded coords
        ex = 0, ey = 0, mx = 0, my = 0; // perfect coords of the last "Move"
        for(var i = 0; i < cmds.length; i++){
            var cmd = cmds[i], cc = lmap[cmd] ? lmap[cmd] : 0;
            var o0 = [], dx, dy, rx, ry; // o1=[], cx, cy, ax,ay;
            if (cmd == "L") {
                dx = crds[co] - x;
                dy = crds[co + 1] - y;
                rx = num(dx + ex);
                ry = num(dy + ey);
                // if this "lineTo" leads to the starting point, and "Z" follows, do not output anything.
                if (cmds[i + 1] == "Z" && crds[co] == mx && crds[co + 1] == my) {
                    rx = dx;
                    ry = dy;
                } else if (rx == 0 && ry == 0) ;
                else if (rx == 0) o0.push("v", ry);
                else if (ry == 0) o0.push("h", rx);
                else {
                    o0.push("l", rx, ry);
                }
            } else {
                o0.push(cmd.toLowerCase());
                for(var j = 0; j < cc; j += 2){
                    dx = crds[co + j] - x;
                    dy = crds[co + j + 1] - y;
                    rx = num(dx + ex);
                    ry = num(dy + ey);
                    o0.push(rx, ry);
                }
            }
            if (cc != 0) {
                ex += dx - rx;
                ey += dy - ry;
            }
            var ou = o0;
            for(var j = 0; j < ou.length; j++)out.push(ou[j]);
            if (cc != 0) {
                co += cc;
                x = crds[co - 2];
                y = crds[co - 1];
            }
            if (cmd == "M") {
                mx = x;
                my = y;
            }
            if (cmd == "Z") {
                x = mx;
                y = my;
            }
        }
        return merge(out);
    }
    function SVGToPath(d) {
        var pth = {
            cmds: [],
            crds: []
        };
        Typr["U"]["SVG"].svgToPath(d, pth);
        return {
            "cmds": pth.cmds,
            "crds": pth.crds
        };
    }
    function mipmapB(buff, w, h, hlp) {
        var nw = w >> 1, nh = h >> 1;
        var nbuf = new Uint8Array(nw * nh * 4);
        var sb32 = new Uint32Array(buff.buffer), nb32 = new Uint32Array(nbuf.buffer);
        for(var y = 0; y < nh; y++)for(var x = 0; x < nw; x++){
            var ti = y * nw + x, si = (y << 1) * w + (x << 1);
            //nbuf[ti  ] = buff[si  ];  nbuf[ti+1] = buff[si+1];  nbuf[ti+2] = buff[si+2];  nbuf[ti+3] = buff[si+3];
            //*
            var c0 = sb32[si], c1 = sb32[si + 1], c2 = sb32[si + w], c3 = sb32[si + w + 1];
            var a0 = c0 >>> 24, a1 = c1 >>> 24, a2 = c2 >>> 24, a3 = c3 >>> 24, a = a0 + a1 + a2 + a3;
            if (a == 1020) {
                var r = (c0 >>> 0 & 255) + (c1 >>> 0 & 255) + (c2 >>> 0 & 255) + (c3 >>> 0 & 255) + 2 >>> 2;
                var g = (c0 >>> 8 & 255) + (c1 >>> 8 & 255) + (c2 >>> 8 & 255) + (c3 >>> 8 & 255) + 2 >>> 2;
                var b = (c0 >>> 16 & 255) + (c1 >>> 16 & 255) + (c2 >>> 16 & 255) + (c3 >>> 16 & 255) + 2 >>> 2;
                nb32[ti] = 255 << 24 | b << 16 | g << 8 | r;
            } else if (a == 0) nb32[ti] = 0;
            else {
                var r = (c0 >>> 0 & 255) * a0 + (c1 >>> 0 & 255) * a1 + (c2 >>> 0 & 255) * a2 + (c3 >>> 0 & 255) * a3;
                var g = (c0 >>> 8 & 255) * a0 + (c1 >>> 8 & 255) * a1 + (c2 >>> 8 & 255) * a2 + (c3 >>> 8 & 255) * a3;
                var b = (c0 >>> 16 & 255) * a0 + (c1 >>> 16 & 255) * a1 + (c2 >>> 16 & 255) * a2 + (c3 >>> 16 & 255) * a3;
                var ia = 1 / a;
                r = ~~(r * ia + 0.5);
                g = ~~(g * ia + 0.5);
                b = ~~(b * ia + 0.5);
                nb32[ti] = a + 2 >>> 2 << 24 | b << 16 | g << 8 | r;
            }
        }
        return {
            buff: nbuf,
            w: nw,
            h: nh
        };
    }
    var __cnv, __ct;
    function pathToContext(path, ctx) {
        var c = 0, cmds = path["cmds"], crds = path["crds"];
        //ctx.translate(3500,500);  ctx.rotate(0.25);  ctx.scale(1,-1);
        for(var j = 0; j < cmds.length; j++){
            var cmd = cmds[j];
            if (cmd == "M") {
                ctx.moveTo(crds[c], crds[c + 1]);
                c += 2;
            } else if (cmd == "L") {
                ctx.lineTo(crds[c], crds[c + 1]);
                c += 2;
            } else if (cmd == "C") {
                ctx.bezierCurveTo(crds[c], crds[c + 1], crds[c + 2], crds[c + 3], crds[c + 4], crds[c + 5]);
                c += 6;
            } else if (cmd == "Q") {
                ctx.quadraticCurveTo(crds[c], crds[c + 1], crds[c + 2], crds[c + 3]);
                c += 4;
            } else if (cmd[0] == "d") {
                var upng = window["UPNG"];
                var x0 = crds[c], y0 = crds[c + 1], x1 = crds[c + 2], y1 = crds[c + 3], x2 = crds[c + 4], y2 = crds[c + 5], x3 = crds[c + 6], y3 = crds[c + 7];
                c += 8;
                //y0+=400;  y1+=400;  y1+=600;
                if (upng == null) {
                    ctx.moveTo(x0, y0);
                    ctx.lineTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.lineTo(x3, y3);
                    ctx.closePath();
                    continue;
                }
                var dx0 = x1 - x0, dy0 = y1 - y0, dx1 = x3 - x0, dy1 = y3 - y0;
                var sbmp = atob(cmd.slice(22));
                var bmp = new Uint8Array(sbmp.length);
                for(var i = 0; i < sbmp.length; i++)bmp[i] = sbmp.charCodeAt(i);
                var img = upng["decode"](bmp.buffer), w = img["width"], h = img["height"]; //console.log(img);
                var nbmp = new Uint8Array(upng["toRGBA8"](img)[0]);
                var tr = ctx["getTransform"]();
                var scl = Math.sqrt(Math.abs(tr["a"] * tr["d"] - tr["b"] * tr["c"])) * Math.sqrt(dx1 * dx1 + dy1 * dy1) / h;
                while(scl < 0.5){
                    var nd = mipmapB(nbmp, w, h);
                    nbmp = nd.buff;
                    w = nd.w;
                    h = nd.h;
                    scl *= 2;
                }
                if (__cnv == null) {
                    __cnv = document.createElement("canvas");
                    __ct = __cnv.getContext("2d");
                }
                if (__cnv.width != w || __cnv.height != h) {
                    __cnv.width = w;
                    __cnv.height = h;
                }
                __ct.putImageData(new ImageData(new Uint8ClampedArray(nbmp.buffer), w, h), 0, 0);
                ctx.save();
                ctx.transform(dx0, dy0, dx1, dy1, x0, y0);
                ctx.scale(1 / w, 1 / h);
                ctx.drawImage(__cnv, 0, 0); //*/
                ctx.restore();
            } else if (cmd.charAt(0) == "#" || cmd.charAt(0) == "r") {
                ctx.beginPath();
                ctx.fillStyle = cmd;
            } else if (cmd.charAt(0) == "O" && cmd != "OX") {
                ctx.beginPath();
                var pts = cmd.split("-");
                ctx.lineWidth = parseFloat(pts[2]);
                ctx.lineCap = [
                    "butt",
                    "round",
                    "square"
                ][parseFloat(pts[3])];
                ctx.lineJoin = [
                    "miter",
                    "round",
                    "bevel"
                ][parseFloat(pts[4])];
                ctx.miterLimit = parseFloat(pts[5]);
                ctx.lineDashOffset = parseFloat(pts[6]);
                ctx.setLineDash(pts[7].split(",").map(parseFloat));
                ctx.strokeStyle = pts[1];
            } else if (cmd == "Z") {
                ctx.closePath();
            } else if (cmd == "X") {
                ctx.fill();
            } else if (cmd == "OX") {
                ctx.stroke();
            }
        }
    }
    function _drawCFF(cmds, state, font, pdct, p) {
        var stack = state.stack;
        var nStems = state.nStems, haveWidth = state.haveWidth, width = state.width, open = state.open;
        var i = 0;
        var x = state.x, y = state.y, c1x = 0, c1y = 0, c2x = 0, c2y = 0, c3x = 0, c3y = 0, c4x = 0, c4y = 0, jpx = 0, jpy = 0;
        var CFF = Typr["T"].CFF;
        var nominalWidthX = pdct["nominalWidthX"];
        var o = {
            val: 0,
            size: 0
        };
        //console.log(cmds);
        while(i < cmds.length){
            CFF.getCharString(cmds, i, o);
            var v = o.val;
            i += o.size;
            if (v == "o1" || v == "o18") {
                var hasWidthArg;
                // The number of stem operators on the stack is always even.
                // If the value is uneven, that means a width is specified.
                hasWidthArg = stack.length % 2 !== 0;
                if (hasWidthArg && !haveWidth) {
                    width = stack.shift() + nominalWidthX;
                }
                nStems += stack.length >> 1;
                stack.length = 0;
                haveWidth = true;
            } else if (v == "o3" || v == "o23") {
                var hasWidthArg;
                // The number of stem operators on the stack is always even.
                // If the value is uneven, that means a width is specified.
                hasWidthArg = stack.length % 2 !== 0;
                if (hasWidthArg && !haveWidth) {
                    width = stack.shift() + nominalWidthX;
                }
                nStems += stack.length >> 1;
                stack.length = 0;
                haveWidth = true;
            } else if (v == "o4") {
                if (stack.length > 1 && !haveWidth) {
                    width = stack.shift() + nominalWidthX;
                    haveWidth = true;
                }
                if (open) P.ClosePath(p);
                y += stack.pop();
                P.MoveTo(p, x, y);
                open = true;
            } else if (v == "o5") {
                while(stack.length > 0){
                    x += stack.shift();
                    y += stack.shift();
                    P.LineTo(p, x, y);
                }
            } else if (v == "o6" || v == "o7") {
                var count = stack.length;
                var isX = v == "o6";
                for(var j = 0; j < count; j++){
                    var sval = stack.shift();
                    if (isX) x += sval;
                    else y += sval;
                    isX = !isX;
                    P.LineTo(p, x, y);
                }
            } else if (v == "o8" || v == "o24") {
                var count = stack.length;
                var index = 0;
                while(index + 6 <= count){
                    c1x = x + stack.shift();
                    c1y = y + stack.shift();
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    x = c2x + stack.shift();
                    y = c2y + stack.shift();
                    P.CurveTo(p, c1x, c1y, c2x, c2y, x, y);
                    index += 6;
                }
                if (v == "o24") {
                    x += stack.shift();
                    y += stack.shift();
                    P.LineTo(p, x, y);
                }
            } else if (v == "o11") break;
            else if (v == "o1234" || v == "o1235" || v == "o1236" || v == "o1237") {
                if (v == "o1234") {
                    c1x = x + stack.shift(); // dx1
                    c1y = y; // dy1
                    c2x = c1x + stack.shift(); // dx2
                    c2y = c1y + stack.shift(); // dy2
                    jpx = c2x + stack.shift(); // dx3
                    jpy = c2y; // dy3
                    c3x = jpx + stack.shift(); // dx4
                    c3y = c2y; // dy4
                    c4x = c3x + stack.shift(); // dx5
                    c4y = y; // dy5
                    x = c4x + stack.shift(); // dx6
                    P.CurveTo(p, c1x, c1y, c2x, c2y, jpx, jpy);
                    P.CurveTo(p, c3x, c3y, c4x, c4y, x, y);
                }
                if (v == "o1235") {
                    c1x = x + stack.shift(); // dx1
                    c1y = y + stack.shift(); // dy1
                    c2x = c1x + stack.shift(); // dx2
                    c2y = c1y + stack.shift(); // dy2
                    jpx = c2x + stack.shift(); // dx3
                    jpy = c2y + stack.shift(); // dy3
                    c3x = jpx + stack.shift(); // dx4
                    c3y = jpy + stack.shift(); // dy4
                    c4x = c3x + stack.shift(); // dx5
                    c4y = c3y + stack.shift(); // dy5
                    x = c4x + stack.shift(); // dx6
                    y = c4y + stack.shift(); // dy6
                    stack.shift(); // flex depth
                    P.CurveTo(p, c1x, c1y, c2x, c2y, jpx, jpy);
                    P.CurveTo(p, c3x, c3y, c4x, c4y, x, y);
                }
                if (v == "o1236") {
                    c1x = x + stack.shift(); // dx1
                    c1y = y + stack.shift(); // dy1
                    c2x = c1x + stack.shift(); // dx2
                    c2y = c1y + stack.shift(); // dy2
                    jpx = c2x + stack.shift(); // dx3
                    jpy = c2y; // dy3
                    c3x = jpx + stack.shift(); // dx4
                    c3y = c2y; // dy4
                    c4x = c3x + stack.shift(); // dx5
                    c4y = c3y + stack.shift(); // dy5
                    x = c4x + stack.shift(); // dx6
                    P.CurveTo(p, c1x, c1y, c2x, c2y, jpx, jpy);
                    P.CurveTo(p, c3x, c3y, c4x, c4y, x, y);
                }
                if (v == "o1237") {
                    c1x = x + stack.shift(); // dx1
                    c1y = y + stack.shift(); // dy1
                    c2x = c1x + stack.shift(); // dx2
                    c2y = c1y + stack.shift(); // dy2
                    jpx = c2x + stack.shift(); // dx3
                    jpy = c2y + stack.shift(); // dy3
                    c3x = jpx + stack.shift(); // dx4
                    c3y = jpy + stack.shift(); // dy4
                    c4x = c3x + stack.shift(); // dx5
                    c4y = c3y + stack.shift(); // dy5
                    if (Math.abs(c4x - x) > Math.abs(c4y - y)) {
                        x = c4x + stack.shift();
                    } else {
                        y = c4y + stack.shift();
                    }
                    P.CurveTo(p, c1x, c1y, c2x, c2y, jpx, jpy);
                    P.CurveTo(p, c3x, c3y, c4x, c4y, x, y);
                }
            } else if (v == "o14") {
                if (stack.length > 0 && stack.length != 4 && !haveWidth) {
                    width = stack.shift() + font["nominalWidthX"];
                    haveWidth = true;
                }
                if (stack.length == 4) {
                    var adx = stack.shift();
                    var ady = stack.shift();
                    var bchar = stack.shift();
                    var achar = stack.shift();
                    var bind = CFF.glyphBySE(font, bchar);
                    var aind = CFF.glyphBySE(font, achar);
                    //console.log(bchar, bind);
                    //console.log(achar, aind);
                    //state.x=x; state.y=y; state.nStems=nStems; state.haveWidth=haveWidth; state.width=width;  state.open=open;
                    _drawCFF(font["CharStrings"][bind], state, font, pdct, p);
                    state.x = adx;
                    state.y = ady;
                    _drawCFF(font["CharStrings"][aind], state, font, pdct, p);
                //x=state.x; y=state.y; nStems=state.nStems; haveWidth=state.haveWidth; width=state.width;  open=state.open;
                }
                if (open) {
                    P.ClosePath(p);
                    open = false;
                }
            } else if (v == "o19" || v == "o20") {
                var hasWidthArg;
                // The number of stem operators on the stack is always even.
                // If the value is uneven, that means a width is specified.
                hasWidthArg = stack.length % 2 !== 0;
                if (hasWidthArg && !haveWidth) {
                    width = stack.shift() + nominalWidthX;
                }
                nStems += stack.length >> 1;
                stack.length = 0;
                haveWidth = true;
                i += nStems + 7 >> 3;
            } else if (v == "o21") {
                if (stack.length > 2 && !haveWidth) {
                    width = stack.shift() + nominalWidthX;
                    haveWidth = true;
                }
                y += stack.pop();
                x += stack.pop();
                if (open) P.ClosePath(p);
                P.MoveTo(p, x, y);
                open = true;
            } else if (v == "o22") {
                if (stack.length > 1 && !haveWidth) {
                    width = stack.shift() + nominalWidthX;
                    haveWidth = true;
                }
                x += stack.pop();
                if (open) P.ClosePath(p);
                P.MoveTo(p, x, y);
                open = true;
            } else if (v == "o25") {
                while(stack.length > 6){
                    x += stack.shift();
                    y += stack.shift();
                    P.LineTo(p, x, y);
                }
                c1x = x + stack.shift();
                c1y = y + stack.shift();
                c2x = c1x + stack.shift();
                c2y = c1y + stack.shift();
                x = c2x + stack.shift();
                y = c2y + stack.shift();
                P.CurveTo(p, c1x, c1y, c2x, c2y, x, y);
            } else if (v == "o26") {
                if (stack.length % 2) {
                    x += stack.shift();
                }
                while(stack.length > 0){
                    c1x = x;
                    c1y = y + stack.shift();
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    x = c2x;
                    y = c2y + stack.shift();
                    P.CurveTo(p, c1x, c1y, c2x, c2y, x, y);
                }
            } else if (v == "o27") {
                if (stack.length % 2) {
                    y += stack.shift();
                }
                while(stack.length > 0){
                    c1x = x + stack.shift();
                    c1y = y;
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    x = c2x + stack.shift();
                    y = c2y;
                    P.CurveTo(p, c1x, c1y, c2x, c2y, x, y);
                }
            } else if (v == "o10" || v == "o29") {
                var obj = v == "o10" ? pdct : font;
                if (stack.length == 0) {
                    console.log("error: empty stack");
                } else {
                    var ind = stack.pop();
                    var subr = obj["Subrs"][ind + obj["Bias"]];
                    state.x = x;
                    state.y = y;
                    state.nStems = nStems;
                    state.haveWidth = haveWidth;
                    state.width = width;
                    state.open = open;
                    _drawCFF(subr, state, font, pdct, p);
                    x = state.x;
                    y = state.y;
                    nStems = state.nStems;
                    haveWidth = state.haveWidth;
                    width = state.width;
                    open = state.open;
                }
            } else if (v == "o30" || v == "o31") {
                var count, count1 = stack.length;
                var index = 0;
                var alternate = v == "o31";
                count = count1 & -3;
                index += count1 - count;
                while(index < count){
                    if (alternate) {
                        c1x = x + stack.shift();
                        c1y = y;
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        y = c2y + stack.shift();
                        if (count - index == 5) {
                            x = c2x + stack.shift();
                            index++;
                        } else x = c2x;
                        alternate = false;
                    } else {
                        c1x = x;
                        c1y = y + stack.shift();
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        x = c2x + stack.shift();
                        if (count - index == 5) {
                            y = c2y + stack.shift();
                            index++;
                        } else y = c2y;
                        alternate = true;
                    }
                    P.CurveTo(p, c1x, c1y, c2x, c2y, x, y);
                    index += 4;
                }
            } else if ((v + "").charAt(0) == "o") {
                console.log("Unknown operation: " + v, cmds);
                throw v;
            } else stack.push(v);
        }
        //console.log(cmds);
        state.x = x;
        state.y = y;
        state.nStems = nStems;
        state.haveWidth = haveWidth;
        state.width = width;
        state.open = open;
    }
    function initHB(hurl, resp) {
        var codeLength = function(code) {
            var len = 0;
            if ((code & 0xffffffff - (1 << 7) + 1) == 0) {
                len = 1;
            } else if ((code & 0xffffffff - (1 << 11) + 1) == 0) {
                len = 2;
            } else if ((code & 0xffffffff - (1 << 16) + 1) == 0) {
                len = 3;
            } else if ((code & 0xffffffff - (1 << 21) + 1) == 0) {
                len = 4;
            }
            return len;
        };
        fetch(hurl).then(function(x) {
            return x["arrayBuffer"]();
        }).then(function(ab) {
            return WebAssembly["instantiate"](ab);
        }).then(function(res) {
            console.log("HB ready");
            var exp = res["instance"]["exports"], mem = exp["memory"];
            //mem["grow"](30); // each page is 64kb in size
            var heapu8, u32, i32, f32;
            var __lastFnt, blob, blobPtr, face, font;
            Typr["U"]["shapeHB"] = function() {
                var toJson = function(ptr) {
                    var length = exp["hb_buffer_get_length"](ptr);
                    var result = [];
                    var iPtr32 = exp["hb_buffer_get_glyph_infos"](ptr, 0) >>> 2;
                    var pPtr32 = exp["hb_buffer_get_glyph_positions"](ptr, 0) >>> 2;
                    for(var i = 0; i < length; ++i){
                        var a = iPtr32 + i * 5, b = pPtr32 + i * 5;
                        result.push({
                            "g": u32[a + 0],
                            "cl": u32[a + 2],
                            "ax": i32[b + 0],
                            "ay": i32[b + 1],
                            "dx": i32[b + 2],
                            "dy": i32[b + 3]
                        });
                    }
                    //console.log(result);
                    return result;
                };
                var te;
                return function(fnt, str, prm) {
                    var fdata = fnt["_data"], fn = fnt["name"]["postScriptName"];
                    var ltr = prm["ltr"], fts = prm["fts"], axs = prm["axs"];
                    if (fnt["fvar"] && axs == null) axs = fnt["fvar"][1][fnt["_index"]][2];
                    //var olen = mem.buffer.byteLength, nlen = 2*fdata.length+str.length*16 + 4e6;
                    //if(olen<nlen) mem["grow"](((nlen-olen)>>>16)+4);  //console.log("growing",nlen);
                    heapu8 = new Uint8Array(mem.buffer);
                    u32 = new Uint32Array(mem.buffer);
                    i32 = new Int32Array(mem.buffer);
                    f32 = new Float32Array(mem.buffer);
                    if (__lastFnt != fn) {
                        if (blob != null) {
                            exp["hb_blob_destroy"](blob);
                            exp["free"](blobPtr);
                            exp["hb_face_destroy"](face);
                            exp["hb_font_destroy"](font);
                        }
                        blobPtr = exp["malloc"](fdata.byteLength);
                        heapu8.set(fdata, blobPtr);
                        blob = exp["hb_blob_create"](blobPtr, fdata.byteLength, 2, 0, 0);
                        face = exp["hb_face_create"](blob, fnt["_index"]);
                        font = exp["hb_font_create"](face);
                        __lastFnt = fn;
                    }
                    if (window["TextEncoder"] == null) {
                        alert("Your browser is too old. Please, update it.");
                        return;
                    }
                    if (te == null) te = new window["TextEncoder"]("utf8");
                    var buffer = exp["hb_buffer_create"]();
                    var bytes = te["encode"](str);
                    var len = bytes.length, strp = exp["malloc"](len);
                    heapu8.set(bytes, strp);
                    exp["hb_buffer_add_utf8"](buffer, strp, len, 0, len);
                    exp["free"](strp);
                    var bin = Typr["B"];
                    var feat = 0;
                    if (fts) {
                        feat = exp["malloc"](16 * fts.length);
                        for(var i = 0; i < fts.length; i++){
                            var fe = fts[i];
                            var off = feat + i * 16, qo = off >>> 2;
                            bin.writeASCII(heapu8, off, fe[0].split("").reverse().join(""));
                            u32[qo + 1] = fe[1];
                            u32[qo + 2] = fe[2];
                            u32[qo + 3] = fe[3];
                        }
                    //console.log(fts);
                    }
                    var vdat = 0;
                    if (axs && fnt["fvar"]) {
                        var axes = fnt["fvar"][0]; //console.log(axes, axs);
                        vdat = exp["malloc"](8 * axs.length);
                        for(var i = 0; i < axs.length; i++){
                            var off = vdat + i * 8, qo = off >>> 2;
                            bin.writeASCII(heapu8, off, axes[i][0].split("").reverse().join(""));
                            f32[qo + 1] = axs[i];
                        }
                    }
                    //*/
                    if (axs) exp["hb_font_set_variations"](font, vdat, axs.length);
                    exp["hb_buffer_set_direction"](buffer, ltr ? 4 : 5);
                    exp["hb_buffer_guess_segment_properties"](buffer);
                    exp["hb_shape"](font, buffer, feat, fts ? fts.length : 0);
                    var json = toJson(buffer); //buffer["json"]();
                    exp["hb_buffer_destroy"](buffer);
                    if (fts) exp["free"](feat);
                    if (axs) exp["free"](vdat);
                    var arr = json.slice(0);
                    if (!ltr) arr.reverse();
                    var ci = 0, bi = 0; // character index, binary index
                    for(var i = 1; i < arr.length; i++){
                        var gl = arr[i], cl = gl["cl"];
                        while(true){
                            var cpt = str.codePointAt(ci), cln = codeLength(cpt);
                            if (bi + cln <= cl) {
                                bi += cln;
                                ci += cpt <= 0xffff ? 1 : 2;
                            } else break;
                        }
                        //while(bi+codeLength(str.charCodeAt(ci)) <=cl) {  bi+=codeLength(str.charCodeAt(ci));  ci++;  }
                        gl["cl"] = ci;
                    }
                    return json;
                };
            }();
            resp();
        });
    }
    return {
        "shape": shape,
        "shapeToPath": shapeToPath,
        "codeToGlyph": codeToGlyph,
        "glyphToPath": glyphToPath,
        "pathToSVG": pathToSVG,
        "SVGToPath": SVGToPath,
        "pathToContext": pathToContext,
        "initHB": initHB
    };
}();
;
}}),
"[project]/node_modules/p5/dist/type/p5.Font.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "Font": (()=>Font),
    "arrayCommandsToObjects": (()=>arrayCommandsToObjects),
    "default": (()=>font)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$textCore$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/type/textCore.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$C$2d$g_eAdC$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/constants-C-g_eAdC.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$japont$2f$unicode$2d$range$2f$lib$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@japont/unicode-range/lib/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$unicodeRanges$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/type/unicodeRanges.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$lib$2f$Typr$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/type/lib/Typr.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$davepagurek$2f$bezier$2d$path$2f$build$2f$bezier$2d$path$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@davepagurek/bezier-path/build/bezier-path.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/p5.Renderer-CwAYZOC2.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$creating_reading$2d$D4AAKRbx$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/creating_reading-D4AAKRbx.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$color$2f$color_spaces$2f$hsb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/color/color_spaces/hsb.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$filters$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/filters.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Vector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$custom_shapes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/custom_shapes.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$States$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/States.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$utilities$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/utilities.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$file$2d$saver$2f$FileSaver$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/file-saver/FileSaver.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pako$2f$dist$2f$pako$2e$esm$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pako/dist/pako.esm.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
/**
 * @module Typography
 */ const pathArgCounts = {
    M: 2,
    L: 2,
    C: 6,
    Q: 4
};
const validFontTypes = [
    'ttf',
    'otf',
    'woff'
]; //, 'woff2'];
const validFontTypesRe = new RegExp(`\\.(${validFontTypes.join('|')})`, 'i');
const extractFontNameRe = new RegExp(`([^/]+)(\\.(?:${validFontTypes.join('|')}))`, 'i');
const invalidFontError = 'Sorry, only TTF, OTF and WOFF files are supported.'; // and WOFF2
const fontFaceVariations = [
    'weight',
    'stretch',
    'style'
];
let nextId = 0;
class Font {
    constructor(p, fontFace, name, path, data){
        if (!(fontFace instanceof FontFace)) {
            throw Error('FontFace is required');
        }
        this._pInst = p;
        this.name = name;
        this.path = path;
        this.data = data;
        this.face = fontFace;
        this.id = nextId++;
    }
    /**
   * Checks whether a font has glyph point data and
   * can thus be used for textToPoints(), WEBGL mode, etc.
   * @private
   */ static hasGlyphData(textFont) {
        let { font } = textFont;
        return typeof font === 'object' && typeof font.data !== 'undefined';
    }
    fontBounds(str, x, y, width, height, options) {
        ({ width, height, options } = this._parseArgs(width, height, options));
        let renderer = options?.graphics?._renderer || this._pInst._renderer;
        if (!renderer) throw Error('p5 or graphics required for fontBounds()');
        return renderer.fontBounds(str, x, y, width, height);
    }
    textBounds(str, x, y, width, height, options) {
        ({ width, height, options } = this._parseArgs(width, height, options));
        let renderer = options?.graphics?._renderer || this._pInst._renderer;
        if (!renderer) throw Error('p5 or graphics required for fontBounds()');
        return renderer.textBounds(str, x, y, width, height);
    }
    /**
   * Returns a flat array of path commands that describe the outlines of a string of text.
   *
   * Each command is represented as an array of the form `[type, ...coords]`, where:
   * - `type` is one of `'M'`, `'L'`, `'Q'`, `'C'`, or `'Z'`,
   * - `coords` are the numeric values needed for that command.
   *
   * `'M'` indicates a "move to" (starting a new contour),
   * `'L'` a line segment,
   * `'Q'` a quadratic bezier,
   * `'C'` a cubic bezier, and
   * `'Z'` closes the current path.
   *
   * The first two parameters, `x` and `y`, specify the baseline origin for the text.
   * Optionally, you can provide a `width` and `height` for text wrapping; if you don't need
   * wrapping, you can omit them and directly pass `options` as the fourth parameter.
   *
   * @param  {String} str            The text to convert into path commands.
   * @param  {Number} x              x‐coordinate of the text baseline.
   * @param  {Number} y              y‐coordinate of the text baseline.
   * @param  {Number} [width]        Optional width for text wrapping.
   * @param  {Number} [height]       Optional height for text wrapping.
   * @param  {Object} [options]      Configuration object for rendering text.
   * @return {Array<Array>}          A flat array of path commands.
   *
   * @example
   * <div>
   * <code>
   * let font;
   *
   * async function setup() {
   *   font = await loadFont('assets/inconsolata.otf');
   *   createCanvas(200, 200);
   *   background(220);
   *   noLoop();
   * }
   *
   * function draw() {
   *   background(220);
   *   stroke(0);
   *   noFill();
   *   textSize(60);
   *
   *   // Get path commands for "Hello" (drawn at baseline x=50, y=100):
   *   const pathCommands = font.textToPaths('Hello', 30, 110);
   *
   *   beginShape();
   *   for (let i = 0; i < pathCommands.length; i++) {
   *     const cmd = pathCommands[i];
   *     const type = cmd[0];
   *
   *     switch (type) {
   *       case 'M': {
   *         // Move to (start a new contour)
   *         const x = cmd[1];
   *         const y = cmd[2];
   *         endContour(); // In case we were already drawing
   *         beginContour();
   *         vertex(x, y);
   *         break;
   *       }
   *       case 'L': {
   *         // Line to
   *         const x = cmd[1];
   *         const y = cmd[2];
   *         vertex(x, y);
   *         break;
   *       }
   *       case 'Q': {
   *         // Quadratic bezier
   *         const cx = cmd[1];
   *         const cy = cmd[2];
   *         const x = cmd[3];
   *         const y = cmd[4];
   *         bezierOrder(2);
   *         bezierVertex(cx, cy);
   *         bezierVertex(x, y);
   *         break;
   *       }
   *       case 'C': {
   *         // Cubic bezier
   *         const cx1 = cmd[1];
   *         const cy1 = cmd[2];
   *         const cx2 = cmd[3];
   *         const cy2 = cmd[4];
   *         const x = cmd[5];
   *         const y = cmd[6];
   *         bezierOrder(3);
   *         bezierVertex(cx1, cy1);
   *         bezierVertex(cx2, cy2);
   *         bezierVertex(x, y);
   *         break;
   *       }
   *       case 'Z': {
   *         // Close path
   *         endContour(CLOSE);
   *         beginContour();
   *         break;
   *       }
   *     }
   *   }
   *   endContour();
   *   endShape();
   * }
   * </code>
   * </div>
   */ textToPaths(str, x, y, width, height, options) {
        ({ width, height, options } = this._parseArgs(width, height, options));
        if (!this.data) {
            throw Error('No font data available for "' + this.name + '"\nTry downloading a local copy of the font file');
        }
        // lineate and get glyphs/paths for each line
        let lines = this._lineateAndPathify(str, x, y, width, height, options);
        // flatten into a single array containing all the glyphs
        let glyphs = lines.map((o)=>o.glyphs).flat();
        // flatten into a single array with all the path commands
        return glyphs.map((g)=>g.path.commands).flat();
    }
    /**
   * Returns an array of points outlining a string of text written using the
   * font.
   *
   * Each point object in the array has three properties that describe the
   * point's location and orientation, called its path angle. For example,
   * `{ x: 10, y: 20, alpha: 450 }`.
   *
   * The first parameter, `str`, is a string of text. The second and third
   * parameters, `x` and `y`, are the text's position. By default, they set the
   * coordinates of the bounding box's bottom-left corner. See
   * <a href="#/p5/textAlign">textAlign()</a> for more ways to align text.
   *
   * The fourth parameter, `options`, is also optional. `font.textToPoints()`
   * expects an object with the following properties:
   *
   * `sampleFactor` is the ratio of the text's path length to the number of
   * samples. It defaults to 0.1. Higher values produce more points along the
   * path and are more precise.
   *
   * `simplifyThreshold` removes collinear points if it's set to a number other
   * than 0. The value represents the threshold angle to use when determining
   * whether two edges are collinear.
   *
   * @param  {String} str        string of text.
   * @param  {Number} x          x-coordinate of the text.
   * @param  {Number} y          y-coordinate of the text.
   * @param  {Object} [options]  object with sampleFactor and simplifyThreshold
   *                             properties.
   * @return {Array<Object>} array of point objects, each with `x`, `y`, and `alpha` (path angle) properties.
   *
   * @example
   * <div>
   * <code>
   * let font;
   *
   * async function setup() {
   *   createCanvas(100, 100);
   *   font = await loadFont('assets/inconsolata.otf');
   *
   *   background(200);
   *   textSize(35);
   *
   *   // Get the point array.
   *   let points = font.textToPoints('p5*js', 6, 60, { sampleFactor: 0.5 });
   *
   *   // Draw a dot at each point.
   *   for (let p of points) {
   *     point(p.x, p.y);
   *   }
   *
   *   describe('A set of black dots outlining the text "p5*js" on a gray background.');
   * }
   * </code>
   * </div>
   */ textToPoints(str, x, y, width, height, options) {
        // By segmenting per contour, pointAtLength becomes much faster
        const contourPoints = this.textToContours(str, x, y, width, height, options);
        return contourPoints.reduce((acc, next)=>{
            acc.push(...next);
            return acc;
        }, []);
    }
    /**
   * Returns an array of arrays of points outlining a string of text written using the
   * font. Each array represents a contour, so the letter O will have two outer arrays:
   * one for the outer edge of the shape, and one for the inner edge of the hole.
   *
   * Each point object in a contour array has three properties that describe the
   * point's location and orientation, called its path angle. For example,
   * `{ x: 10, y: 20, alpha: 450 }`.
   *
   * The first parameter, `str`, is a string of text. The second and third
   * parameters, `x` and `y`, are the text's position. By default, they set the
   * coordinates of the bounding box's bottom-left corner. See
   * <a href="#/p5/textAlign">textAlign()</a> for more ways to align text.
   *
   * The fourth parameter, `options`, is also optional. `font.textToPoints()`
   * expects an object with the following properties:
   *
   * `sampleFactor` is the ratio of the text's path length to the number of
   * samples. It defaults to 0.1. Higher values produce more points along the
   * path and are more precise.
   *
   * `simplifyThreshold` removes collinear points if it's set to a number other
   * than 0. The value represents the threshold angle to use when determining
   * whether two edges are collinear.
   *
   * @param  {String} str        string of text.
   * @param  {Number} x          x-coordinate of the text.
   * @param  {Number} y          y-coordinate of the text.
   * @param  {Object} [options]  object with sampleFactor and simplifyThreshold
   *                             properties.
   * @return {Array<Array<Object>>} array of point objects, each with `x`, `y`, and `alpha` (path angle) properties.
   *
   * @example
   * <div>
   * <code>
   * let font;
   *
   * async function setup() {
   *   createCanvas(100, 100);
   *   font = await loadFont('/assets/inconsolata.otf');
   * }
   *
   * function draw() {
   *   background(200);
   *   textAlign(CENTER, CENTER);
   *   textSize(30);
   *
   *   // Get the point array.
   *   let contours = font.textToContours('p5*js', width/2, height/2, { sampleFactor: 0.5 });
   *
   *   beginShape();
   *   for (const pts of contours) {
   *     beginContour();
   *     for (const pt of pts) {
   *       vertex(pt.x + 5*sin(pt.y*0.1 + millis()*0.01), pt.y);
   *     }
   *     endContour(CLOSE);
   *   }
   *   endShape();
   *
   *   describe('The text p5*js wobbling over time');
   * }
   * </code>
   * </div>
   */ textToContours(str, x = 0, y = 0, width, height, options) {
        ({ width, height, options } = this._parseArgs(width, height, options));
        const cmds = this.textToPaths(str, x, y, width, height, options);
        const cmdContours = [];
        for (const cmd of cmds){
            if (cmd[0] === 'M') {
                cmdContours.push([]);
            }
            cmdContours[cmdContours.length - 1].push(cmd);
        }
        return cmdContours.map((commands)=>pathToPoints(commands, options, this));
    }
    /**
      *
      * Converts text into a 3D model that can be rendered in WebGL mode.
      *
      * This method transforms flat text into extruded 3D geometry, allowing
      * for dynamic effects like depth, warping, and custom shading.
      *
      * It works by taking the outlines (contours) of each character in the
      * provided text string and constructing a 3D shape from them.
      *
      * Once your 3D text is ready, you can rotate it in 3D space using <a href="#/p5/orbitControl">orbitControl()</a>
      * — just click and drag with your mouse to see it from all angles!
      *
      * Use the extrude slider to give your letters depth: slide it up, and your
      * flat text turns into a solid, multi-dimensional object.
      *
      * You can also choose from various fonts such as "Anton", "Montserrat", or "Source Serif",
      * much like selecting fancy fonts in a word processor,
      *
      * The generated model (a Geometry object) can be manipulated further—rotated, scaled,
      * or styled with shaders—to create engaging, interactive visual art.
      *
      * @param {String} str The text string to convert into a 3D model.
      * @param {Number} x The x-coordinate for the starting position of the text.
      * @param {Number} y The y-coordinate for the starting position of the text.
      * @param {Number} width Maximum width of the text block (wraps text if exceeded).
      * @param {Number} height Maximum height of the text block.
      * @param {Object} [options] Configuration options for the 3D text:
      * @param {Number} [options.extrude=0] The depth to extrude the text. A value of 0 produces
      * flat text; higher values create thicker, 3D models.
      * @param {Number} [options.sampleFactor=1] A factor controlling the level of detail for the text contours.
      *  Higher values result in smoother curves.
      * @return {p5.Geometry} A geometry object representing the 3D model of the text.
      *
      * @example
      * <div modernizr='webgl'>
      * <code>
      * let font;
      * let geom;
      *
      * async function setup() {
      *   createCanvas(200, 200, WEBGL);
      *   font = await loadFont('https://fonts.gstatic.com/s/anton/v25/1Ptgg87LROyAm0K08i4gS7lu.ttf');
      *
      *   geom = font.textToModel("Hello", 50, 0, { sampleFactor: 2 });
      *   geom.clearColors();
      *   geom.normalize();
      * }
      *
      * function draw() {
      *   background(255);
      *   orbitControl();
      *   fill("red");
      *   strokeWeight(4);
      *   scale(min(width, height) / 300);
      *   model(geom);
      *   describe('A red non-extruded "Hello" in Anton on white canvas, rotatable via mouse.');
      * }
      * </code>
      * </div>
      *
      * @example
      * <div modernizr='webgl'>
      * <code>
      * let font;
      * let geom;
      *
      * async function setup() {
      *   createCanvas(200, 200, WEBGL);
      *
      *   // Alternative fonts:
      *   // Anton: 'https://fonts.gstatic.com/s/anton/v25/1Ptgg87LROyAm0K08i4gS7lu.ttf'
      *   // Montserrat: 'https://fonts.gstatic.com/s/montserrat/v29/JTUHjIg1_i6t8kCHKm4532VJOt5-QNFgpCtr6Ew-Y3tcoqK5.ttf'
      *   // Source Serif: 'https://fonts.gstatic.com/s/sourceserif4/v8/vEFy2_tTDB4M7-auWDN0ahZJW3IX2ih5nk3AucvUHf6OAVIJmeUDygwjihdqrhxXD-wGvjU.ttf'
      *
      *   // Using Source Serif for this example:
      *   font = await loadFont('https://fonts.gstatic.com/s/sourceserif4/v8/vEFy2_tTDB4M7-auWDN0ahZJW3IX2ih5nk3AucvUHf6OAVIJmeUDygwjihdqrhxXD-wGvjU.ttf');
      *
      *   geom = font.textToModel("Hello", 50, 0, { sampleFactor: 2, extrude: 5 });
      *   geom.clearColors();
      *   geom.normalize();
      * }
      *
      * function draw() {
      *   background(255);
      *   orbitControl();
      *   fill("red");
      *   strokeWeight(4);
      *   scale(min(width, height) / 300);
      *   model(geom);
      *   describe('3D red extruded "Hello" in Source Serif on white, rotatable via mouse.');
      * }
      * </code>
      * </div>
      *
      * @example
      * <div modernizr='webgl'>
      * <code>
      * let geom;
      * let activeFont;
      * let artShader;
      * let lineShader;
      *
      * // Define parameters as simple variables
      * let words = 'HELLO';
      * let warp = 1;
      * let extrude = 5;
      * let palette = ["#ffe03d", "#fe4830", "#d33033", "#6d358a", "#1c509e", "#00953c"];
      *
      * async function setup() {
      *   createCanvas(200, 200, WEBGL);
      *
      *   // Using Anton as the default font for this example:
      *
      *  // Alternative fonts:
      *  // Anton: 'https://fonts.gstatic.com/s/anton/v25/1Ptgg87LROyAm0K08i4gS7lu.ttf'
      *  // Montserrat: 'https://fonts.gstatic.com/s/montserrat/v29/JTUHjIg1_i6t8kCHKm4532VJOt5-QNFgpCtr6Ew-Y3tcoqK5.ttf'
      *  // Source Serif: 'https://fonts.gstatic.com/s/sourceserif4/v8/vEFy2_tTDB4M7-auWDN0ahZJW3IX2ih5nk3AucvUHf6OAVIJmeUDygwjihdqrhxXD-wGvjU.ttf'
      *   activeFont = await loadFont('https://fonts.gstatic.com/s/anton/v25/1Ptgg87LROyAm0K08i4gS7lu.ttf');
      *
      *   geom = activeFont.textToModel(words, 0, 50, { sampleFactor: 2, extrude });
      *   geom.clearColors();
      *   geom.normalize();
      *
      *   artShader = baseMaterialShader().modify({
      *     uniforms: {
      *       'float time': () => millis(),
      *       'float warp': () => warp,
      *       'float numColors': () => palette.length,
      *       'vec3[6] colors': () => palette.flatMap((c) => [red(c)/255, green(c)/255, blue(c)/255]),
      *     },
      *     vertexDeclarations: 'out vec3 vPos;',
      *     fragmentDeclarations: 'in vec3 vPos;',
      *     'Vertex getObjectInputs': `(Vertex inputs) {
      *       vPos = inputs.position;
      *       inputs.position.x += 5. * warp * sin(inputs.position.y * 0.1 + time * 0.001) / (1. + warp);
      *       inputs.position.y += 5. * warp * sin(inputs.position.x * 0.1 + time * 0.0009) / (1. + warp);
      *       return inputs;
      *     }`,
      *     'vec4 getFinalColor': `(vec4 _c) {
      *       float x = vPos.x * 0.005;
      *       float a = floor(fract(x) * numColors);
      *       float b = a == numColors - 1. ? 0. : a + 1.;
      *       float t = fract(x * numColors);
      *       vec3 c = mix(colors[int(a)], colors[int(b)], t);
      *       return vec4(c, 1.);
      *     }`
      *   });
      *
      *   lineShader = baseStrokeShader().modify({
      *     uniforms: {
      *       'float time': () => millis(),
      *       'float warp': () => warp,
      *     },
      *     'StrokeVertex getObjectInputs': `(StrokeVertex inputs) {
      *       inputs.position.x += 5. * warp * sin(inputs.position.y * 0.1 + time * 0.001) / (1. + warp);
      *       inputs.position.y += 5. * warp * sin(inputs.position.x * 0.1 + time * 0.0009) / (1. + warp);
      *       return inputs;
      *     }`,
      *   });
      * }
      *
      * function draw() {
      *   background(255);
      *   orbitControl();
      *   shader(artShader);
      *   strokeShader(lineShader);
      *   strokeWeight(4);
      *   scale(min(width, height) / 210);
      *   model(geom);
      *   describe('3D wavy with different color sets "Hello" in Anton on white canvas, rotatable via mouse.');
      * }
      * </code>
      * </div>
      */ textToModel(str, x, y, width, height, options) {
        ({ width, height, options } = this._parseArgs(width, height, options));
        const extrude = options?.extrude || 0;
        const contours = this.textToContours(str, x, y, width, height, options);
        const geom = this._pInst.buildGeometry(()=>{
            if (extrude === 0) {
                this._pInst.beginShape();
                this._pInst.normal(0, 0, 1);
                for (const contour of contours){
                    this._pInst.beginContour();
                    for (const { x, y } of contour){
                        this._pInst.vertex(x, y);
                    }
                    this._pInst.endContour(this._pInst.CLOSE);
                }
                this._pInst.endShape();
            } else {
                // Draw front faces
                for (const side of [
                    1,
                    -1
                ]){
                    this._pInst.beginShape();
                    for (const contour of contours){
                        this._pInst.beginContour();
                        for (const { x, y } of contour){
                            this._pInst.vertex(x, y, side * extrude * 0.5);
                        }
                        this._pInst.endContour(this._pInst.CLOSE);
                    }
                    this._pInst.endShape();
                    this._pInst.beginShape();
                }
                // Draw sides
                for (const contour of contours){
                    this._pInst.beginShape(this._pInst.QUAD_STRIP);
                    for (const v of contour){
                        for (const side of [
                            -1,
                            1
                        ]){
                            this._pInst.vertex(v.x, v.y, side * extrude * 0.5);
                        }
                    }
                    this._pInst.endShape();
                }
            }
        });
        if (extrude !== 0) {
            geom.computeNormals();
            for (const face of geom.faces){
                if (face.every((idx)=>geom.vertices[idx].z <= -extrude * 0.5 + 0.1)) {
                    for (const idx of face)geom.vertexNormals[idx].set(0, 0, -1);
                    face.reverse();
                }
            }
        }
        return geom;
    }
    variations() {
        let vars = {};
        if (this.data) {
            let axes = this.face?.axes;
            if (axes) {
                axes.forEach((ax)=>{
                    vars[ax.tag] = ax.value;
                });
            }
        }
        fontFaceVariations.forEach((v)=>{
            let val = this.face[v];
            if (val !== 'normal') {
                vars[v] = vars[v] || val;
            }
        });
        return vars;
    }
    metadata() {
        let meta = this.data?.name || {};
        for(let p in this.face){
            if (!/^load/.test(p)) {
                meta[p] = meta[p] || this.face[p];
            }
        }
        return meta;
    }
    static async list(log = false) {
        if (log) {
            console.log('There are', document.fonts.size, 'font-faces\n');
            let loaded = 0;
            for (let fontFace of document.fonts.values()){
                console.log('FontFace: {');
                for(let property in fontFace){
                    console.log('  ' + property + ': ' + fontFace[property]);
                }
                console.log('}\n');
                if (fontFace.status === 'loaded') {
                    loaded++;
                }
            }
            console.log(loaded + ' loaded');
        }
        return await Array.from(document.fonts);
    }
    /////////////////////////////// HELPERS ////////////////////////////////
    _verticalAlign(size) {
        const { sCapHeight } = this.data?.['OS/2'] || {};
        const { unitsPerEm = 1000 } = this.data?.head || {};
        const { ascender = 0, descender = 0 } = this.data?.hhea || {};
        const current = ascender / 2;
        const target = (sCapHeight || ascender + descender) / 2;
        const offset = target - current;
        return offset * size / unitsPerEm;
    }
    /*
    Returns an array of line objects, each containing { text, x, y, glyphs: [ {g, path} ] }
  */ _lineateAndPathify(str, x, y, width, height, options = {}) {
        let renderer = options?.graphics?._renderer || this._pInst._renderer;
        // save the baseline
        let setBaseline = renderer.drawingContext.textBaseline;
        // lineate and compute bounds for the text
        let { lines, bounds } = renderer._computeBounds(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$textCore$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["textCoreConstants"]._FONT_BOUNDS, str, x, y, width, height, {
            ignoreRectMode: true,
            ...options
        });
        // compute positions for each of the lines
        lines = this._position(renderer, lines, bounds, width, height);
        // convert lines to paths
        let uPE = this.data?.head?.unitsPerEm || 1000;
        let scale = renderer.states.textSize / uPE;
        const axs = this._currentAxes(renderer);
        let pathsForLine = lines.map((l)=>this._lineToGlyphs(l, {
                scale,
                axs
            }));
        // restore the baseline
        renderer.drawingContext.textBaseline = setBaseline;
        return pathsForLine;
    }
    _currentAxes(renderer) {
        let axs;
        if ((this.data?.fvar?.length ?? 0) > 0) {
            const fontAxes = this.data.fvar[0];
            axs = fontAxes.map(([tag, minVal, defaultVal, maxVal, flags, name])=>{
                if (!renderer) return defaultVal;
                if (tag === 'wght') {
                    return renderer.states.fontWeight;
                } else if (tag === 'wdth') {
                    // TODO: map from keywords (normal, ultra-condensed, etc) to values
                    // return renderer.states.fontStretch
                    return 100;
                } else if (renderer.textCanvas().style.fontVariationSettings) {
                    const match = new RegExp(`\\b${tag}\s+(\d+)`).exec(renderer.textCanvas().style.fontVariationSettings);
                    if (match) {
                        return parseInt(match[1]);
                    } else {
                        return defaultVal;
                    }
                } else {
                    return defaultVal;
                }
            });
        }
        return axs;
    }
    _textToPathPoints(str, x, y, width, height, options) {
        ({ width, height, options } = this._parseArgs(width, height, options));
        // lineate and get the points for each line
        let cmds = this.textToPaths(str, x, y, width, height, options);
        // divide line-segments with intermediate points
        const subdivide = (pts, pt1, pt2, md)=>{
            if (fn.dist(pt1.x, pt1.y, pt2.x, pt2.y) > md) {
                let middle = {
                    x: (pt1.x + pt2.x) / 2,
                    y: (pt1.y + pt2.y) / 2
                };
                pts.push(middle);
                subdivide(pts, pt1, middle, md);
                subdivide(pts, middle, pt2, md);
            }
        };
        // a point for each path-command plus line subdivisions
        let pts = [];
        let { textSize } = this._pInst._renderer.states;
        let maxDist = textSize / this.data.head.unitsPerEm * 500;
        for(let i = 0; i < cmds.length; i++){
            let { type, data: d } = cmds[i];
            if (type !== 'Z') {
                let pt = {
                    x: d[d.length - 2],
                    y: d[d.length - 1]
                };
                if (type === 'L' && pts.length && !options?.nodivide > 0) {
                    subdivide(pts, pts[pts.length - 1], pt, maxDist);
                }
                pts.push(pt);
            }
        }
        return pts;
    }
    _parseArgs(width, height, options = {}) {
        if (typeof width === 'object') {
            options = width;
            width = height = undefined;
        } else if (typeof height === 'object') {
            options = height;
            height = undefined;
        }
        return {
            width,
            height,
            options
        };
    }
    _position(renderer, lines, bounds, width, height) {
        let { textAlign, textLeading } = renderer.states;
        let metrics = this._measureTextDefault(renderer, 'X');
        let ascent = metrics.fontBoundingBoxAscent;
        let coordify = (text, i)=>{
            let x = bounds.x;
            let y = bounds.y + i * textLeading + ascent;
            let lineWidth = renderer._fontWidthSingle(text);
            if (textAlign === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$C$2d$g_eAdC$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["C"]) {
                x += (bounds.w - lineWidth) / 2;
            } else if (textAlign === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$C$2d$g_eAdC$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"]) {
                x += bounds.w - lineWidth;
            }
            if (typeof width !== 'undefined') {
                switch(renderer.states.rectMode){
                    case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$C$2d$g_eAdC$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["C"]:
                        x -= width / 2;
                        y -= height / 2;
                        break;
                    case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$C$2d$g_eAdC$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a"]:
                        x -= width;
                        y -= height;
                        break;
                }
            }
            return {
                text,
                x,
                y
            };
        };
        return lines.map(coordify);
    }
    _lineToGlyphs(line, { scale = 1, axs } = {}) {
        if (!this.data) {
            throw Error('No font data available for "' + this.name + '"\nTry downloading a local copy of the font file');
        }
        let glyphShapes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$lib$2f$Typr$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].U.shape(this.data, line.text, {
            axs
        });
        line.glyphShapes = glyphShapes;
        line.glyphs = this._shapeToPaths(glyphShapes, line, {
            scale,
            axs
        });
        return line;
    }
    _positionGlyphs(text, options) {
        let renderer = options?.graphics?._renderer || this._pInst._renderer;
        const axs = this._currentAxes(renderer);
        const glyphShapes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$lib$2f$Typr$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].U.shape(this.data, text, {
            axs
        });
        const positionedGlyphs = [];
        let x = 0;
        for (const glyph of glyphShapes){
            positionedGlyphs.push({
                x,
                index: glyph.g,
                shape: glyph
            });
            x += glyph.ax;
        }
        return positionedGlyphs;
    }
    _singleShapeToPath(shape, { scale = 1, x = 0, y = 0, lineX = 0, lineY = 0, axs } = {}) {
        let font = this.data;
        let crdIdx = 0;
        let { g, ax, ay, dx, dy } = shape;
        let { crds, cmds } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$lib$2f$Typr$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].U.glyphToPath(font, g, true, axs);
        // can get simple points for each glyph here, but we don't need them ?
        let glyph = {
            path: {
                commands: []
            }
        };
        for(let j = 0; j < cmds.length; j++){
            let type = cmds[j], command = [
                type
            ];
            if (type in pathArgCounts) {
                let argCount = pathArgCounts[type];
                for(let k = 0; k < argCount; k += 2){
                    let gx = crds[k + crdIdx] + x + dx;
                    let gy = crds[k + crdIdx + 1] + y + dy;
                    let fx = lineX + gx * scale;
                    let fy = lineY + gy * -scale;
                    command.push(fx);
                    command.push(fy);
                /*if (k === argCount - 2) {
            glyph.points.push({ x: fx, y: fy });
          }*/ }
                crdIdx += argCount;
            }
            glyph.path.commands.push(command);
        }
        return {
            glyph,
            ax,
            ay
        };
    }
    _shapeToPaths(glyphs, line, { scale = 1, axs } = {}) {
        let x = 0, y = 0, paths = [];
        if (glyphs.length !== line.text.length) {
            throw Error('Invalid shape data');
        }
        // iterate over the glyphs, converting each to a glyph object
        // with a path property containing an array of commands
        for(let i = 0; i < glyphs.length; i++){
            const { glyph, ax, ay } = this._singleShapeToPath(glyphs[i], {
                scale,
                x,
                y,
                lineX: line.x,
                lineY: line.y,
                axs
            });
            paths.push(glyph);
            x += ax;
            y += ay;
        }
        return paths;
    }
    _measureTextDefault(renderer, str) {
        let { textAlign, textBaseline } = renderer.states;
        let ctx = renderer.textDrawingContext();
        ctx.textAlign = 'left';
        ctx.textBaseline = 'alphabetic';
        let metrics = ctx.measureText(str);
        ctx.textAlign = textAlign;
        ctx.textBaseline = textBaseline;
        return metrics;
    }
    drawPaths(ctx, commands, opts) {
        ctx.strokeStyle = opts?.stroke || ctx.strokeStyle;
        ctx.fillStyle = opts?.fill || ctx.fillStyle;
        ctx.beginPath();
        commands.forEach(([type, ...data])=>{
            if (type === 'M') {
                ctx.moveTo(...data);
            } else if (type === 'L') {
                ctx.lineTo(...data);
            } else if (type === 'C') {
                ctx.bezierCurveTo(...data);
            } else if (type === 'Q') {
                ctx.quadraticCurveTo(...data);
            } else if (type === 'Z') {
                ctx.closePath();
            }
        });
        if (opts?.fill) ctx.fill();
        if (opts?.stroke) ctx.stroke();
    }
    _pathsToCommands(paths, scale) {
        let commands = [];
        for(let i = 0; i < paths.length; i++){
            let pathData = paths[i];
            let { x, y, path } = pathData;
            let { crds, cmds } = path;
            // iterate over the path, storing each non-control point
            for(let c = 0, j = 0; j < cmds.length; j++){
                let cmd = cmds[j], obj = {
                    type: cmd,
                    data: []
                };
                if (cmd == "M" || cmd == "L") {
                    obj.data.push(x + crds[c] * scale, y + crds[c + 1] * -scale);
                    c += 2;
                } else if (cmd == "C") {
                    for(let i = 0; i < 6; i += 2){
                        obj.data.push(x + crds[c + i] * scale, y + crds[c + i + 1] * -scale);
                    }
                    c += 6;
                } else if (cmd == "Q") {
                    for(let i = 0; i < 4; i += 2){
                        obj.data.push(x + crds[c + i] * scale, y + crds[c + i + 1] * -scale);
                    }
                    c += 4;
                }
                commands.push(obj);
            }
        }
        return commands;
    }
}
async function create(pInst, name, path, descriptors, rawFont) {
    let face = createFontFace(name, path, descriptors, rawFont);
    // load if we need to
    if (face.status !== 'loaded') await face.load();
    // add it to the document
    document.fonts.add(face);
    // return a new p5.Font
    return new Font(pInst, face, name, path, rawFont);
}
function createFontFace(name, path, descriptors, rawFont) {
    if (name.includes(' ')) name = "'" + name + "'"; // NOTE: must be single-quotes
    let fontArg = rawFont?._compressedData ?? rawFont?._data;
    if (!fontArg) {
        if (!validFontTypesRe.test(path)) {
            throw Error(invalidFontError);
        }
        if (!path.startsWith('url(')) {
            path = 'url(' + path + ')';
        }
        fontArg = path;
    }
    if ((rawFont?.fvar?.length ?? 0) > 0) {
        descriptors = descriptors || {};
        for (const [tag, minVal, defaultVal, maxVal, flags, name] of rawFont.fvar[0]){
            if (tag === 'wght') {
                descriptors.weight = `${minVal} ${maxVal}`;
            } else if (tag === 'wdth') {
                descriptors.stretch = `${minVal}% ${maxVal}%`;
            }
        // TODO add other descriptors
        }
    }
    // create/return the FontFace object
    let face = new FontFace(name, fontArg, descriptors);
    if (face.status === 'error') {
        throw Error('Failed to create FontFace for "' + name + '"');
    }
    return face;
}
function extractFontName(font, path) {
    let result, meta = font?.name;
    // use the metadata if we have it
    if (meta) {
        if (meta.fullName) {
            return meta.fullName;
        }
        if (meta.familyName) {
            result = meta.familyName;
        }
    }
    if (!result) {
        // if not, try to extract the name from the path
        let matches = extractFontNameRe.exec(path);
        if (matches && matches.length >= 3) {
            result = matches[1];
        } else {
            // give up and return the full path
            result = path;
        }
    }
    // replace spaces with underscores
    if (result.includes(' ')) {
        result = result.replace(/ /g, '_');
    }
    return result;
}
function pathToPoints(cmds, options, font) {
    const parseOpts = (options, defaults)=>{
        if (typeof options !== 'object') {
            options = defaults;
        } else {
            for(const key in defaults){
                if (typeof options[key] === 'undefined') {
                    options[key] = defaults[key];
                }
            }
        }
        return options;
    };
    const at = (v, i)=>{
        const s = v.length;
        return v[i < 0 ? i % s + s : i % s];
    };
    const simplify = (pts, angle)=>{
        angle = angle || 0;
        let num = 0;
        for(let i = pts.length - 1; pts.length > 3 && i >= 0; --i){
            if (collinear(at(pts, i - 1), at(pts, i), at(pts, i + 1), angle)) {
                pts.splice(i % pts.length, 1); // Remove middle point
                num++;
            }
        }
        return num;
    };
    const path = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$davepagurek$2f$bezier$2d$path$2f$build$2f$bezier$2d$path$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createFromCommands"])(arrayCommandsToObjects(cmds));
    let opts = parseOpts(options, {
        sampleFactor: 0.1,
        simplifyThreshold: 0
    });
    const totalPoints = Math.max(1, Math.ceil(path.getTotalLength() * opts.sampleFactor));
    let points = [];
    const mode = font._pInst.angleMode();
    const DEGREES = font._pInst.DEGREES;
    for(let i = 0; i < totalPoints; i++){
        const length = path.getTotalLength() * (totalPoints === 1 ? 0 : i / (totalPoints - 1));
        points.push({
            ...path.getPointAtLength(length),
            get angle () {
                const angle = path.getAngleAtLength(length);
                if (mode === DEGREES) {
                    return angle * 180 / Math.PI;
                } else {
                    return angle;
                }
            },
            // For backwards compatibility
            get alpha () {
                return this.angle;
            }
        });
    }
    if (opts.simplifyThreshold) {
        simplify(points, opts.simplifyThreshold);
    }
    return points;
}
function unquote(name) {
    // Unquote name from CSS
    if ((name.startsWith('"') || name.startsWith("'")) && name.at(0) === name.at(-1)) {
        return name.slice(1, -1).replace(/\/(['"])/g, '$1');
    }
    return name;
}
function parseCreateArgs(...args /*path, name, onSuccess, onError*/ ) {
    // parse the path
    let path = args.shift();
    if (typeof path !== 'string' || path.length === 0) {
        p5._friendlyError(invalidFontError, 'p5.loadFont'); // ?
    }
    // parse the name
    let name;
    if (typeof args[0] === 'string') {
        name = args.shift();
    }
    // get the callbacks/descriptors if any
    let success, error, options;
    for(let i = 0; i < args.length; i++){
        const arg = args[i];
        if (typeof arg === 'function') {
            if (!success) {
                success = arg;
            } else {
                error = arg;
            }
        } else if (typeof arg === 'object') {
            options = arg;
        }
    }
    return {
        path,
        name,
        success,
        error,
        options
    };
}
function font(p51, fn1) {
    /**
   * A class to describe fonts. Create through <a href="#/p5/loadFont">`loadFont()`</a>.
   *
   * @class p5.Font
   */ p51.Font = Font;
    /**
   * @private
   */ fn1.parseFontData = async function(pathOrData) {
        // load the raw font bytes
        let result = pathOrData instanceof Uint8Array ? pathOrData : await fn1.loadBytes(pathOrData);
        //console.log('result:', result);
        if (!result) {
            throw Error('Failed to load font data');
        }
        // parse the font data
        let fonts = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$lib$2f$Typr$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].parse(result);
        // TODO: generate descriptors from font in the future
        if (fonts.length === 0 || fonts[0].cmap === undefined) {
            throw Error('parsing font data');
        }
        return fonts[0];
    };
    /**
   * Loads a font and creates a <a href="#/p5.Font">p5.Font</a> object.
   * `loadFont()` can load fonts in either .otf or .ttf format. Loaded fonts can
   * be used to style text on the canvas and in HTML elements.
   *
   * The first parameter, `path`, is the path to a font file.
   * Paths to local files should be relative. For example,
   * `'assets/inconsolata.otf'`. The Inconsolata font used in the following
   * examples can be downloaded for free
   * <a href="https://www.fontsquirrel.com/fonts/inconsolata" target="_blank">here</a>.
   * Paths to remote files should be URLs. For example,
   * `'https://example.com/inconsolata.otf'`. URLs may be blocked due to browser
   * security.
   *
   * In 2D mode, `path` can take on a few other forms. It could be a path to a CSS file,
   * such as one from <a href="https://fonts.google.com/">Google Fonts.</a> It could also
   * be a string with a <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face">CSS `@font-face` declaration.</a>
   *
   * The second parameter, `successCallback`, is optional. If a function is
   * passed, it will be called once the font has loaded. The callback function
   * may use the new <a href="#/p5.Font">p5.Font</a> object if needed.
   *
   * The third parameter, `failureCallback`, is also optional. If a function is
   * passed, it will be called if the font fails to load. The callback function
   * may use the error
   * <a href="https://developer.mozilla.org/en-US/docs/Web/API/Event" target="_blank">Event</a>
   * object if needed.
   *
   * Fonts can take time to load. `await` the result of `loadFont()` in
   * <a href="#/p5/setup">setup()</a> before using the result.
   *
   * @method loadFont
   * @for p5
   * @param  {String}        path       path of the font or CSS file to be loaded, or a CSS `@font-face` string.
   * @param  {String}        [name]            An alias that can be used for this font in `textFont()`. Defaults to the name in the font's metadata.
   * @param  {Object}        [options]         An optional object with extra CSS font face descriptors, or p5.js font settings.
   * @param  {String|Array<String>} [options.sets] (Experimental) An optional string of list of strings with Unicode character set names that should be included. When a CSS file is used as the font, it may contain multiple font files. The font best matching the requested character sets will be picked.
   * @param  {Function}      [successCallback] function called with the
   *                                           <a href="#/p5.Font">p5.Font</a> object after it
   *                                           loads.
   * @param  {Function}      [failureCallback] function called with the error
   *                                           <a href="https://developer.mozilla.org/en-US/docs/Web/API/Event" target="_blank">Event</a>
   *                                           object if the font fails to load.
   * @return {Promise<p5.Font>}                         <a href="#/p5.Font">p5.Font</a> object.
   * @example
   * <div>
   * <code>
   * let font;
   *
   * async function setup() {
   *   createCanvas(100, 100);
   *   font = await loadFont('assets/inconsolata.otf');
   *   fill('deeppink');
   *   textFont(font);
   *   textSize(36);
   *   text('p5*js', 10, 50);
   *
   *   describe('The text "p5*js" written in pink on a white background.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *   loadFont('assets/inconsolata.otf', font => {
   *     fill('deeppink');
   *     textFont(font);
   *     textSize(36);
   *     text('p5*js', 10, 50);
   *
   *     describe('The text "p5*js" written in pink on a white background.');
   *   });
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *   loadFont('assets/inconsolata.otf', success, failure);
   * }
   *
   * function success(font) {
   *   fill('deeppink');
   *   textFont(font);
   *   textSize(36);
   *   text('p5*js', 10, 50);
   *
   *   describe('The text "p5*js" written in pink on a white background.');
   * }
   *
   * function failure(event) {
   *   console.error('Oops!', event);
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * async function setup() {
   *   createCanvas(100, 100);
   *   await loadFont('assets/inconsolata.otf');
   *   let p = createP('p5*js');
   *   p.style('color', 'deeppink');
   *   p.style('font-family', 'Inconsolata');
   *   p.style('font-size', '36px');
   *   p.position(10, 50);
   *
   *   describe('The text "p5*js" written in pink on a white background.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div class="norender">
   * <code>
   * // Some other forms of loading fonts:
   * loadFont("https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,200..800&display=swap");
   * loadFont(`@font-face { font-family: "Bricolage Grotesque", serif; font-optical-sizing: auto; font-weight: 400; font-style: normal; font-variation-settings: "wdth" 100; }`);
   * </code>
   * </div>
   */ /**
    * @method loadFont
    * @for p5
    * @param  {String}        path              path of the font to be loaded.
    * @param  {Function}      [successCallback] function called with the
    *                                           <a href="#/p5.Font">p5.Font</a> object after it
    *                                           loads.
    * @param  {Function}      [failureCallback] function called with the error
    *                                           <a href="https://developer.mozilla.org/en-US/docs/Web/API/Event" target="_blank">Event</a>
    *                                           object if the font fails to load.
    * @returns {Promise<p5.Font>} The font.
    */ fn1.loadFont = async function(...args /*path, name, onSuccess, onError, descriptors*/ ) {
        let { path, name, success, error, options: { sets, ...descriptors } = {} } = parseCreateArgs(...args);
        let isCSS = path.includes('@font-face');
        if (!isCSS) {
            const info = await fetch(path, {
                method: 'HEAD'
            });
            const isCSSFile = info.headers.get('content-type')?.startsWith('text/css');
            if (isCSSFile) {
                isCSS = true;
                path = await fetch(path).then((res)=>res.text());
            }
        }
        if (isCSS) {
            const stylesheet = new CSSStyleSheet();
            await stylesheet.replace(path);
            const possibleFonts = [];
            for (const rule of stylesheet.cssRules){
                if (rule instanceof CSSFontFaceRule) {
                    const style = rule.style;
                    let name = unquote(style.getPropertyValue('font-family'));
                    const src = style.getPropertyValue('src');
                    const fontDescriptors = {
                        ...descriptors || {}
                    };
                    for (const key of style){
                        if (key === 'font-family' || key === 'src') continue;
                        const camelCaseKey = key.replace(/^font-/, '').split('-').map((v, i)=>i === 0 ? v : `${v[0].toUpperCase()}${v.slice(1)}`).join('');
                        fontDescriptors[camelCaseKey] = style.getPropertyValue(key);
                    }
                    possibleFonts.push({
                        name,
                        src,
                        fontDescriptors,
                        loadWithData: async ()=>{
                            let fontData;
                            try {
                                const urlMatch = /url\(([^\)]+)\)/.exec(src);
                                if (urlMatch) {
                                    let url = urlMatch[1];
                                    if (/^['"]/.exec(url) && url.at(0) === url.at(-1)) {
                                        url = url.slice(1, -1);
                                    }
                                    fontData = await fn1.parseFontData(url);
                                }
                            } catch (_e) {}
                            return create(this, name, src, fontDescriptors, fontData);
                        },
                        loadWithoutData: ()=>create(this, name, src, fontDescriptors)
                    });
                }
            }
            // TODO: handle multiple font faces?
            sets = sets || [
                'latin'
            ]; // Default to latin for now if omitted
            const requestedGroups = (sets instanceof Array ? sets : [
                sets
            ]).map((s)=>s.toLowerCase());
            // Grab thr named groups with names that include the requested keywords
            const requestedCategories = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$unicodeRanges$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["unicodeRanges"].filter((r)=>requestedGroups.some((g)=>r.category.includes(g) && // Only include extended character sets if specifically requested
                    r.category.includes('ext') === g.includes('ext')));
            const requestedRanges = new Set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$japont$2f$unicode$2d$range$2f$lib$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UnicodeRange"].parse(requestedCategories.map((c)=>`U+${c.hexrange[0]}-${c.hexrange[1]}`)));
            let closestRangeOverlap = 0;
            let closestDescriptorOverlap = 0;
            let closestMatch = undefined;
            for (const font of possibleFonts){
                if (!font.fontDescriptors.unicodeRange) continue;
                const fontRange = new Set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$japont$2f$unicode$2d$range$2f$lib$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UnicodeRange"].parse(font.fontDescriptors.unicodeRange.split(/,\s*/g)));
                const rangeOverlap = [
                    ...fontRange.values()
                ].filter((v)=>requestedRanges.has(v)).length;
                const targetDescriptors = {
                    // Default to normal style at regular weight
                    style: 'normal',
                    weight: 400,
                    // Override from anything else passed in
                    ...descriptors
                };
                const descriptorOverlap = Object.keys(font.fontDescriptors).filter((k)=>font.fontDescriptors[k] === targetDescriptors[k]).length;
                if (descriptorOverlap > closestDescriptorOverlap || descriptorOverlap === closestDescriptorOverlap && rangeOverlap >= closestRangeOverlap) {
                    closestDescriptorOverlap = descriptorOverlap;
                    closestRangeOverlap = rangeOverlap;
                    closestMatch = font;
                }
            }
            const picked = closestMatch || possibleFonts.at(-1);
            for (const font of possibleFonts){
                if (font !== picked) {
                    // Load without parsing data with Typr so that it still can be accessed
                    // via regular CSS by name
                    font.loadWithoutData();
                }
            }
            return picked?.loadWithData();
        }
        let pfont;
        try {
            const fontData = await fn1.parseFontData(path);
            // make sure we have a valid name
            name = name || extractFontName(fontData, path);
            // create a FontFace object and pass it to the p5.Font constructor
            pfont = await create(this, name, path, descriptors, fontData);
        } catch (err) {
            // failed to parse the font, load it as a simple FontFace
            let ident = name || path.substring(path.lastIndexOf('/') + 1).replace(/\.[^/.]+$/, "");
            console.warn(`WARN: No glyph data for '${ident}', retrying as FontFace`);
            try {
                // create a FontFace object and pass it to p5.Font
                pfont = await create(this, ident, path, descriptors);
            } catch (err) {
                if (error) return error(err);
                throw err;
            }
        }
        if (success) return success(pfont);
        return pfont;
    };
}
// Convert arrays to named objects
const arrayCommandsToObjects = (commands)=>commands.map((command)=>{
        const type = command[0];
        switch(type){
            case 'Z':
                {
                    return {
                        type
                    };
                }
            case 'M':
            case 'L':
                {
                    const [, x, y] = command;
                    return {
                        type,
                        x,
                        y
                    };
                }
            case 'Q':
                {
                    const [, x1, y1, x, y] = command;
                    return {
                        type,
                        x1,
                        y1,
                        x,
                        y
                    };
                }
            case 'C':
                {
                    const [, x1, y1, x2, y2, x, y] = command;
                    return {
                        type,
                        x1,
                        y1,
                        x2,
                        y2,
                        x,
                        y
                    };
                }
            default:
                {
                    throw new Error(`Unexpected path command: ${type}`);
                }
        }
    });
if (typeof p5 !== 'undefined') {
    font(p5, p5.prototype);
}
;
}}),
"[project]/node_modules/p5/dist/type/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>type)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$textCore$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/type/textCore.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$p5$2e$Font$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/type/p5.Font.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/p5.Renderer-CwAYZOC2.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$creating_reading$2d$D4AAKRbx$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/creating_reading-D4AAKRbx.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$color$2f$color_spaces$2f$hsb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/color/color_spaces/hsb.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$C$2d$g_eAdC$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/constants-C-g_eAdC.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$filters$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/filters.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Vector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$custom_shapes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/custom_shapes.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$States$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/States.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$utilities$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/utilities.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$file$2d$saver$2f$FileSaver$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/file-saver/FileSaver.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$japont$2f$unicode$2d$range$2f$lib$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@japont/unicode-range/lib/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$unicodeRanges$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/type/unicodeRanges.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$lib$2f$Typr$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/type/lib/Typr.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pako$2f$dist$2f$pako$2e$esm$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pako/dist/pako.esm.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$davepagurek$2f$bezier$2d$path$2f$build$2f$bezier$2d$path$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@davepagurek/bezier-path/build/bezier-path.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
function type(p5) {
    p5.registerAddon(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$textCore$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]);
    p5.registerAddon(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$p5$2e$Font$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]);
}
;
}}),

};

//# sourceMappingURL=node_modules_p5_dist_type_cebedf9e._.js.map