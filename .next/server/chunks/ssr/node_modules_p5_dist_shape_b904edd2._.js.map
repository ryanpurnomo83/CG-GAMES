{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Users/Ryan%20Purnomo/Bahasa-Pemrograman/Website/Javascript/NextJS/CG-GAMES/node_modules/p5/dist/shape/custom_shapes.js"],"sourcesContent":["import { C as Color } from '../creating_reading-D4AAKRbx.js';\nimport { Vector } from '../math/p5.Vector.js';\nimport { I as INCLUDE, m as PATH, E as EMPTY_PATH, O as OPEN, n as CLOSE, o as POINTS, L as LINES, p as TRIANGLES, Q as QUADS, q as TRIANGLE_FAN, r as TRIANGLE_STRIP, s as QUAD_STRIP, t as EXCLUDE, J as JOIN } from '../constants-C-g_eAdC.js';\nimport 'colorjs.io/fn';\nimport '../color/color_spaces/hsb.js';\n\n/**\n * @module Shape\n * @submodule Custom Shapes\n * @for p5\n * @requires core\n * @requires constants\n */\n\n\n// ---- UTILITY FUNCTIONS ----\nfunction polylineLength(vertices) {\n  let length = 0;\n  for (let i = 1; i < vertices.length; i++) {\n    length += vertices[i-1].position.dist(vertices[i].position);\n  }\n  return length;\n}\n\n// ---- GENERAL BUILDING BLOCKS ----\n\nclass Vertex {\n  constructor(properties) {\n    for (const [key, value] of Object.entries(properties)) {\n      this[key] = value;\n    }\n  }\n  /*\n  get array() {\n    // convert to 1D array\n    // call `toArray()` if value is an object with a toArray() method\n    // handle primitive values separately\n    // maybe handle object literals too, with Object.values()?\n    // probably donâ€™t need anything else for now?\n  }\n  */\n  // TODO: make sure name of array conversion method is\n  // consistent with any modifications to the names of corresponding\n  // properties of p5.Vector and p5.Color\n}\n\nclass ShapePrimitive {\n  vertices;\n  _shape = null;\n  _primitivesIndex = null;\n  _contoursIndex = null;\n  isClosing = false;\n\n  constructor(...vertices) {\n    if (this.constructor === ShapePrimitive) {\n      throw new Error('ShapePrimitive is an abstract class: it cannot be instantiated.');\n    }\n    if (vertices.length > 0) {\n      this.vertices = vertices;\n    }\n    else {\n      throw new Error('At least one vertex must be passed to the constructor.');\n    }\n  }\n\n  get vertexCount() {\n    return this.vertices.length;\n  }\n\n  get vertexCapacity() {\n    throw new Error('Getter vertexCapacity must be implemented.');\n  }\n\n  get _firstInterpolatedVertex() {\n    return this.startVertex();\n  }\n\n  get canOverrideAnchor() {\n    return false;\n  }\n\n  accept(visitor) {\n    throw new Error('Method accept() must be implemented.');\n  }\n\n  addToShape(shape) {\n    /*\n    TODO:\n    Refactor?\n    Test this method once more primitives are implemented.\n    Test segments separately (Segment adds an extra step to this method).\n    */\n    let lastContour = shape.at(-1);\n\n    if (lastContour.primitives.length === 0) {\n      lastContour.primitives.push(this);\n    } else {\n      // last primitive in shape\n      let lastPrimitive = shape.at(-1, -1);\n      let hasSameType = lastPrimitive instanceof this.constructor;\n      let spareCapacity = lastPrimitive.vertexCapacity -\n                          lastPrimitive.vertexCount;\n\n      // this primitive\n      let pushableVertices;\n      let remainingVertices;\n\n      if (hasSameType && spareCapacity > 0) {\n\n        pushableVertices = this.vertices.splice(0, spareCapacity);\n        remainingVertices = this.vertices;\n        lastPrimitive.vertices.push(...pushableVertices);\n\n        if (remainingVertices.length > 0) {\n          lastContour.primitives.push(this);\n        }\n      }\n      else {\n        lastContour.primitives.push(this);\n      }\n    }\n\n    // if primitive itself was added\n    // (i.e. its individual vertices weren't all added to an existing primitive)\n    // give it a reference to the shape and store its location within the shape\n    let addedToShape = this.vertices.length > 0;\n    if (addedToShape) {\n      let lastContour = shape.at(-1);\n      this._primitivesIndex = lastContour.primitives.length - 1;\n      this._contoursIndex = shape.contours.length - 1;\n      this._shape = shape;\n    }\n\n    return shape.at(-1, -1);\n  }\n\n  get _nextPrimitive() {\n    return this._belongsToShape ?\n      this._shape.at(this._contoursIndex, this._primitivesIndex + 1) :\n      null;\n  }\n\n  get _belongsToShape() {\n    return this._shape !== null;\n  }\n\n  handlesClose() {\n    return false;\n  }\n\n  close(vertex) {\n    throw new Error('Unimplemented!');\n  }\n}\n\nclass Contour {\n  #kind;\n  primitives;\n\n  constructor(kind = PATH) {\n    this.#kind = kind;\n    this.primitives = [];\n  }\n\n  get kind() {\n    const isEmpty = this.primitives.length === 0;\n    const isPath = this.#kind === PATH;\n    return isEmpty && isPath ? EMPTY_PATH : this.#kind;\n  }\n\n  accept(visitor) {\n    for (const primitive of this.primitives) {\n      primitive.accept(visitor);\n    }\n  }\n}\n\n// ---- PATH PRIMITIVES ----\n\nclass Anchor extends ShapePrimitive {\n  #vertexCapacity = 1;\n\n  get vertexCapacity() {\n    return this.#vertexCapacity;\n  }\n\n  accept(visitor) {\n    visitor.visitAnchor(this);\n  }\n\n  getEndVertex() {\n    return this.vertices[0];\n  }\n}\n\n// abstract class\nclass Segment extends ShapePrimitive {\n  constructor(...vertices) {\n    super(...vertices);\n    if (this.constructor === Segment) {\n      throw new Error('Segment is an abstract class: it cannot be instantiated.');\n    }\n  }\n\n  // segments in a shape always have a predecessor\n  // (either an anchor or another segment)\n  get _previousPrimitive() {\n    return this._belongsToShape ?\n      this._shape.at(this._contoursIndex, this._primitivesIndex - 1) :\n      null;\n  }\n\n  getStartVertex() {\n    return this._previousPrimitive.getEndVertex();\n  }\n\n  getEndVertex() {\n    return this.vertices.at(-1);\n  }\n}\n\nclass LineSegment extends Segment {\n  #vertexCapacity = 1;\n\n  get vertexCapacity() {\n    return this.#vertexCapacity;\n  }\n\n  accept(visitor) {\n    visitor.visitLineSegment(this);\n  }\n}\n\nclass BezierSegment extends Segment {\n  #order;\n  #vertexCapacity;\n\n  constructor(order, ...vertices) {\n    super(...vertices);\n\n    // Order m may sometimes be passed as an array [m], since arrays\n    // may be used elsewhere to store order of\n    // Bezier curves and surfaces in a common format\n\n    let numericalOrder = Array.isArray(order) ? order[0] : order;\n    this.#order = numericalOrder;\n    this.#vertexCapacity = numericalOrder;\n  }\n\n  get order() {\n    return this.#order;\n  }\n\n  get vertexCapacity() {\n    return this.#vertexCapacity;\n  }\n\n  #_hullLength;\n  hullLength() {\n    if (this.#_hullLength === undefined) {\n      this.#_hullLength = polylineLength([\n        this.getStartVertex(),\n        ...this.vertices\n      ]);\n    }\n    return this.#_hullLength;\n  }\n\n  accept(visitor) {\n    visitor.visitBezierSegment(this);\n  }\n}\n\n/*\nTo-do: Consider type and end modes -- see #6766\nmay want to use separate classes, but maybe not\n\nFor now, the implementation overrides\nsuper.getEndVertex() in order to preserve current p5\nendpoint behavior, but we're considering defaulting\nto interpolated endpoints (a breaking change)\n*/\nclass SplineSegment extends Segment {\n  #vertexCapacity = Infinity;\n  _splineProperties = {\n    ends: INCLUDE,\n    tightness: 0\n  };\n\n  get vertexCapacity() {\n    return this.#vertexCapacity;\n  }\n\n  accept(visitor) {\n    visitor.visitSplineSegment(this);\n  }\n\n  get _comesAfterSegment() {\n    return this._previousPrimitive instanceof Segment;\n  }\n\n  get canOverrideAnchor() {\n    return this._splineProperties.ends === EXCLUDE;\n  }\n\n  // assuming for now that the first interpolated vertex is always\n  // the second vertex passed to splineVertex()\n  // if this spline segment doesn't follow another segment,\n  // the first vertex is in an anchor\n  get _firstInterpolatedVertex() {\n    if (this._splineProperties.ends === EXCLUDE) {\n      return this._comesAfterSegment ?\n        this.vertices[1] :\n        this.vertices[0];\n    } else {\n      return this.getStartVertex()\n    }\n  }\n\n  get _chainedToSegment() {\n    if (this._belongsToShape && this._comesAfterSegment) {\n      let interpolatedStartPosition = this._firstInterpolatedVertex.position;\n      let predecessorEndPosition = this.getStartVertex().position;\n      return predecessorEndPosition.equals(interpolatedStartPosition);\n    }\n    else {\n      return false;\n    }\n  }\n\n  // extend addToShape() with a warning in case second vertex\n  // doesn't line up with end of last segment\n  addToShape(shape) {\n    const added = super.addToShape(shape);\n    this._splineProperties.ends = shape._splineProperties.ends;\n    this._splineProperties.tightness = shape._splineProperties.tightness;\n\n    if (this._splineProperties.ends !== EXCLUDE) return added;\n\n    let verticesPushed = !this._belongsToShape;\n    let lastPrimitive = shape.at(-1, -1);\n\n    let message = (array1, array2) =>\n      `Spline does not start where previous path segment ends:\n      second spline vertex at (${array1})\n      expected to be at (${array2}).`;\n\n    if (verticesPushed &&\n      // Only check once the first interpolated vertex has been added\n      lastPrimitive.vertices.length === 2 &&\n      lastPrimitive._comesAfterSegment &&\n      !lastPrimitive._chainedToSegment\n    ) {\n      let interpolatedStart = lastPrimitive._firstInterpolatedVertex.position;\n      let predecessorEnd = lastPrimitive.getStartVertex().position;\n\n      console.warn(\n        message(interpolatedStart.array(), predecessorEnd.array())\n      );\n    }\n\n    // Note: Could add a warning in an else-if case for when this spline segment\n    // is added directly to the shape instead of pushing its vertices to\n    // an existing spline segment. However, if we assume addToShape() is called by\n    // splineVertex(), it'd add a new spline segment with only one vertex in that case,\n    // and the check wouldn't be needed yet.\n\n    // TODO: Consider case where positions match but other vertex properties don't.\n    return added;\n  }\n\n  // override method on base class\n  getEndVertex() {\n    if (this._splineProperties.ends === INCLUDE) {\n      return super.getEndVertex();\n    } else if (this._splineProperties.ends === EXCLUDE) {\n      return this.vertices.at(-2);\n    } else {\n      return this.getStartVertex();\n    }\n  }\n\n  getControlPoints() {\n    let points = [];\n\n    if (this._comesAfterSegment) {\n      points.push(this.getStartVertex());\n    }\n    points.push(this.getStartVertex());\n\n    for (const vertex of this.vertices) {\n      points.push(vertex);\n    }\n\n    const prevVertex = this.getStartVertex();\n    if (this._splineProperties.ends === INCLUDE) {\n      points.unshift(prevVertex);\n      points.push(this.vertices.at(-1));\n    } else if (this._splineProperties.ends === JOIN) {\n      points.unshift(this.vertices.at(-1));\n      points.push(prevVertex, this.vertices.at(0));\n    }\n\n    return points;\n  }\n\n  handlesClose() {\n    if (!this._belongsToShape) return false;\n\n    // Only handle closing if the spline is the only thing in its contour after\n    // the anchor\n    const contour = this._shape.at(this._contoursIndex);\n    return contour.primitives.length === 2 && this._primitivesIndex === 1;\n  }\n\n  close() {\n    this._splineProperties.ends = JOIN;\n  }\n}\n\n// ---- ISOLATED PRIMITIVES ----\n\nclass Point extends ShapePrimitive {\n  #vertexCapacity = 1;\n\n  get vertexCapacity() {\n    return this.#vertexCapacity;\n  }\n\n  accept(visitor) {\n    visitor.visitPoint(this);\n  }\n}\n\nclass Line extends ShapePrimitive {\n  #vertexCapacity = 2;\n\n  get vertexCapacity() {\n    return this.#vertexCapacity;\n  }\n\n  accept(visitor) {\n    visitor.visitLine(this);\n  }\n}\n\nclass Triangle extends ShapePrimitive {\n  #vertexCapacity = 3;\n\n  get vertexCapacity() {\n    return this.#vertexCapacity;\n  }\n\n  accept(visitor) {\n    visitor.visitTriangle(this);\n  }\n}\n\nclass Quad extends ShapePrimitive {\n  #vertexCapacity = 4;\n\n  get vertexCapacity() {\n    return this.#vertexCapacity;\n  }\n\n  accept(visitor) {\n    visitor.visitQuad(this);\n  }\n}\n\n// ---- TESSELLATION PRIMITIVES ----\n\nclass TriangleFan extends ShapePrimitive {\n  #vertexCapacity = Infinity;\n\n  get vertexCapacity() {\n    return this.#vertexCapacity;\n  }\n\n  accept(visitor) {\n    visitor.visitTriangleFan(this);\n  }\n}\n\nclass TriangleStrip extends ShapePrimitive {\n  #vertexCapacity = Infinity;\n\n  get vertexCapacity() {\n    return this.#vertexCapacity;\n  }\n\n  accept(visitor) {\n    visitor.visitTriangleStrip(this);\n  }\n}\n\nclass QuadStrip extends ShapePrimitive {\n  #vertexCapacity = Infinity;\n\n  get vertexCapacity() {\n    return this.#vertexCapacity;\n  }\n\n  accept(visitor) {\n    visitor.visitQuadStrip(this);\n  }\n}\n\n// ---- PRIMITIVE SHAPE CREATORS ----\n\nclass PrimitiveShapeCreators {\n  // TODO: make creators private?\n  // That'd probably be better, but for now, it may be convenient to use\n  // native Map properties like size, e.g. for testing, and it's simpler to\n  // not have to wrap all the properties that might be useful\n  creators;\n\n  constructor() {\n    let creators = new Map();\n\n    /* TODO: REFACTOR BASED ON THE CODE BELOW,\n       ONCE CONSTANTS ARE IMPLEMENTED AS SYMBOLS\n\n    // Store Symbols as strings for use in Map keys\n    const EMPTY_PATH = constants.EMPTY_PATH.description;\n    const PATH = constants.PATH.description;\n    //etc.\n\n    creators.set(`vertex-${EMPTY_PATH}`, (...vertices) => new Anchor(...vertices));\n    // etc.\n\n    get(vertexKind, shapeKind) {\n      const key = `${vertexKind}-${shapeKind.description}`;\n      return this.creators.get(key);\n    }\n    // etc.\n    */\n\n    // vertex\n    creators.set(`vertex-${EMPTY_PATH}`, (...vertices) => new Anchor(...vertices));\n    creators.set(`vertex-${PATH}`, (...vertices) => new LineSegment(...vertices));\n    creators.set(`vertex-${POINTS}`, (...vertices) => new Point(...vertices));\n    creators.set(`vertex-${LINES}`, (...vertices) => new Line(...vertices));\n    creators.set(`vertex-${TRIANGLES}`, (...vertices) => new Triangle(...vertices));\n    creators.set(`vertex-${QUADS}`, (...vertices) => new Quad(...vertices));\n    creators.set(`vertex-${TRIANGLE_FAN}`, (...vertices) => new TriangleFan(...vertices));\n    creators.set(`vertex-${TRIANGLE_STRIP}`, (...vertices) => new TriangleStrip(...vertices));\n    creators.set(`vertex-${QUAD_STRIP}`, (...vertices) => new QuadStrip(...vertices));\n\n    // bezierVertex (constructors all take order and vertices so they can be called in a uniform way)\n    creators.set(`bezierVertex-${EMPTY_PATH}`, (order, ...vertices) => new Anchor(...vertices));\n    creators.set(`bezierVertex-${PATH}`, (order, ...vertices) => new BezierSegment(order, ...vertices));\n\n    // splineVertex\n    creators.set(`splineVertex-${EMPTY_PATH}`, (...vertices) => new Anchor(...vertices));\n    creators.set(`splineVertex-${PATH}`, (...vertices) => new SplineSegment(...vertices));\n\n    this.creators = creators;\n  }\n\n  get(vertexKind, shapeKind) {\n    const key = `${vertexKind}-${shapeKind}`;\n    return this.creators.get(key);\n  }\n\n  set(vertexKind, shapeKind, creator) {\n    const key = `${vertexKind}-${shapeKind}`;\n    this.creators.set(key, creator);\n  }\n\n  clear() {\n    this.creators.clear();\n  }\n}\n\n// ---- SHAPE ----\n\n/* Note: It's assumed that Shape instances are always built through\n * their beginShape()/endShape() methods. For example, this ensures\n * that a segment is never the first primitive in a contour (paths\n * always start with an anchor), which simplifies code elsewhere.\n */\nclass Shape {\n  #vertexProperties;\n  #initialVertexProperties;\n  #primitiveShapeCreators;\n  #bezierOrder = 3;\n  kind = null;\n  contours = [];\n  _splineProperties = {\n    tightness: 0,\n    ends: INCLUDE\n  };\n  userVertexProperties = null;\n\n  constructor(\n    vertexProperties,\n    primitiveShapeCreators = new PrimitiveShapeCreators()\n  ) {\n    this.#initialVertexProperties = vertexProperties;\n    this.#vertexProperties = vertexProperties;\n    this.#primitiveShapeCreators = primitiveShapeCreators;\n\n    for (const key in this.#vertexProperties) {\n      if (key !== 'position' && key !== 'textureCoordinates') {\n        this[key] = function(value) {\n          this.#vertexProperties[key] = value;\n        };\n      }\n    }\n  }\n\n  serializeToArray(val) {\n    if (val === null || val === undefined) {\n      return [];\n    } if (val instanceof Number) {\n      return [val];\n    } else if (val instanceof Array) {\n      return val;\n    } else if (val.array instanceof Function) {\n      return val.array();\n    } else {\n      throw new Error(`Can't convert ${val} to array!`);\n    }\n  }\n\n  vertexToArray(vertex) {\n    const array = [];\n    for (const key in this.#vertexProperties) {\n      if (this.userVertexProperties && key in this.userVertexProperties)\n        continue;\n      const val = vertex[key];\n      array.push(...this.serializeToArray(val));\n    }\n    for (const key in this.userVertexProperties) {\n      if (key in vertex) {\n        array.push(...this.serializeToArray(vertex[key]));\n      } else {\n        array.push(...new Array(this.userVertexProperties[key]).fill(0));\n      }\n    }\n    return array;\n  }\n\n  hydrateValue(queue, original) {\n    if (original === null) {\n      return null;\n    } else if (original instanceof Number) {\n      return queue.shift();\n    } else if (original instanceof Array) {\n      const array = [];\n      for (let i = 0; i < original.length; i++) {\n        array.push(queue.shift());\n      }\n      return array;\n    } else if (original instanceof Vector) {\n      return new Vector(queue.shift(), queue.shift(), queue.shift());\n    } else if (original instanceof Color) {\n      // NOTE: Not sure what intention here is, `Color` constructor signature\n      // has changed so needed to be reviewed\n      const array = [\n        queue.shift(),\n        queue.shift(),\n        queue.shift(),\n        queue.shift()\n      ];\n      return new Color(array);\n    }\n  }\n\n  arrayToVertex(array) {\n    const vertex = {};\n    const queue = [...array];\n\n    for (const key in this.#vertexProperties) {\n      if (this.userVertexProperties && key in this.userVertexProperties)\n        continue;\n      const original = this.#vertexProperties[key];\n      vertex[key] = this.hydrateValue(queue, original);\n    }\n    for (const key in this.userVertexProperties) {\n      const original = this.#vertexProperties[key];\n      vertex[key] = this.hydrateValue(queue, original);\n    }\n    return vertex;\n  }\n\n  arrayScale(array, scale) {\n    return array.map(v => v * scale);\n  }\n\n  arraySum(first, ...rest) {\n    return first.map((v, i) => {\n      let result = v;\n      for (let j = 0; j < rest.length; j++) {\n        result += rest[j][i];\n      }\n      return result;\n    });\n  }\n\n  arrayMinus(a, b) {\n    return a.map((v, i) => v - b[i]);\n  }\n\n  evaluateCubicBezier([a, b, c, d], t) {\n    return this.arraySum(\n      this.arrayScale(a, Math.pow(1 - t, 3)),\n      this.arrayScale(b, 3 * Math.pow(1 - t, 2) * t),\n      this.arrayScale(c, 3 * (1 - t) * Math.pow(t, 2)),\n      this.arrayScale(d, Math.pow(t, 3))\n    );\n  }\n\n  evaluateQuadraticBezier([a, b, c], t) {\n    return this.arraySum(\n      this.arrayScale(a, Math.pow(1 - t, 2)),\n      this.arrayScale(b, 2 * (1 - t) * t),\n      this.arrayScale(c, t * t)\n    );\n  }\n\n  /*\n  catmullRomToBezier(vertices, tightness)\n\n  Abbreviated description:\n  Converts a Catmull-Rom spline to a sequence of Bezier curveTo points.\n\n  Parameters:\n  vertices -> Array [v0, v1, v2, v3, ...] of at least four vertices\n  tightness -> Number affecting shape of curve\n\n  Returns:\n  array of Bezier curveTo control points, each represented as [c1, c2, c3][]\n\n  TODO:\n  1. It seems p5 contains code for converting from Catmull-Rom to Bezier in at least two places:\n\n  catmullRomToBezier() is based on code in the legacy endShape() function:\n  https://github.com/processing/p5.js/blob/1b66f097761d3c2057c0cec4349247d6125f93ca/src/core/p5.Renderer2D.js#L859C1-L886C1\n\n  A different conversion can be found elsewhere in p5:\n  https://github.com/processing/p5.js/blob/17304ce9e9ef3f967bd828102a51b62a2d39d4f4/src/typography/p5.Font.js#L1179\n\n  A more careful review and comparison of both implementations would be helpful. They're different. I put\n  catmullRomToBezier() together quickly without checking the math/algorithm, when I made the proof of concept\n  for the refactor.\n\n  2. It may be possible to replace the code in p5.Font.js with the code here, to reduce duplication.\n  */\n  catmullRomToBezier(vertices, tightness) {\n    let s = 1 - tightness;\n    let bezArrays = [];\n\n    for (let i = 0; i + 3 < vertices.length; i++) {\n      const [a, b, c, d] = vertices.slice(i, i + 4);\n      const bezB = this.arraySum(\n        b,\n        this.arrayScale(this.arrayMinus(c, a), s / 6)\n      );\n      const bezC = this.arraySum(\n        c,\n        this.arrayScale(this.arrayMinus(b, d), s / 6)\n      );\n      const bezD = c;\n\n      bezArrays.push([bezB, bezC, bezD]);\n    }\n    return bezArrays;\n  }\n\n  // TODO for at() method:\n\n  // RENAME?\n  // -at() indicates it works like Array.prototype.at(), e.g. with negative indices\n  // -get() may work better if we want to add a corresponding set() method\n  // -a set() method could maybe check for problematic usage (e.g. inserting a Triangle into a PATH)\n  // -renaming or removing would necessitate changes at call sites (it's already in use)\n\n  // REFACTOR?\n\n  // TEST\n  at(contoursIndex, primitivesIndex, verticesIndex) {\n    let contour;\n    let primitive;\n\n    contour = this.contours.at(contoursIndex);\n\n    switch(arguments.length) {\n      case 1:\n        return contour;\n      case 2:\n        return contour.primitives.at(primitivesIndex);\n      case 3:\n        primitive = contour.primitives.at(primitivesIndex);\n        return primitive.vertices.at(verticesIndex);\n    }\n  }\n\n  // maybe call this clear() for consistency with PrimitiveShapeCreators.clear()?\n  // note: p5.Geometry has a reset() method, but also clearColors()\n  // looks like reset() isn't in the public reference, so maybe we can switch\n  // everything to clear()? Not sure if reset/clear is used in other classes,\n  // but it'd be good if geometries and shapes are consistent\n  reset() {\n    this.#vertexProperties = { ...this.#initialVertexProperties };\n    this.kind = null;\n    this.contours = [];\n    this.userVertexProperties = null;\n  }\n\n  vertexProperty(name, data) {\n    this.userVertexProperties = this.userVertexProperties || {};\n    const key = this.vertexPropertyKey(name);\n\n    const dataArray = Array.isArray(data) ? data : [data];\n\n    if (!this.userVertexProperties[key]) {\n      this.userVertexProperties[key] = dataArray.length;\n    }\n    this.#vertexProperties[key] = dataArray;\n}\n  vertexPropertyName(key) {\n    return key.replace(/Src$/, '');\n  }\n  vertexPropertyKey(name) {\n    return name + 'Src';\n  }\n\n  bezierOrder(...order) {\n    this.#bezierOrder = order;\n  }\n\n  splineProperty(key, value) {\n    this._splineProperties[key] = value;\n  }\n\n  splineProperties(values) {\n    if (values) {\n      for (const key in values) {\n        this.splineProperty(key, values[key]);\n      }\n    } else {\n      return this._splineProperties;\n    }\n  }\n\n  /*\n  To-do: Maybe refactor #createVertex() since this has side effects that aren't advertised\n  in the method name?\n  */\n  #createVertex(position, textureCoordinates) {\n    this.#vertexProperties.position = position;\n\n    if (textureCoordinates !== undefined) {\n      this.#vertexProperties.textureCoordinates = textureCoordinates;\n    }\n\n    return new Vertex(this.#vertexProperties);\n  }\n\n  #createPrimitiveShape(vertexKind, shapeKind, ...vertices) {\n    let primitiveShapeCreator = this.#primitiveShapeCreators.get(\n      vertexKind, shapeKind\n    );\n\n    return  vertexKind === 'bezierVertex' ?\n      primitiveShapeCreator(this.#bezierOrder, ...vertices) :\n      primitiveShapeCreator(...vertices);\n  }\n\n  /*\n    #generalVertex() is reused by the special vertex functions,\n    including vertex(), bezierVertex(), splineVertex(), and arcVertex():\n\n    It creates a vertex, builds a primitive including that\n    vertex, and has the primitive add itself to the shape.\n  */\n  #generalVertex(kind, position, textureCoordinates) {\n    let vertexKind = kind;\n    let lastContourKind = this.at(-1).kind;\n    let vertex = this.#createVertex(position, textureCoordinates);\n\n    let primitiveShape = this.#createPrimitiveShape(\n      vertexKind,\n      lastContourKind,\n      vertex\n    );\n\n    return primitiveShape.addToShape(this);\n  }\n\n  vertex(position, textureCoordinates, { isClosing = false } = {}) {\n    const added = this.#generalVertex('vertex', position, textureCoordinates);\n    added.isClosing = isClosing;\n  }\n\n  bezierVertex(position, textureCoordinates) {\n    this.#generalVertex('bezierVertex', position, textureCoordinates);\n  }\n\n  splineVertex(position, textureCoordinates) {\n    this.#generalVertex('splineVertex', position, textureCoordinates);\n  }\n\n  arcVertex(position, textureCoordinates) {\n    this.#generalVertex('arcVertex', position, textureCoordinates);\n  }\n\n  beginContour(shapeKind = PATH) {\n    if (this.at(-1)?.kind === EMPTY_PATH) {\n      this.contours.pop();\n    }\n    this.contours.push(new Contour(shapeKind));\n  }\n\n  endContour(closeMode = OPEN, _index = this.contours.length - 1) {\n    const contour = this.at(_index);\n    if (closeMode === CLOSE) {\n      // shape characteristics\n      const isPath = contour.kind === PATH;\n\n      // anchor characteristics\n      const anchorVertex = this.at(_index, 0, 0);\n      const anchorHasPosition = Object.hasOwn(anchorVertex, 'position');\n      const lastSegment = this.at(_index, -1);\n\n      // close path\n      if (isPath && anchorHasPosition) {\n        if (lastSegment.handlesClose()) {\n          lastSegment.close(anchorVertex);\n        } else {\n          // Temporarily remove contours after the current one so that we add to the original\n          // contour again\n          const rest = this.contours.splice(\n            _index + 1,\n            this.contours.length - _index - 1\n          );\n          const prevVertexProperties = this.#vertexProperties;\n          this.#vertexProperties = { ...prevVertexProperties };\n          for (const key in anchorVertex) {\n            if (['position', 'textureCoordinates'].includes(key)) continue;\n            this.#vertexProperties[key] = anchorVertex[key];\n          }\n          this.vertex(\n            anchorVertex.position,\n            anchorVertex.textureCoordinates,\n            { isClosing: true }\n          );\n          this.#vertexProperties = prevVertexProperties;\n          this.contours.push(...rest);\n        }\n      }\n    }\n  }\n\n  beginShape(shapeKind = PATH) {\n    this.kind = shapeKind;\n    // Implicitly start a contour\n    this.beginContour(shapeKind);\n  }\n  /* TO-DO:\n     Refactor?\n     - Might not need anchorHasPosition.\n     - Might combine conditions at top, and rely on shortcircuiting.\n     Does nothing if shape is not a path or has multiple contours. Might discuss this.\n  */\n  endShape(closeMode = OPEN) {\n    if (closeMode === CLOSE) {\n      // Close the first contour, the one implicitly used for shape data\n      // added without an explicit contour\n      this.endContour(closeMode, 0);\n    }\n  }\n\n  accept(visitor) {\n    for (const contour of this.contours) {\n      contour.accept(visitor);\n    }\n  }\n}\n\n// ---- PRIMITIVE VISITORS ----\n\n// abstract class\nclass PrimitiveVisitor {\n  constructor() {\n    if (this.constructor === PrimitiveVisitor) {\n      throw new Error('PrimitiveVisitor is an abstract class: it cannot be instantiated.');\n    }\n  }\n  // path primitives\n  visitAnchor(anchor) {\n    throw new Error('Method visitAnchor() has not been implemented.');\n  }\n  visitLineSegment(lineSegment) {\n    throw new Error('Method visitLineSegment() has not been implemented.');\n  }\n  visitBezierSegment(bezierSegment) {\n    throw new Error('Method visitBezierSegment() has not been implemented.');\n  }\n  visitSplineSegment(curveSegment) {\n    throw new Error('Method visitSplineSegment() has not been implemented.');\n  }\n  visitArcSegment(arcSegment) {\n    throw new Error('Method visitArcSegment() has not been implemented.');\n  }\n\n  // isolated primitives\n  visitPoint(point) {\n    throw new Error('Method visitPoint() has not been implemented.');\n  }\n  visitLine(line) {\n    throw new Error('Method visitLine() has not been implemented.');\n  }\n  visitTriangle(triangle) {\n    throw new Error('Method visitTriangle() has not been implemented.');\n  }\n  visitQuad(quad) {\n    throw new Error('Method visitQuad() has not been implemented.');\n  }\n\n  // tessellation primitives\n  visitTriangleFan(triangleFan) {\n    throw new Error('Method visitTriangleFan() has not been implemented.');\n  }\n  visitTriangleStrip(triangleStrip) {\n    throw new Error('Method visitTriangleStrip() has not been implemented.');\n  }\n  visitQuadStrip(quadStrip) {\n    throw new Error('Method visitQuadStrip() has not been implemented.');\n  }\n}\n\n// requires testing\nclass PrimitiveToPath2DConverter extends PrimitiveVisitor {\n  path = new Path2D();\n  strokeWeight;\n\n  constructor({ strokeWeight }) {\n    super();\n    this.strokeWeight = strokeWeight;\n  }\n\n  // path primitives\n  visitAnchor(anchor) {\n    let vertex = anchor.getEndVertex();\n    this.path.moveTo(vertex.position.x, vertex.position.y);\n  }\n  visitLineSegment(lineSegment) {\n    if (lineSegment.isClosing) {\n      // The same as lineTo, but it adds a stroke join between this\n      // and the starting vertex rather than having two caps\n      this.path.closePath();\n    } else {\n      let vertex = lineSegment.getEndVertex();\n      this.path.lineTo(vertex.position.x, vertex.position.y);\n    }\n  }\n  visitBezierSegment(bezierSegment) {\n    let [v1, v2, v3] = bezierSegment.vertices;\n\n    switch (bezierSegment.order) {\n      case 2:\n        this.path.quadraticCurveTo(\n          v1.position.x,\n          v1.position.y,\n          v2.position.x,\n          v2.position.y\n        );\n        break;\n      case 3:\n        this.path.bezierCurveTo(\n          v1.position.x,\n          v1.position.y,\n          v2.position.x,\n          v2.position.y,\n          v3.position.x,\n          v3.position.y\n        );\n        break;\n    }\n  }\n  visitSplineSegment(splineSegment) {\n    const shape = splineSegment._shape;\n\n    if (\n      splineSegment._splineProperties.ends === EXCLUDE &&\n      !splineSegment._comesAfterSegment\n    ) {\n      let startVertex = splineSegment._firstInterpolatedVertex;\n      this.path.moveTo(startVertex.position.x, startVertex.position.y);\n    }\n\n    const arrayVertices = splineSegment.getControlPoints().map(\n      v => shape.vertexToArray(v)\n    );\n    let bezierArrays = shape.catmullRomToBezier(\n      arrayVertices,\n      splineSegment._splineProperties.tightness\n    ).map(arr => arr.map(vertArr => shape.arrayToVertex(vertArr)));\n    for (const array of bezierArrays) {\n      const points = array.flatMap(vert => [vert.position.x, vert.position.y]);\n      this.path.bezierCurveTo(...points);\n    }\n  }\n  visitPoint(point) {\n    const { x, y } = point.vertices[0].position;\n    this.path.moveTo(x, y);\n    // Hack: to draw just strokes and not fills, draw a very very tiny line\n    this.path.lineTo(x + 0.00001, y);\n  }\n  visitLine(line) {\n    const { x: x0, y: y0 } = line.vertices[0].position;\n    const { x: x1, y: y1 } = line.vertices[1].position;\n    this.path.moveTo(x0, y0);\n    this.path.lineTo(x1, y1);\n  }\n  visitTriangle(triangle) {\n    const [v0, v1, v2] = triangle.vertices;\n    this.path.moveTo(v0.position.x, v0.position.y);\n    this.path.lineTo(v1.position.x, v1.position.y);\n    this.path.lineTo(v2.position.x, v2.position.y);\n    this.path.closePath();\n  }\n  visitQuad(quad) {\n    const [v0, v1, v2, v3] = quad.vertices;\n    this.path.moveTo(v0.position.x, v0.position.y);\n    this.path.lineTo(v1.position.x, v1.position.y);\n    this.path.lineTo(v2.position.x, v2.position.y);\n    this.path.lineTo(v3.position.x, v3.position.y);\n    this.path.closePath();\n  }\n  visitTriangleFan(triangleFan) {\n    const [v0, ...rest] = triangleFan.vertices;\n    for (let i = 0; i < rest.length - 1; i++) {\n      const v1 = rest[i];\n      const v2 = rest[i + 1];\n      this.path.moveTo(v0.position.x, v0.position.y);\n      this.path.lineTo(v1.position.x, v1.position.y);\n      this.path.lineTo(v2.position.x, v2.position.y);\n      this.path.closePath();\n    }\n  }\n  visitTriangleStrip(triangleStrip) {\n    for (let i = 0; i < triangleStrip.vertices.length - 2; i++) {\n      const v0 = triangleStrip.vertices[i];\n      const v1 = triangleStrip.vertices[i + 1];\n      const v2 = triangleStrip.vertices[i + 2];\n      this.path.moveTo(v0.position.x, v0.position.y);\n      this.path.lineTo(v1.position.x, v1.position.y);\n      this.path.lineTo(v2.position.x, v2.position.y);\n      this.path.closePath();\n    }\n  }\n  visitQuadStrip(quadStrip) {\n    for (let i = 0; i < quadStrip.vertices.length - 3; i += 2) {\n      const v0 = quadStrip.vertices[i];\n      const v1 = quadStrip.vertices[i + 1];\n      const v2 = quadStrip.vertices[i + 2];\n      const v3 = quadStrip.vertices[i + 3];\n      this.path.moveTo(v0.position.x, v0.position.y);\n      this.path.lineTo(v1.position.x, v1.position.y);\n      // These are intentionally out of order to go around the quad\n      this.path.lineTo(v3.position.x, v3.position.y);\n      this.path.lineTo(v2.position.x, v2.position.y);\n      this.path.closePath();\n    }\n  }\n}\n\nclass PrimitiveToVerticesConverter extends PrimitiveVisitor {\n  contours = [];\n  curveDetail;\n\n  constructor({ curveDetail = 1 } = {}) {\n    super();\n    this.curveDetail = curveDetail;\n  }\n\n  lastContour() {\n    return this.contours[this.contours.length - 1];\n  }\n\n  visitAnchor(anchor) {\n    this.contours.push([]);\n    // Weird edge case: if the next segment is a spline, we might\n    // need to jump to a different vertex.\n    const next = anchor._nextPrimitive;\n    if (next?.canOverrideAnchor) {\n      this.lastContour().push(next._firstInterpolatedVertex);\n    } else {\n      this.lastContour().push(anchor.getEndVertex());\n    }\n  }\n  visitLineSegment(lineSegment) {\n    this.lastContour().push(lineSegment.getEndVertex());\n  }\n  visitBezierSegment(bezierSegment) {\n    const contour = this.lastContour();\n    const numPoints = Math.max(\n      1,\n      Math.ceil(bezierSegment.hullLength() * this.curveDetail)\n    );\n    const vertexArrays = [\n      bezierSegment.getStartVertex(),\n      ...bezierSegment.vertices\n    ].map(v => bezierSegment._shape.vertexToArray(v));\n    for (let i = 0; i < numPoints; i++) {\n      const t = (i + 1) / numPoints;\n      contour.push(\n        bezierSegment._shape.arrayToVertex(\n          bezierSegment.order === 3\n            ? bezierSegment._shape.evaluateCubicBezier(vertexArrays, t)\n            : bezierSegment._shape.evaluateQuadraticBezier(vertexArrays, t)\n        )\n      );\n    }\n  }\n  visitSplineSegment(splineSegment) {\n    const shape = splineSegment._shape;\n    const contour = this.lastContour();\n\n    const arrayVertices = splineSegment.getControlPoints().map(\n      v => shape.vertexToArray(v)\n    );\n    let bezierArrays = shape.catmullRomToBezier(\n      arrayVertices,\n      splineSegment._splineProperties.tightness\n    );\n    let startVertex = shape.vertexToArray(splineSegment._firstInterpolatedVertex);\n    for (const array of bezierArrays) {\n      const bezierControls = [startVertex, ...array];\n      const numPoints = Math.max(\n        1,\n        Math.ceil(\n          polylineLength(bezierControls.map(v => shape.arrayToVertex(v))) *\n          this.curveDetail\n        )\n      );\n      for (let i = 0; i < numPoints; i++) {\n        const t = (i + 1) / numPoints;\n        contour.push(\n          shape.arrayToVertex(shape.evaluateCubicBezier(bezierControls, t))\n        );\n      }\n      startVertex = array[2];\n    }\n  }\n  visitPoint(point) {\n    this.contours.push(point.vertices.slice());\n  }\n  visitLine(line) {\n    this.contours.push(line.vertices.slice());\n  }\n  visitTriangle(triangle) {\n    this.contours.push(triangle.vertices.slice());\n  }\n  visitQuad(quad) {\n    this.contours.push(quad.vertices.slice());\n  }\n  visitTriangleFan(triangleFan) {\n    // WebGL itself interprets the vertices as a fan, no reformatting needed\n    this.contours.push(triangleFan.vertices.slice());\n  }\n  visitTriangleStrip(triangleStrip) {\n    // WebGL itself interprets the vertices as a strip, no reformatting needed\n    this.contours.push(triangleStrip.vertices.slice());\n  }\n  visitQuadStrip(quadStrip) {\n    // WebGL itself interprets the vertices as a strip, no reformatting needed\n    this.contours.push(quadStrip.vertices.slice());\n  }\n}\n\nclass PointAtLengthGetter extends PrimitiveVisitor {\n  constructor() {\n    super();\n  }\n}\n\nfunction customShapes(p5, fn) {\n  // ---- GENERAL CLASSES ----\n\n  /**\n     * @private\n     * A class to describe a custom shape made with `beginShape()`/`endShape()`.\n     *\n     * Every `Shape` has a `kind`. The kind takes any value that\n     * can be passed to <a href=\"#/p5/beginShape\">beginShape()</a>:\n     *\n     * - `PATH`\n     * - `POINTS`\n     * - `LINES`\n     * - `TRIANGLES`\n     * - `QUADS`\n     * - `TRIANGLE_FAN`\n     * - `TRIANGLE_STRIP`\n     * - `QUAD_STRIP`\n     *\n     * A `Shape` of any kind consists of `contours`, which can be thought of as\n     * subshapes (shapes inside another shape). Each `contour` is built from\n     * basic shapes called primitives, and each primitive consists of one or more vertices.\n     *\n     * For example, a square can be made from a single path contour with four line-segment\n     * primitives. Each line segment contains a vertex that indicates its endpoint. A square\n     * with a circular hole in it contains the circle in a separate contour.\n     *\n     * By default, each vertex only has a position, but a shape's vertices may have other\n     * properties such as texture coordinates, a normal vector, a fill color, and a stroke color.\n     * The properties every vertex should have may be customized by passing `vertexProperties` to\n     * `createShape()`.\n     *\n     * Once a shape is created and given a name like `myShape`, it can be built up with\n     * methods such as `myShape.beginShape()`, `myShape.vertex()`, and `myShape.endShape()`.\n     *\n     * Vertex functions such as `vertex()` or `bezierVertex()` are used to set the `position`\n     * property of vertices, as well as the `textureCoordinates` property if applicable. Those\n     * properties only apply to a single vertex.\n     *\n     * If `vertexProperties` includes other properties, they are each set by a method of the\n     * same name. For example, if vertices in `myShape` have a `fill`, then that is set with\n     * `myShape.fill()`. In the same way that a <a href=\"#/p5/fill\">fill()</a> may be applied\n     * to one or more shapes, `myShape.fill()` may be applied to one or more vertices.\n     *\n     * @class p5.Shape\n     * @param {Object} [vertexProperties={position: createVector(0, 0)}] vertex properties and their initial values.\n     */\n\n  p5.Shape = Shape;\n\n  /**\n     * @private\n     * A class to describe a contour made with `beginContour()`/`endContour()`.\n     *\n     * Contours may be thought of as shapes inside of other shapes.\n     * For example, a contour may be used to create a hole in a shape that is created\n     * with <a href=\"#/p5/beginShape\">beginShape()</a>/<a href=\"#/p5/endShape\">endShape()</a>.\n     * Multiple contours may be included inside a single shape.\n     *\n     * Contours can have any `kind` that a shape can have:\n     *\n     * - `PATH`\n     * - `POINTS`\n     * - `LINES`\n     * - `TRIANGLES`\n     * - `QUADS`\n     * - `TRIANGLE_FAN`\n     * - `TRIANGLE_STRIP`\n     * - `QUAD_STRIP`\n     *\n     * By default, a contour has the same kind as the shape that contains it, but this\n     * may be changed by passing a different `kind` to <a href=\"#/p5/beginContour\">beginContour()</a>.\n     *\n     * A `Contour` of any kind consists of `primitives`, which are the most basic\n     * shapes that can be drawn. For example, if a contour is a hexagon, then\n     * it's made from six line-segment primitives.\n     *\n     * @class p5.Contour\n     */\n\n  p5.Contour = Contour;\n\n  /**\n     * @private\n     * A base class to describe a shape primitive (a basic shape drawn with\n     * `beginShape()`/`endShape()`).\n     *\n     * Shape primitives are the most basic shapes that can be drawn with\n     * <a href=\"#/p5/beginShape\">beginShape()</a>/<a href=\"#/p5/endShape\">endShape()</a>:\n     *\n     * - segment primitives: line segments, bezier segments, spline segments, and arc segments\n     * - isolated primitives: points, lines, triangles, and quads\n     * - tessellation primitives: triangle fans, triangle strips, and quad strips\n     *\n     * More complex shapes may be created by combining many primitives, possibly of different kinds,\n     * into a single shape.\n     *\n     * In a similar way, every shape primitive is built from one or more vertices.\n     * For example, a point consists of a single vertex, while a triangle consists of three vertices.\n     * Each type of shape primitive has a `vertexCapacity`, which may be `Infinity` (for example, a\n     * spline may consist of any number of vertices). A primitive's `vertexCount` is the number of\n     * vertices it currently contains.\n     *\n     * Each primitive can add itself to a shape with an `addToShape()` method.\n     *\n     * It can also accept visitor objects with an `accept()` method. When a primitive accepts a visitor,\n     * it gives the visitor access to its vertex data. For example, one visitor to a segment might turn\n     * the data into 2D drawing instructions. Another might find a point at a given distance\n     * along the segment.\n     *\n     * @class p5.ShapePrimitive\n     * @abstract\n     */\n\n  p5.ShapePrimitive = ShapePrimitive;\n\n  /**\n     * @private\n     * A class to describe a vertex (a point on a shape), in 2D or 3D.\n     *\n     * Vertices are the basic building blocks of all `p5.Shape` objects, including\n     * shapes made with <a href=\"#/p5/vertex\">vertex()</a>, <a href=\"#/p5/arcVertex\">arcVertex()</a>,\n     * <a href=\"#/p5/bezierVertex\">bezierVertex()</a>, and <a href=\"#/p5/splineVertex\">splineVertex()</a>.\n     *\n     * Like a point on an object in the real world, a vertex may have different properties.\n     * These may include coordinate properties such as `position`, `textureCoordinates`, and `normal`,\n     * color properties such as `fill` and `stroke`, and more.\n     *\n     * A vertex called `myVertex` with position coordinates `(2, 3, 5)` and a green stroke may be created\n     * like this:\n     *\n     * ```js\n     * let myVertex = new p5.Vertex({\n     *   position: createVector(2, 3, 5),\n     *   stroke: color('green')\n     * });\n     * ```\n     *\n     * Any property names may be used. The `p5.Shape` class assumes that if a vertex has a\n     * position or texture coordinates, they are stored in `position` and `textureCoordinates`\n     * properties.\n     *\n     * Property values may be any\n     * <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Primitive\">JavaScript primitive</a>, any\n     * <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer\">object literal</a>,\n     * or any object with an `array` property.\n     *\n     * For example, if a position is stored as a `p5.Vector` object and a stroke is stored as a `p5.Color` object,\n     * then the `array` properties of those objects will be used by the vertex's own `array` property, which provides\n     * all the vertex data in a single array.\n     *\n     * @class p5.Vertex\n     * @param {Object} [properties={position: createVector(0, 0)}] vertex properties.\n     */\n\n  p5.Vertex = Vertex;\n\n  // ---- PATH PRIMITIVES ----\n\n  /**\n     * @private\n     * A class responsible for...\n     *\n     * @class p5.Anchor\n     * @extends p5.ShapePrimitive\n     * @param {p5.Vertex} vertex the vertex to include in the anchor.\n     */\n\n  p5.Anchor = Anchor;\n\n  /**\n     * @private\n     * A class responsible for...\n     *\n     * Note: When a segment is added to a shape, it's attached to an anchor or another segment.\n     * Adding it to another shape may result in unexpected behavior.\n     *\n     * @class p5.Segment\n     * @extends p5.ShapePrimitive\n     * @param {...p5.Vertex} vertices the vertices to include in the segment.\n     */\n\n  p5.Segment = Segment;\n\n  /**\n     * @private\n     * A class responsible for...\n     *\n     * @class p5.LineSegment\n     * @param {p5.Vertex} vertex the vertex to include in the anchor.\n     */\n\n  p5.LineSegment = LineSegment;\n\n  /**\n     * @private\n     * A class responsible for...\n     */\n\n  p5.BezierSegment = BezierSegment;\n\n  /**\n     * @private\n     * A class responsible for...\n     */\n\n  p5.SplineSegment = SplineSegment;\n\n  // ---- ISOLATED PRIMITIVES ----\n\n  /**\n     * @private\n     * A class responsible for...\n     */\n\n  p5.Point = Point;\n\n  /**\n     * @private\n     * A class responsible for...\n     *\n     * @class p5.Line\n     * @param {...p5.Vertex} vertices the vertices to include in the line.\n     */\n\n  p5.Line = Line;\n\n  /**\n     * @private\n     * A class responsible for...\n     */\n\n  p5.Triangle = Triangle;\n\n  /**\n     * @private\n     * A class responsible for...\n     */\n\n  p5.Quad = Quad;\n\n  // ---- TESSELLATION PRIMITIVES ----\n\n  /**\n     * @private\n     * A class responsible for...\n     */\n\n  p5.TriangleFan = TriangleFan;\n\n  /**\n     * @private\n     * A class responsible for...\n     */\n\n  p5.TriangleStrip = TriangleStrip;\n\n  /**\n     * @private\n     * A class responsible for...\n     */\n\n  p5.QuadStrip = QuadStrip;\n\n  // ---- PRIMITIVE VISITORS ----\n\n  /**\n     * @private\n     * A class responsible for...\n     */\n\n  p5.PrimitiveVisitor = PrimitiveVisitor;\n\n  /**\n     * @private\n     * A class responsible for...\n     *\n     * Notes:\n     * 1. Assumes vertex positions are stored as p5.Vector instances.\n     * 2. Currently only supports position properties of vectors.\n     */\n\n  p5.PrimitiveToPath2DConverter = PrimitiveToPath2DConverter;\n\n  /**\n     * @private\n     * A class responsible for...\n     */\n\n  p5.PrimitiveToVerticesConverter = PrimitiveToVerticesConverter;\n\n  /**\n     * @private\n     * A class responsible for...\n     */\n\n  p5.PointAtLengthGetter = PointAtLengthGetter;\n\n  // ---- FUNCTIONS ----\n\n\n  /**\n   * Influences the shape of the BÃ©zier curve segment in a custom shape.\n   * By default, this is 3; the other possible parameter is 2. This\n   * results in quadratic BÃ©zier curves.\n   *\n   * `bezierVertex()` adds a curved segment to custom shapes. The BÃ©zier curves\n   * it creates are defined like those made by the\n   * <a href=\"#/p5/bezier\">bezier()</a> function. `bezierVertex()` must be\n   * called between the\n   * <a href=\"#/p5/beginShape\">beginShape()</a> and\n   * <a href=\"#/p5/endShape\">endShape()</a> functions. There must be at least\n   * one call to <a href=\"#/p5/vertex\">bezierVertex()</a>, before\n   * a number of `bezierVertex()` calls that is a multiple of the parameter\n   * set by <a href=\"#/p5/bezierOrder\">bezierOrder(...)</a> (default 3).\n   * \n   * Each curve of order 3 requires three calls to `bezierVertex`, so\n   * 2 curves would need 7 calls to `bezierVertex()`:\n   * (1 one initial anchor point, two sets of 3 curves describing the curves)\n   * With `bezierOrder(2)`, two curves would need 5 calls: 1 + 2 + 2. \n   *\n   * BÃ©zier curves can also be drawn in 3D using WebGL mode.\n   *\n   * Note: `bezierVertex()` wonâ€™t work when an argument is passed to\n   * <a href=\"#/p5/beginShape\">beginShape()</a>.\n   *\n   * @method bezierOrder\n   * @param {Number} order The new order to set. Can be either 2 or 3, by default 3\n   * \n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Style the shape.\n   *   noFill();\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   * \n   *   // set the order to 2 for a quadratic BÃ©zier curve\n   *   bezierOrder(2);\n   *\n   *   // Add the first anchor point.\n   *   bezierVertex(30, 20);\n   *\n   *   // Add the BÃ©zier vertex.\n   *   bezierVertex(80, 20);\n   *   bezierVertex(50, 50);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   describe('A black curve drawn on a gray square. The curve starts at the top-left corner and ends at the center.');\n   * }\n   * </code>\n   * </div>\n   */\n  /**\n   * @method bezierOrder\n   * @returns {Number} The current BÃ©zier order.\n   */\n  fn.bezierOrder = function(order) {\n    return this._renderer.bezierOrder(order);\n  };\n\n\n/**\n   * Adds a spline curve segment to a custom shape.\n   *\n   * `splineVertex()` adds a curved segment to custom shapes. The spline curves\n   * it creates are defined like those made by the\n   * <a href=\"#/p5/curve\">curve()</a> function. `splineVertex()` must be called\n   * between the <a href=\"#/p5/beginShape\">beginShape()</a> and\n   * <a href=\"#/p5/endShape\">endShape()</a> functions.\n   *\n   * Spline curves can form shapes and curves that slope gently. Theyâ€™re like\n   * cables that are attached to a set of points. Splines are defined by two\n   * anchor points and two control points. `splineVertex()` must be called at\n   * least four times between\n   * <a href=\"#/p5/beginShape\">beginShape()</a> and\n   * <a href=\"#/p5/endShape\">endShape()</a> in order to draw a curve:\n   *\n   * ```js\n   * beginShape();\n   *\n   * // Add the first control point.\n   * splineVertex(84, 91);\n   *\n   * // Add the anchor points to draw between.\n   * splineVertex(68, 19);\n   * splineVertex(21, 17);\n   *\n   * // Add the second control point.\n   * splineVertex(32, 91);\n   *\n   * endShape();\n   * ```\n   *\n   * The code snippet above would only draw the curve between the anchor points,\n   * similar to the <a href=\"#/p5/curve\">curve()</a> function. The segments\n   * between the control and anchor points can be drawn by calling\n   * `splineVertex()` with the coordinates of the control points:\n   *\n   * ```js\n   * beginShape();\n   *\n   * // Add the first control point and draw a segment to it.\n   * splineVertex(84, 91);\n   * splineVertex(84, 91);\n   *\n   * // Add the anchor points to draw between.\n   * splineVertex(68, 19);\n   * splineVertex(21, 17);\n   *\n   * // Add the second control point.\n   * splineVertex(32, 91);\n   *\n   * // Uncomment the next line to draw the segment to the second control point.\n   * // splineVertex(32, 91);\n   *\n   * endShape();\n   * ```\n   *\n   * The first two parameters, `x` and `y`, set the vertexâ€™s location. For\n   * example, calling `splineVertex(10, 10)` adds a point to the curve at\n   * `(10, 10)`.\n   *\n   * Spline curves can also be drawn in 3D using WebGL mode. The 3D version of\n   * `splineVertex()` has three arguments because each point has x-, y-, and\n   * z-coordinates. By default, the vertexâ€™s z-coordinate is set to 0.\n   *\n   * Note: `splineVertex()` wonâ€™t work when an argument is passed to\n   * <a href=\"#/p5/beginShape\">beginShape()</a>.\n   *\n   * @method splineVertex\n   * @param {Number} x x-coordinate of the vertex\n   * @param {Number} y y-coordinate of the vertex\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Style the shape.\n   *   noFill();\n   *   strokeWeight(1);\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Add the first control point.\n   *   splineVertex(32, 91);\n   *\n   *   // Add the anchor points.\n   *   splineVertex(21, 17);\n   *   splineVertex(68, 19);\n   *\n   *   // Add the second control point.\n   *   splineVertex(84, 91);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   // Style the anchor and control points.\n   *   strokeWeight(5);\n   *\n   *   // Draw the anchor points in black.\n   *   stroke(0);\n   *   point(21, 17);\n   *   point(68, 19);\n   *\n   *   // Draw the control points in red.\n   *   stroke(255, 0, 0);\n   *   point(32, 91);\n   *   point(84, 91);\n   *\n   *   describe(\n   *     'A black curve drawn on a gray background. The curve has black dots at its ends. Two red dots appear near the bottom of the canvas.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Style the shape.\n   *   noFill();\n   *   strokeWeight(1);\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Add the first control point and draw a segment to it.\n   *   splineVertex(32, 91);\n   *   splineVertex(32, 91);\n   *\n   *   // Add the anchor points.\n   *   splineVertex(21, 17);\n   *   splineVertex(68, 19);\n   *\n   *   // Add the second control point.\n   *   splineVertex(84, 91);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   // Style the anchor and control points.\n   *   strokeWeight(5);\n   *\n   *   // Draw the anchor points in black.\n   *   stroke(0);\n   *   point(21, 17);\n   *   point(68, 19);\n   *\n   *   // Draw the control points in red.\n   *   stroke(255, 0, 0);\n   *   point(32, 91);\n   *   point(84, 91);\n   *\n   *   describe(\n   *     'A black curve drawn on a gray background. The curve passes through one red dot and two black dots. Another red dot appears near the bottom of the canvas.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Style the shape.\n   *   noFill();\n   *   strokeWeight(1);\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Add the first control point and draw a segment to it.\n   *   splineVertex(32, 91);\n   *   splineVertex(32, 91);\n   *\n   *   // Add the anchor points.\n   *   splineVertex(21, 17);\n   *   splineVertex(68, 19);\n   *\n   *   // Add the second control point and draw a segment to it.\n   *   splineVertex(84, 91);\n   *   splineVertex(84, 91);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   // Style the anchor and control points.\n   *   strokeWeight(5);\n   *\n   *   // Draw the anchor points in black.\n   *   stroke(0);\n   *   point(21, 17);\n   *   point(68, 19);\n   *\n   *   // Draw the control points in red.\n   *   stroke(255, 0, 0);\n   *   point(32, 91);\n   *   point(84, 91);\n   *\n   *   describe(\n   *     'A black U curve drawn upside down on a gray background. The curve passes from one red dot through two black dots and ends at another red dot.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click the mouse near the red dot in the bottom-left corner\n   * // and drag to change the curve's shape.\n   *\n   * let x1 = 32;\n   * let y1 = 91;\n   * let isChanging = false;\n   *\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   describe(\n   *     'A black U curve drawn upside down on a gray background. The curve passes from one red dot through two black dots and ends at another red dot.'\n   *   );\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Style the shape.\n   *   noFill();\n   *   stroke(0);\n   *   strokeWeight(1);\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Add the first control point and draw a segment to it.\n   *   splineVertex(x1, y1);\n   *   splineVertex(x1, y1);\n   *\n   *   // Add the anchor points.\n   *   splineVertex(21, 17);\n   *   splineVertex(68, 19);\n   *\n   *   // Add the second control point and draw a segment to it.\n   *   splineVertex(84, 91);\n   *   splineVertex(84, 91);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   // Style the anchor and control points.\n   *   strokeWeight(5);\n   *\n   *   // Draw the anchor points in black.\n   *   stroke(0);\n   *   point(21, 17);\n   *   point(68, 19);\n   *\n   *   // Draw the control points in red.\n   *   stroke(255, 0, 0);\n   *   point(x1, y1);\n   *   point(84, 91);\n   * }\n   *\n   * // Start changing the first control point if the user clicks near it.\n   * function mousePressed() {\n   *   if (dist(mouseX, mouseY, x1, y1) < 20) {\n   *     isChanging = true;\n   *   }\n   * }\n   *\n   * // Stop changing the first control point when the user releases the mouse.\n   * function mouseReleased() {\n   *   isChanging = false;\n   * }\n   *\n   * // Update the first control point while the user drags the mouse.\n   * function mouseDragged() {\n   *   if (isChanging === true) {\n   *     x1 = mouseX;\n   *     y1 = mouseY;\n   *   }\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Add the first control point and draw a segment to it.\n   *   splineVertex(32, 91);\n   *   splineVertex(32, 91);\n   *\n   *   // Add the anchor points.\n   *   splineVertex(21, 17);\n   *   splineVertex(68, 19);\n   *\n   *   // Add the second control point.\n   *   splineVertex(84, 91);\n   *   splineVertex(84, 91);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   describe('A ghost shape drawn in white on a gray background.');\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * @method splineVertex\n   * @param {Number} x\n   * @param {Number} y\n   * @param {Number} [z] z-coordinate of the vertex.\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A ghost shape drawn in white on a blue background. When the user drags the mouse, the scene rotates to reveal the outline of a second ghost.');\n   * }\n   *\n   * function draw() {\n   *   background('midnightblue');\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the first ghost.\n   *   noStroke();\n   *   fill('ghostwhite');\n   *\n   *   beginShape();\n   *   splineVertex(-28, 41, 0);\n   *   splineVertex(-28, 41, 0);\n   *   splineVertex(-29, -33, 0);\n   *   splineVertex(18, -31, 0);\n   *   splineVertex(34, 41, 0);\n   *   splineVertex(34, 41, 0);\n   *   endShape();\n   *\n   *   // Draw the second ghost.\n   *   noFill();\n   *   stroke('ghostwhite');\n   *\n   *   beginShape();\n   *   splineVertex(-28, 41, -20);\n   *   splineVertex(-28, 41, -20);\n   *   splineVertex(-29, -33, -20);\n   *   splineVertex(18, -31, -20);\n   *   splineVertex(34, 41, -20);\n   *   splineVertex(34, 41, -20);\n   *   endShape();\n   * }\n   * </code>\n   * </div>\n   */\n  /**\n   * @method splineVertex\n   * @param {Number} x\n   * @param {Number} y\n   * @param {Number} [u=0]\n   * @param {Number} [v=0]\n   */\n  /**\n   * @method splineVertex\n   * @param {Number} x\n   * @param {Number} y\n   * @param {Number} z\n   * @param {Number} [u=0]\n   * @param {Number} [v=0]\n   */\n  fn.splineVertex = function(...args) {\n    let x = 0, y = 0, z = 0, u = 0, v = 0;\n    if (args.length === 2) {\n      [x, y] = args;\n    } else if (args.length === 4) {\n      [x, y, u, v] = args;\n    } else if (args.length === 3) {\n      [x, y, z] = args;\n    } else if (args.length === 5) {\n      [x, y, z, u, v] = args;\n    }\n    this._renderer.splineVertex(x, y, z, u, v);\n  };\n\n  /**\n   * Sets the property of a curve.\n   * \n   * For example, set tightness,\n   * use `splineProperty('tightness', t)`, with `t` between 0 and 1,\n   * at 0 as default.\n   * \n   * Spline curves are like cables that are attached to a set of points.\n   * Adjusting tightness adjusts how tightly the cable is\n   * attached to the points. The parameter, tightness, determines\n   * how the curve fits to the vertex points. By default,\n   * tightness is set to 0. Setting tightness to 1, as in\n   * `splineProperty('tightness', 1)`, connects the curve's points\n   * using straight lines. Values in the range from â€“5 to 5\n   * deform curves while leaving them recognizable.\n   * \n   * This function can also be used to set 'ends' property\n   * (see also: the <a href=\"#/p5/curveDetail\">curveDetail()</a> example),\n   * such as: `splineProperty('ends', EXCLUDE)` to exclude\n   * vertices, or `splineProperty('ends', INCLUDE)` to include them.\n   * \n   * @method splineProperty\n   * @param {String} property\n   * @param value Value to set the given property to.\n   * \n   * @example\n   * <div>\n   * <code>\n   * // Move the mouse left and right to see the curve change.\n   * \n   * function setup() {\n   *   createCanvas(100, 100);\n   *   describe('A black curve forms a sideways U shape. The curve deforms as the user moves the mouse from left to right');\n   * }\n   * \n   * function draw() {\n   *   background(200);\n   * \n   *   // Set the curve's tightness using the mouse.\n   *   let t = map(mouseX, 0, 100, -5, 5, true);\n   *   splineProperty('tightness', t);\n   * \n   *   // Draw the curve.\n   *   noFill();\n   *   beginShape();\n   *   splineVertex(10, 26);\n   *   splineVertex(10, 26);\n   *   splineVertex(83, 24);\n   *   splineVertex(83, 61);\n   *   splineVertex(25, 65);\n   *   splineVertex(25, 65);\n   *   endShape();\n   * }\n   * </code>\n   * </div>\n   */\n  /**\n   * @method splineProperty\n   * @param {String} property\n   * @returns The current value for the given property.\n   */\n  fn.splineProperty = function(property, value) {\n    return this._renderer.splineProperty(property, value);\n  };\n\n  /**\n   * Get or set multiple spline properties at once.\n   * \n   * Similar to <a href=\"#/p5/splineProperty\">splineProperty()</a>:\n   * `splineProperty('tightness', t)` is the same as\n   * `splineProperties({'tightness': t})`\n   * \n   * @method splineProperties\n   * @param {Object} properties An object containing key-value pairs to set.\n   */\n  /**\n   * @method splineProperties\n   * @returns {Object} The current spline properties.\n   */\n  fn.splineProperties = function(values) {\n    return this._renderer.splineProperties(values);\n  };\n\n  /**\n   * Adds a vertex to a custom shape.\n   *\n   * `vertex()` sets the coordinates of vertices drawn between the\n   * <a href=\"#/p5/beginShape\">beginShape()</a> and\n   * <a href=\"#/p5/endShape\">endShape()</a> functions.\n   *\n   * The first two parameters, `x` and `y`, set the x- and y-coordinates of the\n   * vertex.\n   *\n   * The third parameter, `z`, is optional. It sets the z-coordinate of the\n   * vertex in WebGL mode. By default, `z` is 0.\n   *\n   * The fourth and fifth parameters, `u` and `v`, are also optional. They set\n   * the u- and v-coordinates for the vertexâ€™s texture when used with\n   * <a href=\"#/p5/endShape\">endShape()</a>. By default, `u` and `v` are both 0.\n   *\n   * @method vertex\n   * @param  {Number} x x-coordinate of the vertex.\n   * @param  {Number} y y-coordinate of the vertex.\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Style the shape.\n   *   strokeWeight(3);\n   *\n   *   // Start drawing the shape.\n   *   // Only draw the vertices.\n   *   beginShape(POINTS);\n   *\n   *   // Add the vertices.\n   *   vertex(30, 20);\n   *   vertex(85, 20);\n   *   vertex(85, 75);\n   *   vertex(30, 75);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   describe('Four black dots that form a square are drawn on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Add vertices.\n   *   vertex(30, 20);\n   *   vertex(85, 20);\n   *   vertex(85, 75);\n   *   vertex(30, 75);\n   *\n   *   // Stop drawing the shape.\n   *   endShape(CLOSE);\n   *\n   *   describe('A white square on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Add vertices.\n   *   vertex(-20, -30, 0);\n   *   vertex(35, -30, 0);\n   *   vertex(35, 25, 0);\n   *   vertex(-20, 25, 0);\n   *\n   *   // Stop drawing the shape.\n   *   endShape(CLOSE);\n   *\n   *   describe('A white square on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A white square spins around slowly on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Rotate around the y-axis.\n   *   rotateY(frameCount * 0.01);\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Add vertices.\n   *   vertex(-20, -30, 0);\n   *   vertex(35, -30, 0);\n   *   vertex(35, 25, 0);\n   *   vertex(-20, 25, 0);\n   *\n   *   // Stop drawing the shape.\n   *   endShape(CLOSE);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   // Load an image to apply as a texture.\n   *   img = await loadImage('assets/laDefense.jpg');\n   *\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A photograph of a ceiling rotates slowly against a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Rotate around the y-axis.\n   *   rotateY(frameCount * 0.01);\n   *\n   *   // Style the shape.\n   *   noStroke();\n   *\n   *   // Apply the texture.\n   *   texture(img);\n   *   textureMode(NORMAL);\n   *\n   *   // Start drawing the shape\n   *   beginShape();\n   *\n   *   // Add vertices.\n   *   vertex(-20, -30, 0, 0, 0);\n   *   vertex(35, -30, 0, 1, 0);\n   *   vertex(35, 25, 0, 1, 1);\n   *   vertex(-20, 25, 0, 0, 1);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   * }\n   * </code>\n   * </div>\n   * \n   * <div>\n   * <code>\n   * let vid;\n   * function setup() {\n   *   // Load a video and create a p5.MediaElement object.\n   *   vid = createVideo('/assets/fingers.mov');\n   *   createCanvas(100, 100, WEBGL);\n   * \n   *   // Hide the video.\n   *   vid.hide();\n   * \n   *   // Set the video to loop.\n   *   vid.loop();\n   * \n   *   describe('A rectangle with video as texture');\n   * }\n   * \n   * function draw() {\n   *   background(0);\n   * \n   *   // Rotate around the y-axis.\n   *   rotateY(frameCount * 0.01);\n   * \n   *   // Set the texture mode.\n   *   textureMode(NORMAL);\n   * \n   *   // Apply the video as a texture.\n   *   texture(vid);\n   * \n   *   // Draw a custom shape using uv coordinates.\n   *   beginShape();\n   *   vertex(-40, -40, 0, 0);\n   *   vertex(40, -40, 1, 0);\n   *   vertex(40, 40, 1, 1);\n   *   vertex(-40, 40, 0, 1);\n   *   endShape();\n   * }\n   * </code>\n   * </div>\n   */\n  /**\n   * @method vertex\n   * @param  {Number} x\n   * @param  {Number} y\n   * @param  {Number} [u=0]   u-coordinate of the vertex's texture.\n   * @param  {Number} [v=0]   v-coordinate of the vertex's texture.\n   */\n  /**\n   * @method vertex\n   * @param  {Number} x\n   * @param  {Number} y\n   * @param  {Number} z\n   * @param  {Number} [u=0]   u-coordinate of the vertex's texture.\n   * @param  {Number} [v=0]   v-coordinate of the vertex's texture.\n   */\n  fn.vertex = function(x, y) {\n    let z, u, v;\n\n    // default to (x, y) mode: all other arguments assumed to be 0.\n    z = u = v = 0;\n\n    if (arguments.length === 3) {\n      // (x, y, z) mode: (u, v) assumed to be 0.\n      z = arguments[2];\n    } else if (arguments.length === 4) {\n      // (x, y, u, v) mode: z assumed to be 0.\n      u = arguments[2];\n      v = arguments[3];\n    } else if (arguments.length === 5) {\n      // (x, y, z, u, v) mode\n      z = arguments[2];\n      u = arguments[3];\n      v = arguments[4];\n    }\n    this._renderer.vertex(x, y, z, u, v);\n    return;\n  };\n\n  /**\n   * Begins creating a hole within a flat shape.\n   *\n   * The `beginContour()` and <a href=\"#/p5/endContour\">endContour()</a>\n   * functions allow for creating negative space within custom shapes that are\n   * flat. `beginContour()` begins adding vertices to a negative space and\n   * <a href=\"#/p5/endContour\">endContour()</a> stops adding them.\n   * `beginContour()` and <a href=\"#/p5/endContour\">endContour()</a> must be\n   * called between <a href=\"#/p5/beginShape\">beginShape()</a> and\n   * <a href=\"#/p5/endShape\">endShape()</a>.\n   *\n   * Transformations such as <a href=\"#/p5/translate\">translate()</a>,\n   * <a href=\"#/p5/rotate\">rotate()</a>, and <a href=\"#/p5/scale\">scale()</a>\n   * don't work between `beginContour()` and\n   * <a href=\"#/p5/endContour\">endContour()</a>. It's also not possible to use\n   * other shapes, such as <a href=\"#/p5/ellipse\">ellipse()</a> or\n   * <a href=\"#/p5/rect\">rect()</a>, between `beginContour()` and\n   * <a href=\"#/p5/endContour\">endContour()</a>.\n   *\n   * Note: The vertices that define a negative space must \"wind\" in the opposite\n   * direction from the outer shape. First, draw vertices for the outer shape\n   * clockwise order. Then, draw vertices for the negative space in\n   * counter-clockwise order.\n   *\n   * @method beginContour\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Exterior vertices, clockwise winding.\n   *   vertex(10, 10);\n   *   vertex(90, 10);\n   *   vertex(90, 90);\n   *   vertex(10, 90);\n   *\n   *   // Interior vertices, counter-clockwise winding.\n   *   beginContour();\n   *   vertex(30, 30);\n   *   vertex(30, 70);\n   *   vertex(70, 70);\n   *   vertex(70, 30);\n   *   endContour(CLOSE);\n   *\n   *   // Stop drawing the shape.\n   *   endShape(CLOSE);\n   *\n   *   describe('A white square with a square hole in its center drawn on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A white square with a square hole in its center drawn on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Exterior vertices, clockwise winding.\n   *   vertex(-40, -40);\n   *   vertex(40, -40);\n   *   vertex(40, 40);\n   *   vertex(-40, 40);\n   *\n   *   // Interior vertices, counter-clockwise winding.\n   *   beginContour();\n   *   vertex(-20, -20);\n   *   vertex(-20, 20);\n   *   vertex(20, 20);\n   *   vertex(20, -20);\n   *   endContour(CLOSE);\n   *\n   *   // Stop drawing the shape.\n   *   endShape(CLOSE);\n   * }\n   * </code>\n   * </div>\n   */\n  fn.beginContour = function(kind) {\n    this._renderer.beginContour(kind);\n  };\n\n  /**\n   * Stops creating a hole within a flat shape. \n   *\n   * The <a href=\"#/p5/beginContour\">beginContour()</a> and `endContour()`\n   * functions allow for creating negative space within custom shapes that are\n   * flat. <a href=\"#/p5/beginContour\">beginContour()</a> begins adding vertices\n   * to a negative space and `endContour()` stops adding them.\n   * <a href=\"#/p5/beginContour\">beginContour()</a> and `endContour()` must be\n   * called between <a href=\"#/p5/beginShape\">beginShape()</a> and\n   * <a href=\"#/p5/endShape\">endShape()</a>.\n   *\n   *  By default, \n   * the controur has an `OPEN` end, and to close it,\n   * call `endContour(CLOSE)`. The CLOSE contour mode closes splines smoothly.\n   * \n   * Transformations such as <a href=\"#/p5/translate\">translate()</a>,\n   * <a href=\"#/p5/rotate\">rotate()</a>, and <a href=\"#/p5/scale\">scale()</a>\n   * don't work between <a href=\"#/p5/beginContour\">beginContour()</a> and\n   * `endContour()`. It's also not possible to use other shapes, such as\n   * <a href=\"#/p5/ellipse\">ellipse()</a> or <a href=\"#/p5/rect\">rect()</a>,\n   * between <a href=\"#/p5/beginContour\">beginContour()</a> and `endContour()`.\n   *\n   * Note: The vertices that define a negative space must \"wind\" in the opposite\n   * direction from the outer shape. First, draw vertices for the outer shape\n   * clockwise order. Then, draw vertices for the negative space in\n   * counter-clockwise order.\n   *\n   * @method endContour\n   * @param {OPEN|CLOSE} [mode=OPEN] By default, the value is OPEN\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Exterior vertices, clockwise winding.\n   *   vertex(10, 10);\n   *   vertex(90, 10);\n   *   vertex(90, 90);\n   *   vertex(10, 90);\n   *\n   *   // Interior vertices, counter-clockwise winding.\n   *   beginContour();\n   *   vertex(30, 30);\n   *   vertex(30, 70);\n   *   vertex(70, 70);\n   *   vertex(70, 30);\n   *   endContour(CLOSE);\n   *\n   *   // Stop drawing the shape.\n   *   endShape(CLOSE);\n   *\n   *   describe('A white square with a square hole in its center drawn on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A white square with a square hole in its center drawn on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Exterior vertices, clockwise winding.\n   *   vertex(-40, -40);\n   *   vertex(40, -40);\n   *   vertex(40, 40);\n   *   vertex(-40, 40);\n   *\n   *   // Interior vertices, counter-clockwise winding.\n   *   beginContour();\n   *   vertex(-20, -20);\n   *   vertex(-20, 20);\n   *   vertex(20, 20);\n   *   vertex(20, -20);\n   *   endContour(CLOSE);\n   *\n   *   // Stop drawing the shape.\n   *   endShape(CLOSE);\n   * }\n   * </code>\n   * </div>\n   */\n  fn.endContour = function(mode = OPEN) {\n    this._renderer.endContour(mode);\n  };\n}\n\nif (typeof p5 !== 'undefined') {\n  customShapes(p5, p5.prototype);\n}\n\nexport { Anchor, BezierSegment, Contour, Line, LineSegment, Point, PointAtLengthGetter, PrimitiveToPath2DConverter, PrimitiveToVerticesConverter, PrimitiveVisitor, Quad, QuadStrip, Segment, Shape, ShapePrimitive, SplineSegment, Triangle, TriangleFan, TriangleStrip, Vertex, customShapes as default };\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2290, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Users/Ryan%20Purnomo/Bahasa-Pemrograman/Website/Javascript/NextJS/CG-GAMES/node_modules/p5/dist/shape/2d_primitives.js"],"sourcesContent":["import { e as CORNER, f as TWO_PI, g as HALF_PI, h as PI } from '../constants-C-g_eAdC.js';\nimport canvas from '../core/helpers.js';\n\n/**\n * @module Shape\n * @submodule 2D Primitives\n * @for p5\n * @requires core\n * @requires constants\n */\n\n\nfunction primitives(p5, fn){\n  /**\n   * This function does 3 things:\n   *\n   *   1. Bounds the desired start/stop angles for an arc (in radians) so that:\n   *\n   *          0 <= start < TWO_PI ;    start <= stop < start + TWO_PI\n   *\n   *      This means that the arc rendering functions don't have to be concerned\n   *      with what happens if stop is smaller than start, or if the arc 'goes\n   *      round more than once', etc.: they can just start at start and increase\n   *      until stop and the correct arc will be drawn.\n   *\n   *   2. Optionally adjusts the angles within each quadrant to counter the naive\n   *      scaling of the underlying ellipse up from the unit circle.  Without\n   *      this, the angles become arbitrary when width != height: 45 degrees\n   *      might be drawn at 5 degrees on a 'wide' ellipse, or at 85 degrees on\n   *      a 'tall' ellipse.\n   *\n   *   3. Flags up when start and stop correspond to the same place on the\n   *      underlying ellipse.  This is useful if you want to do something special\n   *      there (like rendering a whole ellipse instead).\n   */\n  fn._normalizeArcAngles = (\n    start,\n    stop,\n    width,\n    height,\n    correctForScaling\n  ) => {\n    const epsilon = 0.00001; // Smallest visible angle on displays up to 4K.\n    let separation;\n\n    // The order of the steps is important here: each one builds upon the\n    // adjustments made in the steps that precede it.\n\n    // Constrain both start and stop to [0,TWO_PI).\n    start = start - TWO_PI * Math.floor(start / TWO_PI);\n    stop = stop - TWO_PI * Math.floor(stop / TWO_PI);\n\n    // Get the angular separation between the requested start and stop points.\n    //\n    // Technically this separation only matches what gets drawn if\n    // correctForScaling is enabled.  We could add a more complicated calculation\n    // for when the scaling is uncorrected (in which case the drawn points could\n    // end up pushed together or pulled apart quite dramatically relative to what\n    // was requested), but it would make things more opaque for little practical\n    // benefit.\n    //\n    // (If you do disable correctForScaling and find that correspondToSamePoint\n    // is set too aggressively, the easiest thing to do is probably to just make\n    // epsilon smaller...)\n    separation = Math.min(\n      Math.abs(start - stop),\n      TWO_PI - Math.abs(start - stop)\n    );\n\n    // Optionally adjust the angles to counter linear scaling.\n    if (correctForScaling) {\n      if (start <= HALF_PI) {\n        start = Math.atan(width / height * Math.tan(start));\n      } else if (start > HALF_PI && start <= 3 * HALF_PI) {\n        start = Math.atan(width / height * Math.tan(start)) + PI;\n      } else {\n        start = Math.atan(width / height * Math.tan(start)) + TWO_PI;\n      }\n      if (stop <= HALF_PI) {\n        stop = Math.atan(width / height * Math.tan(stop));\n      } else if (stop > HALF_PI && stop <= 3 * HALF_PI) {\n        stop = Math.atan(width / height * Math.tan(stop)) + PI;\n      } else {\n        stop = Math.atan(width / height * Math.tan(stop)) + TWO_PI;\n      }\n    }\n\n    // Ensure that start <= stop < start + TWO_PI.\n    if (start > stop) {\n      stop += TWO_PI;\n    }\n\n    return {\n      start,\n      stop,\n      correspondToSamePoint: separation < epsilon\n    };\n  };\n\n  /**\n   * Draws an arc.\n   *\n   * An arc is a section of an ellipse defined by the `x`, `y`, `w`, and\n   * `h` parameters. `x` and `y` set the location of the arc's center. `w` and\n   * `h` set the arc's width and height. See\n   * <a href=\"#/p5/ellipse\">ellipse()</a> and\n   * <a href=\"#/p5/ellipseMode\">ellipseMode()</a> for more details.\n   *\n   * The fifth and sixth parameters, `start` and `stop`, set the angles\n   * between which to draw the arc. Arcs are always drawn clockwise from\n   * `start` to `stop`. Angles are always given in radians.\n   *\n   * The seventh parameter, `mode`, is optional. It determines the arc's fill\n   * style. The fill modes are a semi-circle (`OPEN`), a closed semi-circle\n   * (`CHORD`), or a closed pie segment (`PIE`).\n   *\n   * The eighth parameter, `detail`, is also optional. It determines how many\n   * vertices are used to draw the arc in WebGL mode. The default value is 25.\n   *\n   * @method arc\n   * @param  {Number} x      x-coordinate of the arc's ellipse.\n   * @param  {Number} y      y-coordinate of the arc's ellipse.\n   * @param  {Number} w      width of the arc's ellipse by default.\n   * @param  {Number} h      height of the arc's ellipse by default.\n   * @param  {Number} start  angle to start the arc, specified in radians.\n   * @param  {Number} stop   angle to stop the arc, specified in radians.\n   * @param  {(CHORD|PIE|OPEN)} [mode] optional parameter to determine the way of drawing\n   *                         the arc. either CHORD, PIE, or OPEN.\n   * @param  {Integer} [detail] optional parameter for WebGL mode only. This is to\n   *                         specify the number of vertices that makes up the\n   *                         perimeter of the arc. Default value is 25. Won't\n   *                         draw a stroke for a detail of more than 50.\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   arc(50, 50, 80, 80, 0, PI + HALF_PI);\n   *\n   *   describe('A white circle on a gray canvas. The top-right quarter of the circle is missing.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   arc(50, 50, 80, 40, 0, PI + HALF_PI);\n   *\n   *   describe('A white ellipse on a gray canvas. The top-right quarter of the ellipse is missing.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Bottom-right.\n   *   arc(50, 55, 50, 50, 0, HALF_PI);\n   *\n   *   noFill();\n   *\n   *   // Bottom-left.\n   *   arc(50, 55, 60, 60, HALF_PI, PI);\n   *\n   *   // Top-left.\n   *   arc(50, 55, 70, 70, PI, PI + QUARTER_PI);\n   *\n   *   // Top-right.\n   *   arc(50, 55, 80, 80, PI + QUARTER_PI, TWO_PI);\n   *\n   *   describe(\n   *     'A shattered outline of an circle with a quarter of a white circle at the bottom-right.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Default fill mode.\n   *   arc(50, 50, 80, 80, 0, PI + QUARTER_PI);\n   *\n   *   describe('A white circle with the top-right third missing. The bottom is outlined in black.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // OPEN fill mode.\n   *   arc(50, 50, 80, 80, 0, PI + QUARTER_PI, OPEN);\n   *\n   *   describe(\n   *     'A white circle missing a section from the top-right. The bottom is outlined in black.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // CHORD fill mode.\n   *   arc(50, 50, 80, 80, 0, PI + QUARTER_PI, CHORD);\n   *\n   *   describe('A white circle with a black outline missing a section from the top-right.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // PIE fill mode.\n   *   arc(50, 50, 80, 80, 0, PI + QUARTER_PI, PIE);\n   *\n   *   describe('A white circle with a black outline. The top-right third is missing.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   // PIE fill mode.\n   *   arc(0, 0, 80, 80, 0, PI + QUARTER_PI, PIE);\n   *\n   *   describe('A white circle with a black outline. The top-right third is missing.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   // PIE fill mode with 5 vertices.\n   *   arc(0, 0, 80, 80, 0, PI + QUARTER_PI, PIE, 5);\n   *\n   *   describe('A white circle with a black outline. The top-right third is missing.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   describe('A yellow circle on a black background. The circle opens and closes its mouth.');\n   * }\n   *\n   * function draw() {\n   *   background(0);\n   *\n   *   // Style the arc.\n   *   noStroke();\n   *   fill(255, 255, 0);\n   *\n   *   // Update start and stop angles.\n   *   let biteSize = PI / 16;\n   *   let startAngle = biteSize * sin(frameCount * 0.1) + biteSize;\n   *   let endAngle = TWO_PI - startAngle;\n   *\n   *   // Draw the arc.\n   *   arc(50, 50, 80, 80, startAngle, endAngle, PIE);\n   * }\n   * </code>\n   * </div>\n   */\n  fn.arc = function(x, y, w, h, start, stop, mode, detail) {\n    // this.validate(\"p5.arc\", arguments);\n    // p5._validateParameters('arc', arguments);\n\n    // if the current stroke and fill settings wouldn't result in something\n    // visible, exit immediately\n    if (!this._renderer.states.strokeColor && !this._renderer.states.fillColor) {\n      return this;\n    }\n\n    if (start === stop) {\n      return this;\n    }\n\n    start = this._toRadians(start);\n    stop = this._toRadians(stop);\n\n    const vals = canvas.modeAdjust(x, y, w, h, this._renderer.states.ellipseMode);\n    const angles = this._normalizeArcAngles(start, stop, vals.w, vals.h, true);\n\n    if (angles.correspondToSamePoint) {\n      // If the arc starts and ends at (near enough) the same place, we choose to\n      // draw an ellipse instead.  This is preferable to faking an ellipse (by\n      // making stop ever-so-slightly less than start + TWO_PI) because the ends\n      // join up to each other rather than at a vertex at the centre (leaving\n      // an unwanted spike in the stroke/fill).\n      this._renderer.ellipse([vals.x, vals.y, vals.w, vals.h, detail]);\n    } else {\n      this._renderer.arc(\n        vals.x,\n        vals.y,\n        vals.w,\n        vals.h,\n        angles.start, // [0, TWO_PI)\n        angles.stop, // [start, start + TWO_PI)\n        mode,\n        detail\n      );\n\n      //accessible Outputs\n      if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {\n        this._accsOutput('arc', [\n          vals.x,\n          vals.y,\n          vals.w,\n          vals.h,\n          angles.start,\n          angles.stop,\n          mode\n        ]);\n      }\n    }\n\n    return this;\n  };\n\n  /**\n   * Draws an ellipse (oval).\n   *\n   * An ellipse is a round shape defined by the `x`, `y`, `w`, and\n   * `h` parameters. `x` and `y` set the location of its center. `w` and\n   * `h` set its width and height. See\n   * <a href=\"#/p5/ellipseMode\">ellipseMode()</a> for other ways to set\n   * its position.\n   *\n   * If no height is set, the value of width is used for both the width and\n   * height. If a negative height or width is specified, the absolute value is\n   * taken.\n   *\n   * The fifth parameter, `detail`, is also optional. It determines how many\n   * vertices are used to draw the ellipse in WebGL mode. The default value is\n   * 25.\n   *\n   * @method ellipse\n   * @param  {Number} x x-coordinate of the center of the ellipse.\n   * @param  {Number} y y-coordinate of the center of the ellipse.\n   * @param  {Number} w width of the ellipse.\n   * @param  {Number} [h] height of the ellipse.\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   ellipse(50, 50, 80, 80);\n   *\n   *   describe('A white circle on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   ellipse(50, 50, 80);\n   *\n   *   describe('A white circle on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   ellipse(50, 50, 80, 40);\n   *\n   *   describe('A white ellipse on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   ellipse(0, 0, 80, 40);\n   *\n   *   describe('A white ellipse on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   // Use 6 vertices.\n   *   ellipse(0, 0, 80, 40, 6);\n   *\n   *   describe('A white hexagon on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * @method ellipse\n   * @param  {Number} x\n   * @param  {Number} y\n   * @param  {Number} w\n   * @param  {Number} h\n   * @param  {Integer} [detail] optional parameter for WebGL mode only. This is to\n   *                         specify the number of vertices that makes up the\n   *                         perimeter of the ellipse. Default value is 25. Won't\n   *                         draw a stroke for a detail of more than 50.\n   */\n  fn.ellipse = function(x, y, w, h, detailX) {\n    // p5._validateParameters('ellipse', arguments);\n    return this._renderEllipse(...arguments);\n  };\n\n  /**\n   * Draws a circle.\n   *\n   * A circle is a round shape defined by the `x`, `y`, and `d` parameters.\n   * `x` and `y` set the location of its center. `d` sets its width and height (diameter).\n   * Every point on the circle's edge is the same distance, `0.5 * d`, from its center.\n   * `0.5 * d` (half the diameter) is the circle's radius.\n   * See <a href=\"#/p5/ellipseMode\">ellipseMode()</a> for other ways to set its position.\n   *\n   * @method circle\n   * @param  {Number} x  x-coordinate of the center of the circle.\n   * @param  {Number} y  y-coordinate of the center of the circle.\n   * @param  {Number} d  diameter of the circle.\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   circle(50, 50, 25);\n   *\n   *   describe('A white circle with black outline in the middle of a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   circle(0, 0, 25);\n   *\n   *   describe('A white circle with black outline in the middle of a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   */\n  fn.circle = function(...args) {\n    // p5._validateParameters('circle', args);\n    const argss = args.slice( 0, 2);\n    argss.push(args[2], args[2]);\n    return this._renderEllipse(...argss);\n  };\n\n  // internal method for drawing ellipses (without parameter validation)\n  fn._renderEllipse = function(x, y, w, h, detailX) {\n    // if the current stroke and fill settings wouldn't result in something\n    // visible, exit immediately\n    if (!this._renderer.states.strokeColor && !this._renderer.states.fillColor) {\n      return this;\n    }\n\n    // Duplicate 3rd argument if only 3 given.\n    if (typeof h === 'undefined') {\n      h = w;\n    }\n\n    const vals = canvas.modeAdjust(x, y, w, h, this._renderer.states.ellipseMode);\n    this._renderer.ellipse([vals.x, vals.y, vals.w, vals.h, detailX]);\n\n    //accessible Outputs\n    if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {\n      this._accsOutput('ellipse', [vals.x, vals.y, vals.w, vals.h]);\n    }\n\n    return this;\n  };\n\n  /**\n   * Draws a straight line between two points.\n   *\n   * A line's default width is one pixel. The version of `line()` with four\n   * parameters draws the line in 2D. To color a line, use the\n   * <a href=\"#/p5/stroke\">stroke()</a> function. To change its width, use the\n   * <a href=\"#/p5/strokeWeight\">strokeWeight()</a> function. A line\n   * can't be filled, so the <a href=\"#/p5/fill\">fill()</a> function won't\n   * affect the line's color.\n   *\n   * The version of `line()` with six parameters allows the line to be drawn in\n   * 3D space. Doing so requires adding the `WEBGL` argument to\n   * <a href=\"#/p5/createCanvas\">createCanvas()</a>.\n   *\n   * @method line\n   * @param  {Number} x1 the x-coordinate of the first point.\n   * @param  {Number} y1 the y-coordinate of the first point.\n   * @param  {Number} x2 the x-coordinate of the second point.\n   * @param  {Number} y2 the y-coordinate of the second point.\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   line(30, 20, 85, 75);\n   *\n   *   describe(\n   *     'A black line on a gray canvas running from top-center to bottom-right.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Style the line.\n   *   stroke('magenta');\n   *   strokeWeight(5);\n   *\n   *   line(30, 20, 85, 75);\n   *\n   *   describe(\n   *     'A thick, magenta line on a gray canvas running from top-center to bottom-right.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Top.\n   *   line(30, 20, 85, 20);\n   *\n   *   // Right.\n   *   stroke(126);\n   *   line(85, 20, 85, 75);\n   *\n   *   // Bottom.\n   *   stroke(255);\n   *   line(85, 75, 30, 75);\n   *\n   *   describe(\n   *     'Three lines drawn in grayscale on a gray canvas. They form the top, right, and bottom sides of a square.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   line(-20, -30, 35, 25);\n   *\n   *   describe(\n   *     'A black line on a gray canvas running from top-center to bottom-right.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A black line connecting two spheres. The scene spins slowly.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Rotate around the y-axis.\n   *   rotateY(frameCount * 0.01);\n   *\n   *   // Draw a line.\n   *   line(0, 0, 0, 30, 20, -10);\n   *\n   *   // Draw the center sphere.\n   *   sphere(10);\n   *\n   *   // Translate to the second point.\n   *   translate(30, 20, -10);\n   *\n   *   // Draw the bottom-right sphere.\n   *   sphere(10);\n   * }\n   * </code>\n   * </div>\n   *\n   */\n\n  /**\n   * @method line\n   * @param  {Number} x1\n   * @param  {Number} y1\n   * @param  {Number} z1 the z-coordinate of the first point.\n   * @param  {Number} x2\n   * @param  {Number} y2\n   * @param  {Number} z2 the z-coordinate of the second point.\n   * @chainable\n   */\n  fn.line = function(...args) {\n    // p5._validateParameters('line', args);\n\n    if (this._renderer.states.strokeColor) {\n      this._renderer.line(...args);\n    }\n\n    //accessible Outputs\n    if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {\n      this._accsOutput('line', args);\n    }\n\n    return this;\n  };\n\n  /**\n   * Draws a single point in space.\n   *\n   * A point's default width is one pixel. To color a point, use the\n   * <a href=\"#/p5/stroke\">stroke()</a> function. To change its width, use the\n   * <a href=\"#/p5/strokeWeight\">strokeWeight()</a> function. A point\n   * can't be filled, so the <a href=\"#/p5/fill\">fill()</a> function won't\n   * affect the point's color.\n   *\n   * The version of `point()` with two parameters allows the point's location to\n   * be set with its x- and y-coordinates, as in `point(10, 20)`.\n   *\n   * The version of `point()` with three parameters allows the point to be drawn\n   * in 3D space with x-, y-, and z-coordinates, as in `point(10, 20, 30)`.\n   * Doing so requires adding the `WEBGL` argument to\n   * <a href=\"#/p5/createCanvas\">createCanvas()</a>.\n   *\n   * The version of `point()` with one parameter allows the point's location to\n   * be set with a <a href=\"#/p5/p5.Vector\">p5.Vector</a> object.\n   *\n   * @method point\n   * @param  {Number} x the x-coordinate.\n   * @param  {Number} y the y-coordinate.\n   * @param  {Number} [z] the z-coordinate (for WebGL mode).\n   * @chainable\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Top-left.\n   *   point(30, 20);\n   *\n   *   // Top-right.\n   *   point(85, 20);\n   *\n   *   // Bottom-right.\n   *   point(85, 75);\n   *\n   *   // Bottom-left.\n   *   point(30, 75);\n   *\n   *   describe(\n   *     'Four small, black points drawn on a gray canvas. The points form the corners of a square.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Top-left.\n   *   point(30, 20);\n   *\n   *   // Top-right.\n   *   point(70, 20);\n   *\n   *   // Style the next points.\n   *   stroke('purple');\n   *   strokeWeight(10);\n   *\n   *   // Bottom-right.\n   *   point(70, 80);\n   *\n   *   // Bottom-left.\n   *   point(30, 80);\n   *\n   *   describe(\n   *     'Four points drawn on a gray canvas. Two are black and two are purple. The points form the corners of a square.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Top-left.\n   *   let a = createVector(30, 20);\n   *   point(a);\n   *\n   *   // Top-right.\n   *   let b = createVector(70, 20);\n   *   point(b);\n   *\n   *   // Bottom-right.\n   *   let c = createVector(70, 80);\n   *   point(c);\n   *\n   *   // Bottom-left.\n   *   let d = createVector(30, 80);\n   *   point(d);\n   *\n   *   describe(\n   *     'Four small, black points drawn on a gray canvas. The points form the corners of a square.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('Two purple points drawn on a gray canvas.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Style the points.\n   *   stroke('purple');\n   *   strokeWeight(10);\n   *\n   *   // Top-left.\n   *   point(-20, -30);\n   *\n   *   // Bottom-right.\n   *   point(20, 30);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('Two purple points drawn on a gray canvas. The scene spins slowly.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Rotate around the y-axis.\n   *   rotateY(frameCount * 0.01);\n   *\n   *   // Style the points.\n   *   stroke('purple');\n   *   strokeWeight(10);\n   *\n   *   // Top-left.\n   *   point(-20, -30, 0);\n   *\n   *   // Bottom-right.\n   *   point(20, 30, -50);\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * @method point\n   * @param {p5.Vector} coordinateVector the coordinate vector.\n   * @chainable\n   */\n  fn.point = function(...args) {\n    // p5._validateParameters('point', args);\n\n    if (this._renderer.states.strokeColor) {\n      if (args.length === 1 && args[0] instanceof p5.Vector) {\n        this._renderer.point.call(\n          this._renderer,\n          args[0].x,\n          args[0].y,\n          args[0].z\n        );\n      } else {\n        this._renderer.point(...args);\n        //accessible Outputs\n        if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {\n          this._accsOutput('point', args);\n        }\n      }\n    }\n\n    return this;\n  };\n\n  /**\n   * Draws a quadrilateral (four-sided shape).\n   *\n   * Quadrilaterals include rectangles, squares, rhombuses, and trapezoids. The\n   * first pair of parameters `(x1, y1)` sets the quad's first point. The next\n   * three pairs of parameters set the coordinates for its next three points\n   * `(x2, y2)`, `(x3, y3)`, and `(x4, y4)`. Points should be added in either\n   * clockwise or counter-clockwise order.\n   *\n   * The version of `quad()` with twelve parameters allows the quad to be drawn\n   * in 3D space. Doing so requires adding the `WEBGL` argument to\n   * <a href=\"#/p5/createCanvas\">createCanvas()</a>.\n   *\n   * The thirteenth and fourteenth parameters are optional. In WebGL mode, they\n   * set the number of segments used to draw the quadrilateral in the x- and\n   * y-directions. They're both 2 by default.\n   *\n   * @method quad\n   * @param {Number} x1 the x-coordinate of the first point.\n   * @param {Number} y1 the y-coordinate of the first point.\n   * @param {Number} x2 the x-coordinate of the second point.\n   * @param {Number} y2 the y-coordinate of the second point.\n   * @param {Number} x3 the x-coordinate of the third point.\n   * @param {Number} y3 the y-coordinate of the third point.\n   * @param {Number} x4 the x-coordinate of the fourth point.\n   * @param {Number} y4 the y-coordinate of the fourth point.\n   * @param {Integer} [detailX] number of segments in the x-direction.\n   * @param {Integer} [detailY] number of segments in the y-direction.\n   * @chainable\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   quad(20, 20, 80, 20, 80, 80, 20, 80);\n   *\n   *   describe('A white square with a black outline drawn on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   quad(20, 30, 80, 30, 80, 70, 20, 70);\n   *\n   *   describe('A white rectangle with a black outline drawn on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   quad(50, 62, 86, 50, 50, 38, 14, 50);\n   *\n   *   describe('A white rhombus with a black outline drawn on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   quad(20, 50, 80, 30, 80, 70, 20, 70);\n   *\n   *   describe('A white trapezoid with a black outline drawn on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   quad(-30, -30, 30, -30, 30, 30, -30, 30);\n   *\n   *   describe('A white square with a black outline drawn on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A wavy white surface spins around on gray canvas.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Rotate around the y-axis.\n   *   rotateY(frameCount * 0.01);\n   *\n   *   // Draw the quad.\n   *   quad(-30, -30, 0, 30, -30, 0, 30, 30, 20, -30, 30, -20);\n   * }\n   * </code>\n   * </div>\n   */\n  /**\n   * @method quad\n   * @param {Number} x1\n   * @param {Number} y1\n   * @param {Number} z1 the z-coordinate of the first point.\n   * @param {Number} x2\n   * @param {Number} y2\n   * @param {Number} z2 the z-coordinate of the second point.\n   * @param {Number} x3\n   * @param {Number} y3\n   * @param {Number} z3 the z-coordinate of the third point.\n   * @param {Number} x4\n   * @param {Number} y4\n   * @param {Number} z4 the z-coordinate of the fourth point.\n   * @param {Integer} [detailX]\n   * @param {Integer} [detailY]\n   * @chainable\n   */\n  fn.quad = function(...args) {\n    // p5._validateParameters('quad', args);\n\n    if (this._renderer.states.strokeColor || this._renderer.states.fillColor) {\n      if (this._renderer.isP3D && args.length < 12) {\n        // if 3D and we weren't passed 12 args, assume Z is 0\n        this._renderer.quad.call(\n          this._renderer,\n          args[0], args[1], 0,\n          args[2], args[3], 0,\n          args[4], args[5], 0,\n          args[6], args[7], 0,\n          args[8], args[9]);\n      } else {\n        this._renderer.quad(...args);\n        //accessibile outputs\n        if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {\n          this._accsOutput('quadrilateral', args);\n        }\n      }\n    }\n\n    return this;\n  };\n\n  /**\n   * Draws a rectangle.\n   *\n   * A rectangle is a four-sided shape defined by the `x`, `y`, `w`, and `h`\n   * parameters. `x` and `y` set the location of its top-left corner. `w` sets\n   * its width and `h` sets its height. Every angle in the rectangle measures\n   * 90Ëš. See <a href=\"#/p5/rectMode\">rectMode()</a> for other ways to define\n   * rectangles.\n   *\n   * The version of `rect()` with five parameters creates a rounded rectangle. The\n   * fifth parameter sets the radius for all four corners.\n   *\n   * The version of `rect()` with eight parameters also creates a rounded\n   * rectangle. Each of the last four parameters set the radius of a corner. The\n   * radii start with the top-left corner and move clockwise around the\n   * rectangle. If any of these parameters are omitted, they are set to the\n   * value of the last radius that was set.\n   *\n   * @method rect\n   * @param  {Number} x  x-coordinate of the rectangle.\n   * @param  {Number} y  y-coordinate of the rectangle.\n   * @param  {Number} w  width of the rectangle.\n   * @param  {Number} [h]  height of the rectangle.\n   * @param  {Number} [tl] optional radius of top-left corner.\n   * @param  {Number} [tr] optional radius of top-right corner.\n   * @param  {Number} [br] optional radius of bottom-right corner.\n   * @param  {Number} [bl] optional radius of bottom-left corner.\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   rect(30, 20, 55, 55);\n   *\n   *   describe('A white square with a black outline on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   rect(30, 20, 55, 40);\n   *\n   *   describe('A white rectangle with a black outline on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Give all corners a radius of 20.\n   *   rect(30, 20, 55, 50, 20);\n   *\n   *   describe('A white rectangle with a black outline and round edges on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Give each corner a unique radius.\n   *   rect(30, 20, 55, 50, 20, 15, 10, 5);\n   *\n   *   describe('A white rectangle with a black outline and round edges of different radii.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   rect(-20, -30, 55, 55);\n   *\n   *   describe('A white square with a black outline on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A white square spins around on gray canvas.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Rotate around the y-axis.\n   *   rotateY(frameCount * 0.01);\n   *\n   *   // Draw the rectangle.\n   *   rect(-20, -30, 55, 55);\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * @method rect\n   * @param  {Number} x\n   * @param  {Number} y\n   * @param  {Number} w\n   * @param  {Number} h\n   * @param  {Integer} [detailX] number of segments in the x-direction (for WebGL mode).\n   * @param  {Integer} [detailY] number of segments in the y-direction (for WebGL mode).\n   * @chainable\n   */\n  fn.rect = function(...args) {\n    // p5._validateParameters('rect', args);\n    return this._renderRect(...args);\n  };\n\n  /**\n   * Draws a square.\n   *\n   * A square is a four-sided shape defined by the `x`, `y`, and `s`\n   * parameters. `x` and `y` set the location of its top-left corner. `s` sets\n   * its width and height. Every angle in the square measures 90Ëš and all its\n   * sides are the same length. See <a href=\"#/p5/rectMode\">rectMode()</a> for\n   * other ways to define squares.\n   *\n   * The version of `square()` with four parameters creates a rounded square.\n   * The fourth parameter sets the radius for all four corners.\n   *\n   * The version of `square()` with seven parameters also creates a rounded\n   * square. Each of the last four parameters set the radius of a corner. The\n   * radii start with the top-left corner and move clockwise around the\n   * square. If any of these parameters are omitted, they are set to the\n   * value of the last radius that was set.\n   *\n   * @method square\n   * @param  {Number} x  x-coordinate of the square.\n   * @param  {Number} y  y-coordinate of the square.\n   * @param  {Number} s  side size of the square.\n   * @param  {Number} [tl] optional radius of top-left corner.\n   * @param  {Number} [tr] optional radius of top-right corner.\n   * @param  {Number} [br] optional radius of bottom-right corner.\n   * @param  {Number} [bl] optional radius of bottom-left corner.\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   square(30, 20, 55);\n   *\n   *   describe('A white square with a black outline in on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Give all corners a radius of 20.\n   *   square(30, 20, 55, 20);\n   *\n   *   describe(\n   *     'A white square with a black outline and round edges on a gray canvas.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Give each corner a unique radius.\n   *   square(30, 20, 55, 20, 15, 10, 5);\n   *\n   *   describe('A white square with a black outline and round edges of different radii.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   square(-20, -30, 55);\n   *\n   *   describe('A white square with a black outline in on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A white square spins around on gray canvas.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Rotate around the y-axis.\n   *   rotateY(frameCount * 0.01);\n   *\n   *   // Draw the square.\n   *   square(-20, -30, 55);\n   * }\n   * </code>\n   * </div>\n   */\n  fn.square = function(x, y, s, tl, tr, br, bl) {\n    // p5._validateParameters('square', arguments);\n    // duplicate width for height in case of square\n    return this._renderRect.call(this, x, y, s, s, tl, tr, br, bl);\n  };\n\n  // internal method to have renderer draw a rectangle\n  fn._renderRect = function() {\n    if (this._renderer.states.strokeColor || this._renderer.states.fillColor) {\n      // duplicate width for height in case only 3 arguments is provided\n      if (arguments.length === 3) {\n        arguments[3] = arguments[2];\n      }\n      const vals = canvas.modeAdjust(\n        arguments[0],\n        arguments[1],\n        arguments[2],\n        arguments[3],\n        this._renderer.states.rectMode\n      );\n\n      // For the default rectMode (CORNER), restore a possible negative width/height\n      // removed by modeAdjust(). This results in flipped/mirrored rendering,\n      // which is especially noticable when using WEGBL rendering and texture().\n      // Note that this behavior only applies to rect(), NOT to ellipse() and arc().\n      if (this._renderer.states.rectMode === CORNER) {\n        vals.w = arguments[2];\n        vals.h = arguments[3];\n      }\n\n      const args = [vals.x, vals.y, vals.w, vals.h];\n      // append the additional arguments (either cornder radii, or\n      // segment details) to the argument list\n      for (let i = 4; i < arguments.length; i++) {\n        args[i] = arguments[i];\n      }\n      this._renderer.rect(args);\n\n      //accessible outputs\n      if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {\n        this._accsOutput('rectangle', [vals.x, vals.y, vals.w, vals.h]);\n      }\n    }\n\n    return this;\n  };\n\n  /**\n   * Draws a triangle.\n   *\n   * A triangle is a three-sided shape defined by three points. The\n   * first two parameters specify the triangle's first point `(x1, y1)`. The\n   * middle two parameters specify its second point `(x2, y2)`. And the last two\n   * parameters specify its third point `(x3, y3)`.\n   *\n   * @method triangle\n   * @param  {Number} x1 x-coordinate of the first point.\n   * @param  {Number} y1 y-coordinate of the first point.\n   * @param  {Number} x2 x-coordinate of the second point.\n   * @param  {Number} y2 y-coordinate of the second point.\n   * @param  {Number} x3 x-coordinate of the third point.\n   * @param  {Number} y3 y-coordinate of the third point.\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   triangle(30, 75, 58, 20, 86, 75);\n   *\n   *   describe('A white triangle with a black outline on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   triangle(-20, 25, 8, -30, 36, 25);\n   *\n   *   describe('A white triangle with a black outline on a gray canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A white triangle spins around on a gray canvas.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Rotate around the y-axis.\n   *   rotateY(frameCount * 0.01);\n   *\n   *   // Draw the triangle.\n   *   triangle(-20, 25, 8, -30, 36, 25);\n   * }\n   * </code>\n   * </div>\n   */\n  fn.triangle = function(...args) {\n    // p5._validateParameters('triangle', args);\n\n    if (this._renderer.states.strokeColor || this._renderer.states.fillColor) {\n      this._renderer.triangle(args);\n    }\n\n    //accessible outputs\n    if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {\n      this._accsOutput('triangle', args);\n    }\n\n    return this;\n  };\n}\n\nif(typeof p5 !== 'undefined'){\n  primitives(p5, p5.prototype);\n}\n\nexport { primitives as default };\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3679, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Users/Ryan%20Purnomo/Bahasa-Pemrograman/Website/Javascript/NextJS/CG-GAMES/node_modules/p5/dist/shape/attributes.js"],"sourcesContent":["import { e as CORNER, i as CORNERS, a as RADIUS, C as CENTER, j as ROUND, S as SQUARE, k as PROJECT, B as BEVEL, l as MITER } from '../constants-C-g_eAdC.js';\n\n/**\n * @module Shape\n * @submodule Attributes\n * @for p5\n * @requires core\n * @requires constants\n */\n\n\nfunction attributes(p5, fn){\n  /**\n   * Changes where ellipses, circles, and arcs are drawn.\n   *\n   * By default, the first two parameters of\n   * <a href=\"#/p5/ellipse\">ellipse()</a>, <a href=\"#/p5/circle\">circle()</a>,\n   * and <a href=\"#/p5/arc\">arc()</a>\n   * are the x- and y-coordinates of the shape's center. The next parameters set\n   * the shape's width and height. This is the same as calling\n   * `ellipseMode(CENTER)`.\n   *\n   * `ellipseMode(RADIUS)` also uses the first two parameters to set the x- and\n   * y-coordinates of the shape's center. The next parameters are half of the\n   * shapes's width and height. Calling `ellipse(0, 0, 10, 15)` draws a shape\n   * with a width of 20 and height of 30.\n   *\n   * `ellipseMode(CORNER)` uses the first two parameters as the upper-left\n   * corner of the shape. The next parameters are its width and height.\n   *\n   * `ellipseMode(CORNERS)` uses the first two parameters as the location of one\n   * corner of the ellipse's bounding box. The next parameters are the location\n   * of the opposite corner.\n   *\n   * The argument passed to `ellipseMode()` must be written in ALL CAPS because\n   * the constants `CENTER`, `RADIUS`, `CORNER`, and `CORNERS` are defined this\n   * way. JavaScript is a case-sensitive language.\n   *\n   * @method ellipseMode\n   * @param  {(CENTER|RADIUS|CORNER|CORNERS)} mode either CENTER, RADIUS, CORNER, or CORNERS\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // White ellipse.\n   *   ellipseMode(RADIUS);\n   *   fill(255);\n   *   ellipse(50, 50, 30, 30);\n   *\n   *   // Gray ellipse.\n   *   ellipseMode(CENTER);\n   *   fill(100);\n   *   ellipse(50, 50, 30, 30);\n   *\n   *   describe('A white circle with a gray circle at its center. Both circles have black outlines.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // White ellipse.\n   *   ellipseMode(CORNER);\n   *   fill(255);\n   *   ellipse(25, 25, 50, 50);\n   *\n   *   // Gray ellipse.\n   *   ellipseMode(CORNERS);\n   *   fill(100);\n   *   ellipse(25, 25, 50, 50);\n   *\n   *   describe('A white circle with a gray circle at its top-left corner. Both circles have black outlines.');\n   * }\n   * </code>\n   * </div>\n   */\n  fn.ellipseMode = function(m) {\n    // p5._validateParameters('ellipseMode', arguments);\n    if (\n      m === CORNER ||\n      m === CORNERS ||\n      m === RADIUS ||\n      m === CENTER\n    ) {\n      this._renderer.states.setValue('ellipseMode', m);\n    }\n    return this;\n  };\n\n  /**\n   * Draws certain features with jagged (aliased) edges.\n   *\n   * <a href=\"#/p5/smooth\">smooth()</a> is active by default. In 2D mode,\n   * `noSmooth()` is helpful for scaling up images without blurring. The\n   * functions don't affect shapes or fonts.\n   *\n   * In WebGL mode, `noSmooth()` causes all shapes to be drawn with jagged\n   * (aliased) edges. The functions don't affect images or fonts.\n   *\n   * @method noSmooth\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * let heart;\n   *\n   * async function setup() {\n   *   // Load a pixelated heart image from an image data string.\n   *   heart = await loadImage('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAYAAADEUlfTAAAAAXNSR0IArs4c6QAAAEZJREFUGFd9jcsNACAIQ9tB2MeR3YdBMBBq8CIXPi2vBICIiOwkOedatllqWO6Y8yOWoyuNf1GZwgmf+RRG2YXr+xVFmA8HZ9Mx/KGPMtcAAAAASUVORK5CYII=');\n   *   createCanvas(100, 100);\n   *\n   *   background(50);\n   *\n   *   // Antialiased hearts.\n   *   image(heart, 10, 10);\n   *   image(heart, 20, 10, 16, 16);\n   *   image(heart, 40, 10, 32, 32);\n   *\n   *   // Aliased hearts.\n   *   noSmooth();\n   *   image(heart, 10, 60);\n   *   image(heart, 20, 60, 16, 16);\n   *   image(heart, 40, 60, 32, 32);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   circle(0, 0, 80);\n   *\n   *   describe('A white circle on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Disable smoothing.\n   *   noSmooth();\n   *\n   *   background(200);\n   *\n   *   circle(0, 0, 80);\n   *\n   *   describe('A pixelated white circle on a gray background.');\n   * }\n   * </code>\n   * </div>\n   */\n  fn.noSmooth = function() {\n    if (!this._renderer.isP3D) {\n      if ('imageSmoothingEnabled' in this.drawingContext) {\n        this.drawingContext.imageSmoothingEnabled = false;\n      }\n    } else {\n      this.setAttributes('antialias', false);\n    }\n    return this;\n  };\n\n  /**\n   * Changes where rectangles and squares are drawn.\n   *\n   * By default, the first two parameters of\n   * <a href=\"#/p5/rect\">rect()</a> and <a href=\"#/p5/square\">square()</a>,\n   * are the x- and y-coordinates of the shape's upper left corner. The next parameters set\n   * the shape's width and height. This is the same as calling\n   * `rectMode(CORNER)`.\n   *\n   * `rectMode(CORNERS)` also uses the first two parameters as the location of\n   * one of the corners. The next parameters are the location of the opposite\n   * corner. This mode only works for <a href=\"#/p5/rect\">rect()</a>.\n   *\n   * `rectMode(CENTER)` uses the first two parameters as the x- and\n   * y-coordinates of the shape's center. The next parameters are its width and\n   * height.\n   *\n   * `rectMode(RADIUS)` also uses the first two parameters as the x- and\n   * y-coordinates of the shape's center. The next parameters are\n   * half of the shape's width and height.\n   *\n   * The argument passed to `rectMode()` must be written in ALL CAPS because the\n   * constants `CENTER`, `RADIUS`, `CORNER`, and `CORNERS` are defined this way.\n   * JavaScript is a case-sensitive language.\n   *\n   * @method rectMode\n   * @param  {(CENTER|RADIUS|CORNER|CORNERS)} mode either CORNER, CORNERS, CENTER, or RADIUS\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   rectMode(CORNER);\n   *   fill(255);\n   *   rect(25, 25, 50, 50);\n   *\n   *   rectMode(CORNERS);\n   *   fill(100);\n   *   rect(25, 25, 50, 50);\n   *\n   *   describe('A small gray square drawn at the top-left corner of a white square.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   rectMode(RADIUS);\n   *   fill(255);\n   *   rect(50, 50, 30, 30);\n   *\n   *   rectMode(CENTER);\n   *   fill(100);\n   *   rect(50, 50, 30, 30);\n   *\n   *   describe('A small gray square drawn at the center of a white square.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   rectMode(CORNER);\n   *   fill(255);\n   *   square(25, 25, 50);\n   *\n   *   describe('A white square.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   rectMode(RADIUS);\n   *   fill(255);\n   *   square(50, 50, 30);\n   *\n   *   rectMode(CENTER);\n   *   fill(100);\n   *   square(50, 50, 30);\n   *\n   *   describe('A small gray square drawn at the center of a white square.');\n   * }\n   * </code>\n   * </div>\n   */\n  fn.rectMode = function(m) {\n    // p5._validateParameters('rectMode', arguments);\n    if (\n      m === CORNER ||\n      m === CORNERS ||\n      m === RADIUS ||\n      m === CENTER\n    ) {\n      this._renderer.states.setValue('rectMode', m);\n    }\n    return this; // return current rectMode ?\n  };\n\n  /**\n   * Draws certain features with smooth (antialiased) edges.\n   *\n   * `smooth()` is active by default. In 2D mode,\n   * <a href=\"#/p5/noSmooth\">noSmooth()</a> is helpful for scaling up images\n   * without blurring. The functions don't affect shapes or fonts.\n   *\n   * In WebGL mode, <a href=\"#/p5/noSmooth\">noSmooth()</a> causes all shapes to\n   * be drawn with jagged (aliased) edges. The functions don't affect images or\n   * fonts.\n   *\n   * @method smooth\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * let heart;\n   *\n   * async function setup() {\n   *   // Load a pixelated heart image from an image data string.\n   *   heart = await loadImage('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAYAAADEUlfTAAAAAXNSR0IArs4c6QAAAEZJREFUGFd9jcsNACAIQ9tB2MeR3YdBMBBq8CIXPi2vBICIiOwkOedatllqWO6Y8yOWoyuNf1GZwgmf+RRG2YXr+xVFmA8HZ9Mx/KGPMtcAAAAASUVORK5CYII=');\n   *\n   *   createCanvas(100, 100);\n   *\n   *   background(50);\n   *\n   *   // Antialiased hearts.\n   *   image(heart, 10, 10);\n   *   image(heart, 20, 10, 16, 16);\n   *   image(heart, 40, 10, 32, 32);\n   *\n   *   // Aliased hearts.\n   *   noSmooth();\n   *   image(heart, 10, 60);\n   *   image(heart, 20, 60, 16, 16);\n   *   image(heart, 40, 60, 32, 32);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   circle(0, 0, 80);\n   *\n   *   describe('A white circle on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Disable smoothing.\n   *   noSmooth();\n   *\n   *   background(200);\n   *\n   *   circle(0, 0, 80);\n   *\n   *   describe('A pixelated white circle on a gray background.');\n   * }\n   * </code>\n   * </div>\n   */\n  fn.smooth = function() {\n    if (!this._renderer.isP3D) {\n      if ('imageSmoothingEnabled' in this.drawingContext) {\n        this.drawingContext.imageSmoothingEnabled = true;\n      }\n    } else {\n      this.setAttributes('antialias', true);\n    }\n    return this;\n  };\n\n  /**\n   * Sets the style for rendering the ends of lines.\n   *\n   * The caps for line endings are either rounded (`ROUND`), squared\n   * (`SQUARE`), or extended (`PROJECT`). The default cap is `ROUND`.\n   *\n   * The argument passed to `strokeCap()` must be written in ALL CAPS because\n   * the constants `ROUND`, `SQUARE`, and `PROJECT` are defined this way.\n   * JavaScript is a case-sensitive language.\n   *\n   * @method strokeCap\n   * @param  {(ROUND|SQUARE|PROJECT)} cap either ROUND, SQUARE, or PROJECT\n   * @chainable\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   strokeWeight(12);\n   *\n   *   // Top.\n   *   strokeCap(ROUND);\n   *   line(20, 30, 80, 30);\n   *\n   *   // Middle.\n   *   strokeCap(SQUARE);\n   *   line(20, 50, 80, 50);\n   *\n   *   // Bottom.\n   *   strokeCap(PROJECT);\n   *   line(20, 70, 80, 70);\n   *\n   *   describe(\n   *     'Three horizontal lines. The top line has rounded ends, the middle line has squared ends, and the bottom line has longer, squared ends.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   */\n  fn.strokeCap = function(cap) {\n    // p5._validateParameters('strokeCap', arguments);\n    if (\n      cap === ROUND ||\n      cap === SQUARE ||\n      cap === PROJECT\n    ) {\n      this._renderer.strokeCap(cap);\n    }\n    return this;\n  };\n\n  /**\n   * Sets the style of the joints that connect line segments.\n   *\n   * Joints are either mitered (`MITER`), beveled (`BEVEL`), or rounded\n   * (`ROUND`). The default joint is `MITER` in 2D mode and `ROUND` in WebGL\n   * mode.\n   *\n   * The argument passed to `strokeJoin()` must be written in ALL CAPS because\n   * the constants `MITER`, `BEVEL`, and `ROUND` are defined this way.\n   * JavaScript is a case-sensitive language.\n   *\n   * @method strokeJoin\n   * @param  {(MITER|BEVEL|ROUND)} join either MITER, BEVEL, or ROUND\n   * @chainable\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Style the line.\n   *   noFill();\n   *   strokeWeight(10);\n   *   strokeJoin(MITER);\n   *\n   *   // Draw the line.\n   *   beginShape();\n   *   vertex(35, 20);\n   *   vertex(65, 50);\n   *   vertex(35, 80);\n   *   endShape();\n   *\n   *   describe('A right-facing arrowhead shape with a pointed tip in center of canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Style the line.\n   *   noFill();\n   *   strokeWeight(10);\n   *   strokeJoin(BEVEL);\n   *\n   *   // Draw the line.\n   *   beginShape();\n   *   vertex(35, 20);\n   *   vertex(65, 50);\n   *   vertex(35, 80);\n   *   endShape();\n   *\n   *   describe('A right-facing arrowhead shape with a flat tip in center of canvas.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Style the line.\n   *   noFill();\n   *   strokeWeight(10);\n   *   strokeJoin(ROUND);\n   *\n   *   // Draw the line.\n   *   beginShape();\n   *   vertex(35, 20);\n   *   vertex(65, 50);\n   *   vertex(35, 80);\n   *   endShape();\n   *\n   *   describe('A right-facing arrowhead shape with a rounded tip in center of canvas.');\n   * }\n   * </code>\n   * </div>\n   */\n  fn.strokeJoin = function(join) {\n    // p5._validateParameters('strokeJoin', arguments);\n    if (\n      join === ROUND ||\n      join === BEVEL ||\n      join === MITER\n    ) {\n      this._renderer.strokeJoin(join);\n    }\n    return this;\n  };\n\n  /**\n   * Sets the width of the stroke used for points, lines, and the outlines of\n   * shapes.\n   *\n   * Note: `strokeWeight()` is affected by transformations, especially calls to\n   * <a href=\"#/p5/scale\">scale()</a>.\n   *\n   * @method strokeWeight\n   * @param  {Number} weight the weight of the stroke (in pixels).\n   * @chainable\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Top.\n   *   line(20, 20, 80, 20);\n   *\n   *   // Middle.\n   *   strokeWeight(4);\n   *   line(20, 40, 80, 40);\n   *\n   *   // Bottom.\n   *   strokeWeight(10);\n   *   line(20, 70, 80, 70);\n   *\n   *   describe('Three horizontal black lines. The top line is thin, the middle is medium, and the bottom is thick.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Top.\n   *   line(20, 20, 80, 20);\n   *\n   *   // Scale by a factor of 5.\n   *   scale(5);\n   *\n   *   // Bottom. Coordinates are adjusted for scaling.\n   *   line(4, 8, 16, 8);\n   *\n   *   describe('Two horizontal black lines. The top line is thin and the bottom is five times thicker than the top.');\n   * }\n   * </code>\n   * </div>\n   */\n  fn.strokeWeight = function(w) {\n    // p5._validateParameters('strokeWeight', arguments);\n    this._renderer.strokeWeight(w);\n    return this;\n  };\n}\n\nif(typeof p5 !== 'undefined'){\n  attributes(p5, p5.prototype);\n}\n\nexport { attributes as default };\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4255, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Users/Ryan%20Purnomo/Bahasa-Pemrograman/Website/Javascript/NextJS/CG-GAMES/node_modules/p5/dist/shape/curves.js"],"sourcesContent":["/**\n * @module Shape\n * @submodule Curves\n * @for p5\n * @requires core\n */\n\nfunction curves(p5, fn){\n  /**\n   * Draws a BÃ©zier curve.\n   *\n   * BÃ©zier curves can form shapes and curves that slope gently. They're defined\n   * by two anchor points and two control points. BÃ©zier curves provide more\n   * control than the spline curves created with the\n   * <a href=\"#/p5/curve\">curve()</a> function.\n   *\n   * The first two parameters, `x1` and `y1`, set the first anchor point. The\n   * first anchor point is where the curve starts.\n   *\n   * The next four parameters, `x2`, `y2`, `x3`, and `y3`, set the two control\n   * points. The control points \"pull\" the curve towards them.\n   *\n   * The seventh and eighth parameters, `x4` and `y4`, set the last anchor\n   * point. The last anchor point is where the curve ends.\n   *\n   * BÃ©zier curves can also be drawn in 3D using WebGL mode. The 3D version of\n   * `bezier()` has twelve arguments because each point has x-, y-,\n   * and z-coordinates.\n   *\n   * @method bezier\n   * @param  {Number} x1 x-coordinate of the first anchor point.\n   * @param  {Number} y1 y-coordinate of the first anchor point.\n   * @param  {Number} x2 x-coordinate of the first control point.\n   * @param  {Number} y2 y-coordinate of the first control point.\n   * @param  {Number} x3 x-coordinate of the second control point.\n   * @param  {Number} y3 y-coordinate of the second control point.\n   * @param  {Number} x4 x-coordinate of the second anchor point.\n   * @param  {Number} y4 y-coordinate of the second anchor point.\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Draw the anchor points in black.\n   *   stroke(0);\n   *   strokeWeight(5);\n   *   point(85, 20);\n   *   point(15, 80);\n   *\n   *   // Draw the control points in red.\n   *   stroke(255, 0, 0);\n   *   point(10, 10);\n   *   point(90, 90);\n   *\n   *   // Draw a black bezier curve.\n   *   noFill();\n   *   stroke(0);\n   *   strokeWeight(1);\n   *   bezier(85, 20, 10, 10, 90, 90, 15, 80);\n   *\n   *   // Draw red lines from the anchor points to the control points.\n   *   stroke(255, 0, 0);\n   *   line(85, 20, 10, 10);\n   *   line(15, 80, 90, 90);\n   *\n   *   describe(\n   *     'A gray square with three curves. A black s-curve has two straight, red lines that extend from its ends. The endpoints of all the curves are marked with dots.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click the mouse near the red dot in the top-left corner\n   * // and drag to change the curve's shape.\n   *\n   * let x2 = 10;\n   * let y2 = 10;\n   * let isChanging = false;\n   *\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   describe(\n   *     'A gray square with three curves. A black s-curve has two straight, red lines that extend from its ends. The endpoints of all the curves are marked with dots.'\n   *   );\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Draw the anchor points in black.\n   *   stroke(0);\n   *   strokeWeight(5);\n   *   point(85, 20);\n   *   point(15, 80);\n   *\n   *   // Draw the control points in red.\n   *   stroke(255, 0, 0);\n   *   point(x2, y2);\n   *   point(90, 90);\n   *\n   *   // Draw a black bezier curve.\n   *   noFill();\n   *   stroke(0);\n   *   strokeWeight(1);\n   *   bezier(85, 20, x2, y2, 90, 90, 15, 80);\n   *\n   *   // Draw red lines from the anchor points to the control points.\n   *   stroke(255, 0, 0);\n   *   line(85, 20, x2, y2);\n   *   line(15, 80, 90, 90);\n   * }\n   *\n   * // Start changing the first control point if the user clicks near it.\n   * function mousePressed() {\n   *   if (dist(mouseX, mouseY, x2, y2) < 20) {\n   *     isChanging = true;\n   *   }\n   * }\n   *\n   * // Stop changing the first control point when the user releases the mouse.\n   * function mouseReleased() {\n   *   isChanging = false;\n   * }\n   *\n   * // Update the first control point while the user drags the mouse.\n   * function mouseDragged() {\n   *   if (isChanging === true) {\n   *     x2 = mouseX;\n   *     y2 = mouseY;\n   *   }\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background('skyblue');\n   *\n   *   // Draw the red balloon.\n   *   fill('red');\n   *   bezier(50, 60, 5, 15, 95, 15, 50, 60);\n   *\n   *   // Draw the balloon string.\n   *   line(50, 60, 50, 80);\n   *\n   *   describe('A red balloon in a blue sky.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A red balloon in a blue sky. The balloon rotates slowly, revealing that it is flat.');\n   * }\n   *\n   * function draw() {\n   *   background('skyblue');\n   *\n   *   // Rotate around the y-axis.\n   *   rotateY(frameCount * 0.01);\n   *\n   *   // Draw the red balloon.\n   *   fill('red');\n   *   bezier(0, 0, 0, -45, -45, 0, 45, -45, 0, 0, 0, 0);\n   *\n   *   // Draw the balloon string.\n   *   line(0, 0, 0, 0, 20, 0);\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * @method bezier\n   * @param  {Number} x1\n   * @param  {Number} y1\n   * @param  {Number} z1 z-coordinate of the first anchor point.\n   * @param  {Number} x2\n   * @param  {Number} y2\n   * @param  {Number} z2 z-coordinate of the first control point.\n   * @param  {Number} x3\n   * @param  {Number} y3\n   * @param  {Number} z3 z-coordinate of the second control point.\n   * @param  {Number} x4\n   * @param  {Number} y4\n   * @param  {Number} z4 z-coordinate of the second anchor point.\n   * @chainable\n   */\n  fn.bezier = function(...args) {\n    // p5._validateParameters('bezier', args);\n\n    // if the current stroke and fill settings wouldn't result in something\n    // visible, exit immediately\n    if (!this._renderer.states.strokeColor && !this._renderer.states.fillColor) {\n      return this;\n    }\n\n    this._renderer.bezier(...args);\n\n    return this;\n  };\n\n  /**\n   * Calculates coordinates along a BÃ©zier curve using interpolation.\n   *\n   * `bezierPoint()` calculates coordinates along a BÃ©zier curve using the\n   * anchor and control points. It expects points in the same order as the\n   * <a href=\"#/p5/bezier\">bezier()</a> function. `bezierPoint()` works one axis\n   * at a time. Passing the anchor and control points' x-coordinates will\n   * calculate the x-coordinate of a point on the curve. Passing the anchor and\n   * control points' y-coordinates will calculate the y-coordinate of a point on\n   * the curve.\n   *\n   * The first parameter, `a`, is the coordinate of the first anchor point.\n   *\n   * The second and third parameters, `b` and `c`, are the coordinates of the\n   * control points.\n   *\n   * The fourth parameter, `d`, is the coordinate of the last anchor point.\n   *\n   * The fifth parameter, `t`, is the amount to interpolate along the curve. 0\n   * is the first anchor point, 1 is the second anchor point, and 0.5 is halfway\n   * between them.\n   *\n   * @method bezierPoint\n   * @param {Number} a coordinate of first control point.\n   * @param {Number} b coordinate of first anchor point.\n   * @param {Number} c coordinate of second anchor point.\n   * @param {Number} d coordinate of second control point.\n   * @param {Number} t amount to interpolate between 0 and 1.\n   * @return {Number} coordinate of the point on the curve.\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Set the coordinates for the curve's anchor and control points.\n   *   let x1 = 85;\n   *   let x2 = 10;\n   *   let x3 = 90;\n   *   let x4 = 15;\n   *   let y1 = 20;\n   *   let y2 = 10;\n   *   let y3 = 90;\n   *   let y4 = 80;\n   *\n   *   // Style the curve.\n   *   noFill();\n   *\n   *   // Draw the curve.\n   *   bezier(x1, y1, x2, y2, x3, y3, x4, y4);\n   *\n   *   // Draw circles along the curve's path.\n   *   fill(255);\n   *\n   *   // Top-right.\n   *   let x = bezierPoint(x1, x2, x3, x4, 0);\n   *   let y = bezierPoint(y1, y2, y3, y4, 0);\n   *   circle(x, y, 5);\n   *\n   *   // Center.\n   *   x = bezierPoint(x1, x2, x3, x4, 0.5);\n   *   y = bezierPoint(y1, y2, y3, y4, 0.5);\n   *   circle(x, y, 5);\n   *\n   *   // Bottom-left.\n   *   x = bezierPoint(x1, x2, x3, x4, 1);\n   *   y = bezierPoint(y1, y2, y3, y4, 1);\n   *   circle(x, y, 5);\n   *\n   *   describe('A black s-curve on a gray square. The endpoints and center of the curve are marked with white circles.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   describe('A black s-curve on a gray square. A white circle moves back and forth along the curve.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Set the coordinates for the curve's anchor and control points.\n   *   let x1 = 85;\n   *   let x2 = 10;\n   *   let x3 = 90;\n   *   let x4 = 15;\n   *   let y1 = 20;\n   *   let y2 = 10;\n   *   let y3 = 90;\n   *   let y4 = 80;\n   *\n   *   // Draw the curve.\n   *   noFill();\n   *   bezier(x1, y1, x2, y2, x3, y3, x4, y4);\n   *\n   *   // Calculate the circle's coordinates.\n   *   let t = 0.5 * sin(frameCount * 0.01) + 0.5;\n   *   let x = bezierPoint(x1, x2, x3, x4, t);\n   *   let y = bezierPoint(y1, y2, y3, y4, t);\n   *\n   *   // Draw the circle.\n   *   fill(255);\n   *   circle(x, y, 5);\n   * }\n   * </code>\n   * </div>\n   */\n  fn.bezierPoint = function(a, b, c, d, t) {\n    // p5._validateParameters('bezierPoint', arguments);\n\n    const adjustedT = 1 - t;\n    return (\n      Math.pow(adjustedT, 3) * a +\n      3 * Math.pow(adjustedT, 2) * t * b +\n      3 * adjustedT * Math.pow(t, 2) * c +\n      Math.pow(t, 3) * d\n    );\n  };\n\n  /**\n   * Calculates coordinates along a line that's tangent to a BÃ©zier curve.\n   *\n   * Tangent lines skim the surface of a curve. A tangent line's slope equals\n   * the curve's slope at the point where it intersects.\n   *\n   * `bezierTangent()` calculates coordinates along a tangent line using the\n   * BÃ©zier curve's anchor and control points. It expects points in the same\n   * order as the <a href=\"#/p5/bezier\">bezier()</a> function. `bezierTangent()`\n   * works one axis at a time. Passing the anchor and control points'\n   * x-coordinates will calculate the x-coordinate of a point on the tangent\n   * line. Passing the anchor and control points' y-coordinates will calculate\n   * the y-coordinate of a point on the tangent line.\n   *\n   * The first parameter, `a`, is the coordinate of the first anchor point.\n   *\n   * The second and third parameters, `b` and `c`, are the coordinates of the\n   * control points.\n   *\n   * The fourth parameter, `d`, is the coordinate of the last anchor point.\n   *\n   * The fifth parameter, `t`, is the amount to interpolate along the curve. 0\n   * is the first anchor point, 1 is the second anchor point, and 0.5 is halfway\n   * between them.\n   *\n   * @method bezierTangent\n   * @param {Number} a coordinate of first anchor point.\n   * @param {Number} b coordinate of first control point.\n   * @param {Number} c coordinate of second control point.\n   * @param {Number} d coordinate of second anchor point.\n   * @param {Number} t amount to interpolate between 0 and 1.\n   * @return {Number} coordinate of a point on the tangent line.\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Set the coordinates for the curve's anchor and control points.\n   *   let x1 = 85;\n   *   let x2 = 10;\n   *   let x3 = 90;\n   *   let x4 = 15;\n   *   let y1 = 20;\n   *   let y2 = 10;\n   *   let y3 = 90;\n   *   let y4 = 80;\n   *\n   *   // Style the curve.\n   *   noFill();\n   *\n   *   // Draw the curve.\n   *   bezier(x1, y1, x2, y2, x3, y3, x4, y4);\n   *\n   *   // Draw tangents along the curve's path.\n   *   fill(255);\n   *\n   *   // Top-right circle.\n   *   stroke(0);\n   *   let x = bezierPoint(x1, x2, x3, x4, 0);\n   *   let y = bezierPoint(y1, y2, y3, y4, 0);\n   *   circle(x, y, 5);\n   *\n   *   // Top-right tangent line.\n   *   // Scale the tangent point to draw a shorter line.\n   *   stroke(255, 0, 0);\n   *   let tx = 0.1 * bezierTangent(x1, x2, x3, x4, 0);\n   *   let ty = 0.1 * bezierTangent(y1, y2, y3, y4, 0);\n   *   line(x + tx, y + ty, x - tx, y - ty);\n   *\n   *   // Center circle.\n   *   stroke(0);\n   *   x = bezierPoint(x1, x2, x3, x4, 0.5);\n   *   y = bezierPoint(y1, y2, y3, y4, 0.5);\n   *   circle(x, y, 5);\n   *\n   *   // Center tangent line.\n   *   // Scale the tangent point to draw a shorter line.\n   *   stroke(255, 0, 0);\n   *   tx = 0.1 * bezierTangent(x1, x2, x3, x4, 0.5);\n   *   ty = 0.1 * bezierTangent(y1, y2, y3, y4, 0.5);\n   *   line(x + tx, y + ty, x - tx, y - ty);\n   *\n   *   // Bottom-left circle.\n   *   stroke(0);\n   *   x = bezierPoint(x1, x2, x3, x4, 1);\n   *   y = bezierPoint(y1, y2, y3, y4, 1);\n   *   circle(x, y, 5);\n   *\n   *   // Bottom-left tangent.\n   *   // Scale the tangent point to draw a shorter line.\n   *   stroke(255, 0, 0);\n   *   tx = 0.1 * bezierTangent(x1, x2, x3, x4, 1);\n   *   ty = 0.1 * bezierTangent(y1, y2, y3, y4, 1);\n   *   line(x + tx, y + ty, x - tx, y - ty);\n   *\n   *   describe(\n   *     'A black s-curve on a gray square. The endpoints and center of the curve are marked with white circles. Red tangent lines extend from the white circles.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   */\n  fn.bezierTangent = function(a, b, c, d, t) {\n    // p5._validateParameters('bezierTangent', arguments);\n\n    const adjustedT = 1 - t;\n    return (\n      3 * d * Math.pow(t, 2) -\n      3 * c * Math.pow(t, 2) +\n      6 * c * adjustedT * t -\n      6 * b * adjustedT * t +\n      3 * b * Math.pow(adjustedT, 2) -\n      3 * a * Math.pow(adjustedT, 2)\n    );\n  };\n\n  /**\n   * Draws a curve using a Catmull-Rom spline.\n   *\n   * Spline curves can form shapes and curves that slope gently. Theyâ€™re like\n   * cables that are attached to a set of points. Splines are defined by two\n   * anchor points and two control points.\n   *\n   * The first two parameters, `x1` and `y1`, set the first control point. This\n   * point isnâ€™t drawn and can be thought of as the curveâ€™s starting point.\n   *\n   * The next four parameters, `x2`, `y2`, `x3`, and `y3`, set the two anchor\n   * points. The anchor points are the start and end points of the curveâ€™s\n   * visible segment.\n   *\n   * The seventh and eighth parameters, `x4` and `y4`, set the last control\n   * point. This point isnâ€™t drawn and can be thought of as the curveâ€™s ending\n   * point.\n   *\n   * Spline curves can also be drawn in 3D using WebGL mode. The 3D version of\n   * `spline()` has twelve arguments because each point has x-, y-, and\n   * z-coordinates.\n   *\n   * @method spline\n   * @param  {Number} x1 x-coordinate of the first control point.\n   * @param  {Number} y1 y-coordinate of the first control point.\n   * @param  {Number} x2 x-coordinate of the first anchor point.\n   * @param  {Number} y2 y-coordinate of the first anchor point.\n   * @param  {Number} x3 x-coordinate of the second anchor point.\n   * @param  {Number} y3 y-coordinate of the second anchor point.\n   * @param  {Number} x4 x-coordinate of the second control point.\n   * @param  {Number} y4 y-coordinate of the second control point.\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Draw a black spline curve.\n   *   noFill();\n   *   strokeWeight(1);\n   *   stroke(0);\n   *   spline(5, 26, 73, 24, 73, 61, 15, 65);\n   *\n   *   // Draw red spline curves from the anchor points to the control points.\n   *   stroke(255, 0, 0);\n   *   spline(5, 26, 5, 26, 73, 24, 73, 61);\n   *   spline(73, 24, 73, 61, 15, 65, 15, 65);\n   *\n   *   // Draw the anchor points in black.\n   *   strokeWeight(5);\n   *   stroke(0);\n   *   point(73, 24);\n   *   point(73, 61);\n   *\n   *   // Draw the control points in red.\n   *   stroke(255, 0, 0);\n   *   point(5, 26);\n   *   point(15, 65);\n   *\n   *   describe(\n   *     'A gray square with a curve drawn in three segments. The curve is a sideways U shape with red segments on top and bottom, and a black segment on the right. The endpoints of all the segments are marked with dots.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let x1 = 5;\n   * let y1 = 26;\n   * let isChanging = false;\n   *\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   describe(\n   *     'A gray square with a curve drawn in three segments. The curve is a sideways U shape with red segments on top and bottom, and a black segment on the right. The endpoints of all the segments are marked with dots.'\n   *   );\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Draw a black spline curve.\n   *   noFill();\n   *   strokeWeight(1);\n   *   stroke(0);\n   *   spline(x1, y1, 73, 24, 73, 61, 15, 65);\n   *\n   *   // Draw red spline curves from the anchor points to the control points.\n   *   stroke(255, 0, 0);\n   *   spline(x1, y1, x1, y1, 73, 24, 73, 61);\n   *   spline(73, 24, 73, 61, 15, 65, 15, 65);\n   *\n   *   // Draw the anchor points in black.\n   *   strokeWeight(5);\n   *   stroke(0);\n   *   point(73, 24);\n   *   point(73, 61);\n   *\n   *   // Draw the control points in red.\n   *   stroke(255, 0, 0);\n   *   point(x1, y1);\n   *   point(15, 65);\n   * }\n   *\n   * // Start changing the first control point if the user clicks near it.\n   * function mousePressed() {\n   *   if (dist(mouseX, mouseY, x1, y1) < 20) {\n   *     isChanging = true;\n   *   }\n   * }\n   *\n   * // Stop changing the first control point when the user releases the mouse.\n   * function mouseReleased() {\n   *   isChanging = false;\n   * }\n   *\n   * // Update the first control point while the user drags the mouse.\n   * function mouseDragged() {\n   *   if (isChanging === true) {\n   *     x1 = mouseX;\n   *     y1 = mouseY;\n   *   }\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background('skyblue');\n   *\n   *   // Draw the red balloon.\n   *   fill('red');\n   *   spline(-150, 275, 50, 60, 50, 60, 250, 275);\n   *\n   *   // Draw the balloon string.\n   *   line(50, 60, 50, 80);\n   *\n   *   describe('A red balloon in a blue sky.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A red balloon in a blue sky.');\n   * }\n   *\n   * function draw() {\n   *   background('skyblue');\n   *\n   *   // Rotate around the y-axis.\n   *   rotateY(frameCount * 0.01);\n   *\n   *   // Draw the red balloon.\n   *   fill('red');\n   *   spline(-200, 225, 0, 0, 10, 0, 0, 10, 0, 200, 225, 0);\n   *\n   *   // Draw the balloon string.\n   *   line(0, 10, 0, 0, 30, 0);\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * @method spline\n   * @param  {Number} x1\n   * @param  {Number} y1\n   * @param  {Number} z1 z-coordinate of the first control point.\n   * @param  {Number} x2\n   * @param  {Number} y2\n   * @param  {Number} z2 z-coordinate of the first anchor point.\n   * @param  {Number} x3\n   * @param  {Number} y3\n   * @param  {Number} z3 z-coordinate of the second anchor point.\n   * @param  {Number} x4\n   * @param  {Number} y4\n   * @param  {Number} z4 z-coordinate of the second control point.\n   * @chainable\n   */\n  fn.spline = function(...args) {\n    if (!this._renderer.states.strokeColor && !this._renderer.states.fillColor) {\n      return this;\n    }\n    this._renderer.spline(...args);\n\n    return this;\n  };\n\n  /**\n   * Calculates coordinates along a spline curve using interpolation.\n   *\n   * `splinePoint()` calculates coordinates along a spline curve using the\n   * anchor and control points. It expects points in the same order as the\n   * <a href=\"#/p5/spline\">spline()</a> function. `splinePoint()` works one axis\n   * at a time. Passing the anchor and control points' x-coordinates will\n   * calculate the x-coordinate of a point on the curve. Passing the anchor and\n   * control points' y-coordinates will calculate the y-coordinate of a point on\n   * the curve.\n   *\n   * The first parameter, `a`, is the coordinate of the first control point.\n   *\n   * The second and third parameters, `b` and `c`, are the coordinates of the\n   * anchor points.\n   *\n   * The fourth parameter, `d`, is the coordinate of the last control point.\n   *\n   * The fifth parameter, `t`, is the amount to interpolate along the curve. 0\n   * is the first anchor point, 1 is the second anchor point, and 0.5 is halfway\n   * between them.\n   *\n   * @method splinePoint\n   * @param {Number} a coordinate of first anchor point.\n   * @param {Number} b coordinate of first control point.\n   * @param {Number} c coordinate of second control point.\n   * @param {Number} d coordinate of second anchor point.\n   * @param {Number} t amount to interpolate between 0 and 1.\n   * @return {Number} coordinate of a point on the curve.\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Set the coordinates for the curve's anchor and control points.\n   *   let x1 = 5;\n   *   let y1 = 26;\n   *   let x2 = 73;\n   *   let y2 = 24;\n   *   let x3 = 73;\n   *   let y3 = 61;\n   *   let x4 = 15;\n   *   let y4 = 65;\n   *\n   *   // Draw the curve.\n   *   noFill();\n   *   spline(x1, y1, x2, y2, x3, y3, x4, y4);\n   *\n   *   // Draw circles along the curve's path.\n   *   fill(255);\n   *\n   *   // Top.\n   *   let x = splinePoint(x1, x2, x3, x4, 0);\n   *   let y = splinePoint(y1, y2, y3, y4, 0);\n   *   circle(x, y, 5);\n   *\n   *   // Center.\n   *   x = splinePoint(x1, x2, x3, x4, 0.5);\n   *   y = splinePoint(y1, y2, y3, y4, 0.5);\n   *   circle(x, y, 5);\n   *\n   *   // Bottom.\n   *   x = splinePoint(x1, x2, x3, x4, 1);\n   *   y = splinePoint(y1, y2, y3, y4, 1);\n   *   circle(x, y, 5);\n   *\n   *   describe('A black curve on a gray square. The endpoints and center of the curve are marked with white circles.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   describe('A black curve on a gray square. A white circle moves back and forth along the curve.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Set the coordinates for the curve's anchor and control points.\n   *   let x1 = 5;\n   *   let y1 = 26;\n   *   let x2 = 73;\n   *   let y2 = 24;\n   *   let x3 = 73;\n   *   let y3 = 61;\n   *   let x4 = 15;\n   *   let y4 = 65;\n   *\n   *   // Draw the curve.\n   *   noFill();\n   *   spline(x1, y1, x2, y2, x3, y3, x4, y4);\n   *\n   *   // Calculate the circle's coordinates.\n   *   let t = 0.5 * sin(frameCount * 0.01) + 0.5;\n   *   let x = splinePoint(x1, x2, x3, x4, t);\n   *   let y = splinePoint(y1, y2, y3, y4, t);\n   *\n   *   // Draw the circle.\n   *   fill(255);\n   *   circle(x, y, 5);\n   * }\n   * </code>\n   * </div>\n   */\n  fn.splinePoint = function(a, b, c, d, t) {\n    const s = this._renderer.states.splineProperties.tightness,\n      t3 = t * t * t,\n      t2 = t * t,\n      f1 = (s - 1) / 2 * t3 + (1 - s) * t2 + (s - 1) / 2 * t,\n      f2 = (s + 3) / 2 * t3 + (-5 - s) / 2 * t2 + 1.0,\n      f3 = (-3 - s) / 2 * t3 + (s + 2) * t2 + (1 - s) / 2 * t,\n      f4 = (1 - s) / 2 * t3 + (s - 1) / 2 * t2;\n    return a * f1 + b * f2 + c * f3 + d * f4;\n  };\n\n  /**\n   * Calculates coordinates along a line that's tangent to a spline curve.\n   *\n   * Tangent lines skim the surface of a curve. A tangent line's slope equals\n   * the curve's slope at the point where it intersects.\n   *\n   * `splineTangent()` calculates coordinates along a tangent line using the\n   * spline curve's anchor and control points. It expects points in the same\n   * order as the <a href=\"#/p5/spline\">spline()</a> function. `splineTangent()`\n   * works one axis at a time. Passing the anchor and control points'\n   * x-coordinates will calculate the x-coordinate of a point on the tangent\n   * line. Passing the anchor and control points' y-coordinates will calculate\n   * the y-coordinate of a point on the tangent line.\n   *\n   * The first parameter, `a`, is the coordinate of the first control point.\n   *\n   * The second and third parameters, `b` and `c`, are the coordinates of the\n   * anchor points.\n   *\n   * The fourth parameter, `d`, is the coordinate of the last control point.\n   *\n   * The fifth parameter, `t`, is the amount to interpolate along the curve. 0\n   * is the first anchor point, 1 is the second anchor point, and 0.5 is halfway\n   * between them.\n   *\n   * @method splineTangent\n   * @param {Number} a coordinate of first control point.\n   * @param {Number} b coordinate of first anchor point.\n   * @param {Number} c coordinate of second anchor point.\n   * @param {Number} d coordinate of second control point.\n   * @param {Number} t amount to interpolate between 0 and 1.\n   * @return {Number} coordinate of a point on the tangent line.\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Set the coordinates for the curve's anchor and control points.\n   *   let x1 = 5;\n   *   let y1 = 26;\n   *   let x2 = 73;\n   *   let y2 = 24;\n   *   let x3 = 73;\n   *   let y3 = 61;\n   *   let x4 = 15;\n   *   let y4 = 65;\n   *\n   *   // Draw the curve.\n   *   noFill();\n   *   spline(x1, y1, x2, y2, x3, y3, x4, y4);\n   *\n   *   // Draw tangents along the curve's path.\n   *   fill(255);\n   *\n   *   // Top circle.\n   *   stroke(0);\n   *   let x = splinePoint(x1, x2, x3, x4, 0);\n   *   let y = splinePoint(y1, y2, y3, y4, 0);\n   *   circle(x, y, 5);\n   *\n   *   // Top tangent line.\n   *   // Scale the tangent point to draw a shorter line.\n   *   stroke(255, 0, 0);\n   *   let tx = 0.2 * splineTangent(x1, x2, x3, x4, 0);\n   *   let ty = 0.2 * splineTangent(y1, y2, y3, y4, 0);\n   *   line(x + tx, y + ty, x - tx, y - ty);\n   *\n   *   // Center circle.\n   *   stroke(0);\n   *   x = splinePoint(x1, x2, x3, x4, 0.5);\n   *   y = splinePoint(y1, y2, y3, y4, 0.5);\n   *   circle(x, y, 5);\n   *\n   *   // Center tangent line.\n   *   // Scale the tangent point to draw a shorter line.\n   *   stroke(255, 0, 0);\n   *   tx = 0.2 * splineTangent(x1, x2, x3, x4, 0.5);\n   *   ty = 0.2 * splineTangent(y1, y2, y3, y4, 0.5);\n   *   line(x + tx, y + ty, x - tx, y - ty);\n   *\n   *   // Bottom circle.\n   *   stroke(0);\n   *   x = splinePoint(x1, x2, x3, x4, 1);\n   *   y = splinePoint(y1, y2, y3, y4, 1);\n   *   circle(x, y, 5);\n   *\n   *   // Bottom tangent line.\n   *   // Scale the tangent point to draw a shorter line.\n   *   stroke(255, 0, 0);\n   *   tx = 0.2 * splineTangent(x1, x2, x3, x4, 1);\n   *   ty = 0.2 * splineTangent(y1, y2, y3, y4, 1);\n   *   line(x + tx, y + ty, x - tx, y - ty);\n   *\n   *   describe(\n   *     'A black curve on a gray square. A white circle moves back and forth along the curve.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   */\n  fn.splineTangent = function(a, b, c, d, t) {\n    const s = this._renderer.states.splineProperties.tightness,\n      tt3 = t * t * 3,\n      t2 = t * 2,\n      f1 = (s - 1) / 2 * tt3 + (1 - s) * t2 + (s - 1) / 2,\n      f2 = (s + 3) / 2 * tt3 + (-5 - s) / 2 * t2,\n      f3 = (-3 - s) / 2 * tt3 + (s + 2) * t2 + (1 - s) / 2,\n      f4 = (1 - s) / 2 * tt3 + (s - 1) / 2 * t2;\n    return a * f1 + b * f2 + c * f3 + d * f4;\n  };\n}\n\nif(typeof p5 !== 'undefined'){\n  curves(p5, p5.prototype);\n}\n\nexport { curves as default };\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5122, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Users/Ryan%20Purnomo/Bahasa-Pemrograman/Website/Javascript/NextJS/CG-GAMES/node_modules/p5/dist/shape/vertex.js"],"sourcesContent":["/**\n * @module Shape\n * @submodule Custom Shapes\n * @for p5\n * @requires core\n * @requires constants\n */\n\n\nfunction vertex(p5, fn){\n  /**\n   * Begins adding vertices to a custom shape.\n   *\n   * The `beginShape()` and <a href=\"#/p5/endShape\">endShape()</a> functions\n   * allow for creating custom shapes in 2D or 3D. `beginShape()` begins adding\n   * vertices to a custom shape and <a href=\"#/p5/endShape\">endShape()</a> stops\n   * adding them.\n   *\n   * The parameter, `kind`, sets the kind of shape to make. The available kinds are:\n   *\n   * - `PATH` (the default) to draw shapes by tracing out the path along their edges.\n   * - `POINTS` to draw a series of points.\n   * - `LINES` to draw a series of unconnected line segments.\n   * - `TRIANGLES` to draw a series of separate triangles.\n   * - `TRIANGLE_FAN` to draw a series of connected triangles sharing the first vertex in a fan-like fashion.\n   * - `TRIANGLE_STRIP` to draw a series of connected triangles in strip fashion.\n   * - `QUADS` to draw a series of separate quadrilaterals (quads).\n   * - `QUAD_STRIP` to draw quad strip using adjacent edges to form the next quad.\n   *\n   * After calling `beginShape()`, shapes can be built by calling\n   * <a href=\"#/p5/vertex\">vertex()</a>,\n   * <a href=\"#/p5/bezierVertex\">bezierVertex()</a>, and/or\n   * <a href=\"#/p5/splineVertex\">splineVertex()</a>. Calling\n   * <a href=\"#/p5/endShape\">endShape()</a> will stop adding vertices to the\n   * shape. Each shape will be outlined with the current stroke color and filled\n   * with the current fill color.\n   *\n   * Transformations such as <a href=\"#/p5/translate\">translate()</a>,\n   * <a href=\"#/p5/rotate\">rotate()</a>, and\n   * <a href=\"#/p5/scale\">scale()</a> don't work between `beginShape()` and\n   * <a href=\"#/p5/endShape\">endShape()</a>. It's also not possible to use\n   * other shapes, such as <a href=\"#/p5/ellipse\">ellipse()</a> or\n   * <a href=\"#/p5/rect\">rect()</a>, between `beginShape()` and\n   * <a href=\"#/p5/endShape\">endShape()</a>.\n   *\n   * @method beginShape\n   * @param  {(POINTS|LINES|TRIANGLES|TRIANGLE_FAN|TRIANGLE_STRIP|QUADS|QUAD_STRIP|PATH)} [kind=PATH] either POINTS, LINES, TRIANGLES, TRIANGLE_FAN\n   *                                TRIANGLE_STRIP, QUADS, QUAD_STRIP or PATH. Defaults to PATH.\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Add vertices.\n   *   vertex(30, 20);\n   *   vertex(85, 20);\n   *   vertex(85, 75);\n   *   vertex(30, 75);\n   *\n   *   // Stop drawing the shape.\n   *   endShape(CLOSE);\n   *\n   *   describe('A white square on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Start drawing the shape.\n   *   // Only draw the vertices (points).\n   *   beginShape(POINTS);\n   *\n   *   // Add vertices.\n   *   vertex(30, 20);\n   *   vertex(85, 20);\n   *   vertex(85, 75);\n   *   vertex(30, 75);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   describe('Four black dots that form a square are drawn on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Start drawing the shape.\n   *   // Only draw lines between alternating pairs of vertices.\n   *   beginShape(LINES);\n   *\n   *   // Add vertices.\n   *   vertex(30, 20);\n   *   vertex(85, 20);\n   *   vertex(85, 75);\n   *   vertex(30, 75);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   describe('Two horizontal black lines on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Style the shape.\n   *   noFill();\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Add vertices.\n   *   vertex(30, 20);\n   *   vertex(85, 20);\n   *   vertex(85, 75);\n   *   vertex(30, 75);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   describe('Three black lines form a sideways U shape on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Style the shape.\n   *   noFill();\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Add vertices.\n   *   vertex(30, 20);\n   *   vertex(85, 20);\n   *   vertex(85, 75);\n   *   vertex(30, 75);\n   *\n   *   // Stop drawing the shape.\n   *   // Connect the first and last vertices.\n   *   endShape(CLOSE);\n   *\n   *   describe('A black outline of a square drawn on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Start drawing the shape.\n   *   // Draw a series of triangles.\n   *   beginShape(TRIANGLES);\n   *\n   *   // Left triangle.\n   *   vertex(30, 75);\n   *   vertex(40, 20);\n   *   vertex(50, 75);\n   *\n   *   // Right triangle.\n   *   vertex(60, 20);\n   *   vertex(70, 75);\n   *   vertex(80, 20);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   describe('Two white triangles drawn on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Start drawing the shape.\n   *   // Draw a series of triangles.\n   *   beginShape(TRIANGLE_STRIP);\n   *\n   *   // Add vertices.\n   *   vertex(30, 75);\n   *   vertex(40, 20);\n   *   vertex(50, 75);\n   *   vertex(60, 20);\n   *   vertex(70, 75);\n   *   vertex(80, 20);\n   *   vertex(90, 75);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   describe('Five white triangles that are interleaved drawn on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Start drawing the shape.\n   *   // Draw a series of triangles that share their first vertex.\n   *   beginShape(TRIANGLE_FAN);\n   *\n   *   // Add vertices.\n   *   vertex(57.5, 50);\n   *   vertex(57.5, 15);\n   *   vertex(92, 50);\n   *   vertex(57.5, 85);\n   *   vertex(22, 50);\n   *   vertex(57.5, 15);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   describe('Four white triangles form a square are drawn on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Start drawing the shape.\n   *   // Draw a series of quadrilaterals.\n   *   beginShape(QUADS);\n   *\n   *   // Left rectangle.\n   *   vertex(30, 20);\n   *   vertex(30, 75);\n   *   vertex(50, 75);\n   *   vertex(50, 20);\n   *\n   *   // Right rectangle.\n   *   vertex(65, 20);\n   *   vertex(65, 75);\n   *   vertex(85, 75);\n   *   vertex(85, 20);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   describe('Two white rectangles drawn on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Start drawing the shape.\n   *   // Draw a series of quadrilaterals.\n   *   beginShape(QUAD_STRIP);\n   *\n   *   // Add vertices.\n   *   vertex(30, 20);\n   *   vertex(30, 75);\n   *   vertex(50, 20);\n   *   vertex(50, 75);\n   *   vertex(65, 20);\n   *   vertex(65, 75);\n   *   vertex(85, 20);\n   *   vertex(85, 75);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   describe('Three white rectangles that share edges are drawn on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   // Start drawing the shape.\n   *   // Draw a series of quadrilaterals.\n   *   beginShape(PATH);\n   *\n   *   // Add the vertices.\n   *   vertex(-30, -30, 0);\n   *   vertex(30, -30, 0);\n   *   vertex(30, -10, 0);\n   *   vertex(-10, -10, 0);\n   *   vertex(-10, 10, 0);\n   *   vertex(30, 10, 0);\n   *   vertex(30, 30, 0);\n   *   vertex(-30, 30, 0);\n   *\n   *   // Stop drawing the shape.\n   *   // Connect the first and last vertices.\n   *   endShape(CLOSE);\n   *\n   *   describe('A blocky C shape drawn in white on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag with the mouse to view the scene from different angles.\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A blocky C shape drawn in red, blue, and green on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Start drawing the shape.\n   *   // Draw a series of quadrilaterals.\n   *   beginShape(PATH);\n   *\n   *   // Add the vertices.\n   *   fill('red');\n   *   stroke('red');\n   *   vertex(-30, -30, 0);\n   *   vertex(30, -30, 0);\n   *   vertex(30, -10, 0);\n   *   fill('green');\n   *   stroke('green');\n   *   vertex(-10, -10, 0);\n   *   vertex(-10, 10, 0);\n   *   vertex(30, 10, 0);\n   *   fill('blue');\n   *   stroke('blue');\n   *   vertex(30, 30, 0);\n   *   vertex(-30, 30, 0);\n   *\n   *   // Stop drawing the shape.\n   *   // Connect the first and last vertices.\n   *   endShape(CLOSE);\n   * }\n   * </code>\n   * </div>\n   */\n  fn.beginShape = function(kind) {\n    // p5._validateParameters('beginShape', arguments);\n    this._renderer.beginShape(...arguments);\n  };\n\n  /**\n   * Adds a BÃ©zier curve segment to a custom shape.\n   *\n   * `bezierVertex()` adds a curved segment to custom shapes. The BÃ©zier curves\n   * it creates are defined like those made by the\n   * <a href=\"#/p5/bezier\">bezier()</a> function. `bezierVertex()` must be\n   * called between the\n   * <a href=\"#/p5/beginShape\">beginShape()</a> and\n   * <a href=\"#/p5/endShape\">endShape()</a> functions.\n   * BÃ©zier need a starting point. Building a shape\n   * only with BÃ©zier curves needs one initial\n   * call to <a href=\"#/p5/vertex\">bezierVertex()</a>, before\n   * a number of `bezierVertex()` calls that is a multiple of the parameter\n   * set by <a href=\"#/p5/bezierOrder\">bezierOrder(...)</a> (default 3).\n   * But shapes can mix different types of vertices, so if there\n   * are some previous vertices, then the initial anchor is not needed, \n   * only the multiples of 3 (or the BÃ©zier order) calls to \n   *  `bezierVertex` for each curve.\n   * \n   * Each curve of order 3 requires three calls to `bezierVertex`, so\n   * 2 curves would need 7 calls to `bezierVertex()`:\n   * (1 one initial anchor point, two sets of 3 curves describing the curves)\n   * With `bezierOrder(2)`, two curves would need 5 calls: 1 + 2 + 2. \n   *\n   * BÃ©zier curves can also be drawn in 3D using WebGL mode.\n   *\n   * Note: `bezierVertex()` wonâ€™t work when an argument is passed to\n   * <a href=\"#/p5/beginShape\">beginShape()</a>.\n   *\n   * @method bezierVertex\n   * @param  {Number} x x-coordinate of the first control point.\n   * @param  {Number} y y-coordinate of the first control point.\n   * @param  {Number} [u]\n   * @param  {Number} [v]\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Style the shape.\n   *   noFill();\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Add the first anchor point.\n   *   bezierVertex(30, 20);\n   *\n   *   // Add the BÃ©zier vertex.\n   *   bezierVertex(80, 0);\n   *   bezierVertex(80, 75);\n   *   bezierVertex(30, 75);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   describe('A black C curve on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Draw the anchor points in black.\n   *   stroke(0);\n   *   strokeWeight(5);\n   *   point(30, 20);\n   *   point(30, 75);\n   *\n   *   // Draw the control points in red.\n   *   stroke(255, 0, 0);\n   *   point(80, 0);\n   *   point(80, 75);\n   *\n   *   // Style the shape.\n   *   noFill();\n   *   stroke(0);\n   *   strokeWeight(1);\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Add the first anchor point.\n   *   bezierVertex(30, 20);\n   *\n   *   // Add the BÃ©zier vertex.\n   *   bezierVertex(80, 0);\n   *   bezierVertex(80, 75);\n   *   bezierVertex(30, 75);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   // Draw red lines from the anchor points to the control points.\n   *   stroke(255, 0, 0);\n   *   line(30, 20, 80, 0);\n   *   line(30, 75, 80, 75);\n   *\n   *   describe(\n   *     'A gray square with three curves. A black curve has two straight, red lines that extend from its ends. The endpoints of all the curves are marked with dots.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click the mouse near the red dot in the top-right corner\n   * // and drag to change the curve's shape.\n   *\n   * let x2 = 80;\n   * let y2 = 0;\n   * let isChanging = false;\n   *\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   describe(\n   *     'A gray square with three curves. A black curve has two straight, red lines that extend from its ends. The endpoints of all the curves are marked with dots.'\n   *   );\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Draw the anchor points in black.\n   *   stroke(0);\n   *   strokeWeight(5);\n   *   point(30, 20);\n   *   point(30, 75);\n   *\n   *   // Draw the control points in red.\n   *   stroke(255, 0, 0);\n   *   point(x2, y2);\n   *   point(80, 75);\n   *\n   *   // Style the shape.\n   *   noFill();\n   *   stroke(0);\n   *   strokeWeight(1);\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Add the first anchor point.\n   *   bezierVertex(30, 20);\n   *\n   *   // Add the BÃ©zier vertex.\n   *   bezierVertex(x2, y2);\n   *   bezierVertex(80, 75);\n   *   bezierVertex(30, 75);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   // Draw red lines from the anchor points to the control points.\n   *   stroke(255, 0, 0);\n   *   line(30, 20, x2, y2);\n   *   line(30, 75, 80, 75);\n   * }\n   *\n   * // Start changing the first control point if the user clicks near it.\n   * function mousePressed() {\n   *   if (dist(mouseX, mouseY, x2, y2) < 20) {\n   *     isChanging = true;\n   *   }\n   * }\n   *\n   * // Stop changing the first control point when the user releases the mouse.\n   * function mouseReleased() {\n   *   isChanging = false;\n   * }\n   *\n   * // Update the first control point while the user drags the mouse.\n   * function mouseDragged() {\n   *   if (isChanging === true) {\n   *     x2 = mouseX;\n   *     y2 = mouseY;\n   *   }\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Start drawing the shape.\n   *   beginShape();\n   *\n   *   // Add the first anchor point.\n   *   bezierVertex(30, 20);\n   *\n   *   // Add the BÃ©zier vertices.\n   *   bezierVertex(80, 0);\n   *   bezierVertex(80, 75);\n   *   bezierVertex(30, 75);\n   * \n   *   bezierVertex(50, 80);\n   *   bezierVertex(60, 25);\n   *   bezierVertex(30, 20);\n   *\n   *   // Stop drawing the shape.\n   *   endShape();\n   *\n   *   describe('A crescent moon shape drawn in white on a gray background.');\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A crescent moon shape drawn in white on a blue background. When the user drags the mouse, the scene rotates and a second moon is revealed.');\n   * }\n   *\n   * function draw() {\n   *   background('midnightblue');\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Style the moons.\n   *   noStroke();\n   *   fill('lemonchiffon');\n   *\n   *   // Draw the first moon.\n   *   beginShape();\n   *   bezierVertex(-20, -30, 0);\n   * \n   *   bezierVertex(30, -50, 0);\n   *   bezierVertex(30, 25, 0);\n   *   bezierVertex(-20, 25, 0);\n   * \n   *   bezierVertex(0, 30, 0);\n   *   bezierVertex(10, -25, 0);\n   *   bezierVertex(-20, -30, 0);\n   *   endShape();\n   *\n   *   // Draw the second moon.\n   *   beginShape();\n   * \n   *   bezierVertex(-20, -30, -20);\n   * \n   *   bezierVertex(30, -50, -20);\n   *   bezierVertex(30, 25, -20);\n   *   bezierVertex(-20, 25, -20);\n   * \n   *   bezierVertex(0, 30, -20);\n   *   bezierVertex(10, -25, -20);\n   *   bezierVertex(-20, -30, -20);\n   * \n   *   endShape();\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * @method bezierVertex\n   * @param  {Number} x\n   * @param  {Number} y\n   * @param  {Number} z\n   * @param  {Number} [u]\n   * @param  {Number} [v]\n   */\n  fn.bezierVertex = function(...args) {\n    this._renderer.bezierVertex(...args);\n  };\n\n  /**\n   * Concludes the vertices of a custom shape. \n   * \n   * The <a href=\"#/p5/beginShape\">beginShape()</a> and `endShape()` functions\n   * allow for creating custom shapes in 2D or 3D.\n   * <a href=\"#/p5/beginShape\">beginShape()</a> begins adding vertices to a\n   * custom shape and `endShape()` stops adding them.\n   *\n   * The first parameter, `mode`, is optional. By default, the first and last\n   * vertices of a shape aren't connected. If the constant `CLOSE` is passed, as\n   * in `endShape(CLOSE)`, then the first and last vertices will be connected.\n   * When CLOSE mode is used for splines (with `splineVeertex()`), the shape is ended smoothly.\n   *\n   * \n   * The second parameter, `count`, is also optional. In WebGL mode, itâ€™s more\n   * efficient to draw many copies of the same shape using a technique called\n   * <a href=\"https://webglfundamentals.org/webgl/lessons/webgl-instanced-drawing.html\" target=\"_blank\">instancing</a>.\n   * The `count` parameter tells WebGL mode how many copies to draw. For\n   * example, calling `endShape(CLOSE, 400)` after drawing a custom shape will\n   * make it efficient to draw 400 copies. This feature requires\n   * <a href=\"https://p5js.org/tutorials/intro-to-shaders/\" target=\"_blank\">writing a custom shader</a>.\n   *\n   * After calling <a href=\"#/p5/beginShape\">beginShape()</a>, shapes can be\n   * built by calling <a href=\"#/p5/vertex\">vertex()</a>,\n   * <a href=\"#/p5/bezierVertex\">bezierVertex()</a> and/or\n   * <a href=\"#/p5/splineVertex\">splineVertex()</a>. Calling\n   * `endShape()` will stop adding vertices to the\n   * shape. Each shape will be outlined with the current stroke color and filled\n   * with the current fill color.\n   *\n   * Transformations such as <a href=\"#/p5/translate\">translate()</a>,\n   * <a href=\"#/p5/rotate\">rotate()</a>, and\n   * <a href=\"#/p5/scale\">scale()</a> don't work between\n   * <a href=\"#/p5/beginShape\">beginShape()</a> and `endShape()`. It's also not\n   * possible to use other shapes, such as <a href=\"#/p5/ellipse\">ellipse()</a> or\n   * <a href=\"#/p5/rect\">rect()</a>, between\n   * <a href=\"#/p5/beginShape\">beginShape()</a> and `endShape()`.\n   *\n   * @method endShape\n   * @param  {CLOSE} [mode] use CLOSE to close the shape\n   * @param  {Integer} [count] number of times you want to draw/instance the shape (for WebGL mode).\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *\n   *   background(200);\n   *\n   *   // Style the shapes.\n   *   noFill();\n   *\n   *   // Left triangle.\n   *   beginShape();\n   *   vertex(20, 20);\n   *   vertex(45, 20);\n   *   vertex(45, 80);\n   *   endShape(CLOSE);\n   *\n   *   // Right triangle.\n   *   beginShape();\n   *   vertex(50, 20);\n   *   vertex(75, 20);\n   *   vertex(75, 80);\n   *   endShape();\n   *\n   *   describe(\n   *     'Two sets of black lines drawn on a gray background. The three lines on the left form a right triangle. The two lines on the right form a right angle.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   * \n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100);\n   *   background(200);\n   * \n   *   beginShape();\n   * \n   *   splineVertex(32, 91);\n   *   splineVertex(21, 17);\n   *   splineVertex(68, 19);\n   *   splineVertex(82, 91);\n   * \n   *   endShape(CLOSE);\n   * \n   *   describe(\n   *     'A curvy four-sided slightly lopsided blob.'\n   *   );\n   * }\n   * </div>\n   * </code>\n   *\n   * <div>\n   * <code>\n   * // Note: A \"uniform\" is a global variable within a shader program.\n   *\n   * // Create a string with the vertex shader program.\n   * // The vertex shader is called for each vertex.\n   * let vertSrc = `#version 300 es\n   *\n   * precision mediump float;\n   *\n   * in vec3 aPosition;\n   * flat out int instanceID;\n   *\n   * uniform mat4 uModelViewMatrix;\n   * uniform mat4 uProjectionMatrix;\n   *\n   * void main() {\n   *\n   *   // Copy the instance ID to the fragment shader.\n   *   instanceID = gl_InstanceID;\n   *   vec4 positionVec4 = vec4(aPosition, 1.0);\n   *\n   *   // gl_InstanceID represents a numeric value for each instance.\n   *   // Using gl_InstanceID allows us to move each instance separately.\n   *   // Here we move each instance horizontally by ID * 23.\n   *   float xOffset = float(gl_InstanceID) * 23.0;\n   *\n   *   // Apply the offset to the final position.\n   *   gl_Position = uProjectionMatrix * uModelViewMatrix * (positionVec4 -\n   *     vec4(xOffset, 0.0, 0.0, 0.0));\n   * }\n   * `;\n   *\n   * // Create a string with the fragment shader program.\n   * // The fragment shader is called for each pixel.\n   * let fragSrc = `#version 300 es\n   *\n   * precision mediump float;\n   *\n   * out vec4 outColor;\n   * flat in int instanceID;\n   * uniform float numInstances;\n   *\n   * void main() {\n   *   vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\n   *   vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);\n   *\n   *   // Normalize the instance ID.\n   *   float normId = float(instanceID) / numInstances;\n   *\n   *   // Mix between two colors using the normalized instance ID.\n   *   outColor = mix(red, blue, normId);\n   * }\n   * `;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Shader object.\n   *   let myShader = createShader(vertSrc, fragSrc);\n   *\n   *   background(220);\n   *\n   *   // Compile and apply the p5.Shader.\n   *   shader(myShader);\n   *\n   *   // Set the numInstances uniform.\n   *   myShader.setUniform('numInstances', 4);\n   *\n   *   // Translate the origin to help align the drawing.\n   *   translate(25, -10);\n   *\n   *   // Style the shapes.\n   *   noStroke();\n   *\n   *   // Draw the shapes.\n   *   beginShape();\n   *   vertex(0, 0);\n   *   vertex(0, 20);\n   *   vertex(20, 20);\n   *   vertex(20, 0);\n   *   vertex(0, 0);\n   *   endShape(CLOSE, 4);\n   *\n   *   describe('A row of four squares. Their colors transition from purple on the left to red on the right');\n   * }\n   * </code>\n   * </div>\n   */\n  fn.endShape = function(mode, count = 1) {\n    // p5._validateParameters('endShape', arguments);\n    if (count < 1) {\n      console.log('ðŸŒ¸ p5.js says: You can not have less than one instance');\n      count = 1;\n    }\n\n    this._renderer.endShape(mode, count);\n  };\n\n  /**\n   * Sets the normal vector for vertices in a custom 3D shape.\n   *\n   * 3D shapes created with <a href=\"#/p5/beginShape\">beginShape()</a> and\n   * <a href=\"#/p5/endShape\">endShape()</a> are made by connecting sets of\n   * points called vertices. Each vertex added with\n   * <a href=\"#/p5/vertex\">vertex()</a> has a normal vector that points away\n   * from it. The normal vector controls how light reflects off the shape.\n   *\n   * `normal()` can be called two ways with different parameters to define the\n   * normal vector's components.\n   *\n   * The first way to call `normal()` has three parameters, `x`, `y`, and `z`.\n   * If `Number`s are passed, as in `normal(1, 2, 3)`, they set the x-, y-, and\n   * z-components of the normal vector.\n   *\n   * The second way to call `normal()` has one parameter, `vector`. If a\n   * <a href=\"#/p5.Vector\">p5.Vector</a> object is passed, as in\n   * `normal(myVector)`, its components will be used to set the normal vector.\n   *\n   * `normal()` changes the normal vector of vertices added to a custom shape\n   * with <a href=\"#/p5/vertex\">vertex()</a>. `normal()` must be called between\n   * the <a href=\"#/p5/beginShape\">beginShape()</a> and\n   * <a href=\"#/p5/endShape\">endShape()</a> functions, just like\n   * <a href=\"#/p5/vertex\">vertex()</a>. The normal vector set by calling\n   * `normal()` will affect all following vertices until `normal()` is called\n   * again:\n   *\n   * ```js\n   * beginShape();\n   *\n   * // Set the vertex normal.\n   * normal(-0.4, -0.4, 0.8);\n   *\n   * // Add a vertex.\n   * vertex(-30, -30, 0);\n   *\n   * // Set the vertex normal.\n   * normal(0, 0, 1);\n   *\n   * // Add vertices.\n   * vertex(30, -30, 0);\n   * vertex(30, 30, 0);\n   *\n   * // Set the vertex normal.\n   * normal(0.4, -0.4, 0.8);\n   *\n   * // Add a vertex.\n   * vertex(-30, 30, 0);\n   *\n   * endShape();\n   * ```\n   *\n   * @method normal\n   * @param  {p5.Vector} vector vertex normal as a <a href=\"#/p5.Vector\">p5.Vector</a> object.\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Click the and drag the mouse to view the scene from a different angle.\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe(\n   *     'A colorful square on a black background. The square changes color and rotates when the user drags the mouse. Parts of its surface reflect light in different directions.'\n   *   );\n   * }\n   *\n   * function draw() {\n   *   background(0);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Style the shape.\n   *   normalMaterial();\n   *   noStroke();\n   *\n   *   // Draw the shape.\n   *   beginShape();\n   *   vertex(-30, -30, 0);\n   *   vertex(30, -30, 0);\n   *   vertex(30, 30, 0);\n   *   vertex(-30, 30, 0);\n   *   endShape();\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click the and drag the mouse to view the scene from a different angle.\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe(\n   *     'A colorful square on a black background. The square changes color and rotates when the user drags the mouse. Parts of its surface reflect light in different directions.'\n   *   );\n   * }\n   *\n   * function draw() {\n   *   background(0);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Style the shape.\n   *   normalMaterial();\n   *   noStroke();\n   *\n   *   // Draw the shape.\n   *   // Use normal() to set vertex normals.\n   *   beginShape();\n   *   normal(-0.4, -0.4, 0.8);\n   *   vertex(-30, -30, 0);\n   *\n   *   normal(0, 0, 1);\n   *   vertex(30, -30, 0);\n   *   vertex(30, 30, 0);\n   *\n   *   normal(0.4, -0.4, 0.8);\n   *   vertex(-30, 30, 0);\n   *   endShape();\n   * }\n   * </code>\n   * </div>\n   *\n   * <div class='notest'>\n   * <code>\n   * // Click the and drag the mouse to view the scene from a different angle.\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe(\n   *     'A colorful square on a black background. The square changes color and rotates when the user drags the mouse. Parts of its surface reflect light in different directions.'\n   *   );\n   * }\n   *\n   * function draw() {\n   *   background(0);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Style the shape.\n   *   normalMaterial();\n   *   noStroke();\n   *\n   *   // Create p5.Vector objects.\n   *   let n1 = createVector(-0.4, -0.4, 0.8);\n   *   let n2 = createVector(0, 0, 1);\n   *   let n3 = createVector(0.4, -0.4, 0.8);\n   *\n   *   // Draw the shape.\n   *   // Use normal() to set vertex normals.\n   *   beginShape();\n   *   normal(n1);\n   *   vertex(-30, -30, 0);\n   *\n   *   normal(n2);\n   *   vertex(30, -30, 0);\n   *   vertex(30, 30, 0);\n   *\n   *   normal(n3);\n   *   vertex(-30, 30, 0);\n   *   endShape();\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * @method normal\n   * @param  {Number} x x-component of the vertex normal.\n   * @param  {Number} y y-component of the vertex normal.\n   * @param  {Number} z z-component of the vertex normal.\n   * @chainable\n   */\n  fn.normal = function(x, y, z) {\n    this._assert3d('normal');\n    // p5._validateParameters('normal', arguments);\n    this._renderer.normal(...arguments);\n\n    return this;\n  };\n\n  /**\n   * Sets the shader's vertex property or attribute variables.\n   *\n   * A vertex property, or vertex attribute, is a variable belonging to a vertex in a shader. p5.js provides some\n   * default properties, such as `aPosition`, `aNormal`, `aVertexColor`, etc. These are\n   * set using <a href=\"#/p5/vertex\">vertex()</a>, <a href=\"#/p5/normal\">normal()</a>\n   * and <a href=\"#/p5/fill\">fill()</a> respectively. Custom properties can also\n   * be defined within <a href=\"#/p5/beginShape\">beginShape()</a> and\n   * <a href=\"#/p5/endShape\">endShape()</a>.\n   *\n   * The first parameter, `propertyName`, is a string with the property's name.\n   * This is the same variable name which should be declared in the shader, such as\n   * `in vec3 aProperty`, similar to .`setUniform()`.\n   *\n   * The second parameter, `data`, is the value assigned to the shader variable. This\n   * value will be applied to subsequent vertices created with\n   * <a href=\"#/p5/vertex\">vertex()</a>. It can be a Number or an array of numbers,\n   * and in the shader program the type can be declared according to the WebGL\n   * specification. Common types include `float`, `vec2`, `vec3`, `vec4` or matrices.\n   *\n   * See also the <a href=\"#/p5/vertexProperty\">vertexProperty()</a> method on\n   * <a href=\"#/p5/Geometry\">Geometry</a> objects.\n   *\n   * @method vertexProperty\n   * @for p5\n   * @param {String} attributeName the name of the vertex attribute.\n   * @param {Number|Number[]} data the data tied to the vertex attribute.\n   *\n   * @example\n   * <div>\n   * <code>\n   * const vertSrc = `#version 300 es\n   *  precision mediump float;\n   *  uniform mat4 uModelViewMatrix;\n   *  uniform mat4 uProjectionMatrix;\n   *\n   *  in vec3 aPosition;\n   *  in vec2 aOffset;\n   *\n   *  void main(){\n   *    vec4 positionVec4 = vec4(aPosition.xyz, 1.0);\n   *    positionVec4.xy += aOffset;\n   *    gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;\n   *  }\n   * `;\n   *\n   * const fragSrc = `#version 300 es\n   *  precision mediump float;\n   *  out vec4 outColor;\n   *  void main(){\n   *    outColor = vec4(0.0, 1.0, 1.0, 1.0);\n   *  }\n   * `;\n   *\n   * function setup(){\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create and use the custom shader.\n   *   const myShader = createShader(vertSrc, fragSrc);\n   *   shader(myShader);\n   *\n   *   describe('A wobbly, cyan circle on a gray background.');\n   * }\n   *\n   * function draw(){\n   *   // Set the styles\n   *   background(125);\n   *   noStroke();\n   *\n   *   // Draw the circle.\n   *   beginShape();\n   *   for (let i = 0; i < 30; i++){\n   *     const x = 40 * cos(i/30 * TWO_PI);\n   *     const y = 40 * sin(i/30 * TWO_PI);\n   *\n   *     // Apply some noise to the coordinates.\n   *     const xOff = 10 * noise(x + millis()/1000) - 5;\n   *     const yOff = 10 * noise(y + millis()/1000) - 5;\n   *\n   *     // Apply these noise values to the following vertex.\n   *     vertexProperty('aOffset', [xOff, yOff]);\n   *     vertex(x, y);\n   *   }\n   *   endShape(CLOSE);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * let myShader;\n   * const cols = 10;\n   * const rows = 10;\n   * const cellSize = 6;\n   *\n   * const vertSrc = `#version 300 es\n   *   precision mediump float;\n   *   uniform mat4 uProjectionMatrix;\n   *   uniform mat4 uModelViewMatrix;\n   *\n   *   in vec3 aPosition;\n   *   in vec3 aNormal;\n   *   in vec3 aVertexColor;\n   *   in float aDistance;\n   *\n   *   out vec3 vVertexColor;\n   *\n   *   void main(){\n   *     vec4 positionVec4 = vec4(aPosition, 1.0);\n   *     positionVec4.xyz += aDistance * aNormal * 2.0;;\n   *     vVertexColor = aVertexColor;\n   *     gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;\n   *   }\n   * `;\n   *\n   * const fragSrc = `#version 300 es\n   *   precision mediump float;\n   *\n   *   in vec3 vVertexColor;\n   *   out vec4 outColor;\n   *\n   *   void main(){\n   *     outColor = vec4(vVertexColor, 1.0);\n   *   }\n   * `;\n   *\n   * function setup(){\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create and apply the custom shader.\n   *   myShader = createShader(vertSrc, fragSrc);\n   *   shader(myShader);\n   *   noStroke();\n   *   describe('A blue grid, which moves away from the mouse position, on a gray background.');\n   * }\n   *\n   * function draw(){\n   *   background(200);\n   *\n   *   // Draw the grid in the middle of the screen.\n   *   translate(-cols*cellSize/2, -rows*cellSize/2);\n   *   beginShape(QUADS);\n   *   for (let i = 0; i < cols; i++) {\n   *     for (let j = 0; j < rows; j++) {\n   *\n   *       // Calculate the cell position.\n   *       let x = i * cellSize;\n   *       let y = j * cellSize;\n   *\n   *       fill(j/rows*255, j/cols*255, 255);\n   *\n   *       // Calculate the distance from the corner of each cell to the mouse.\n   *       let distance = dist(x, y, mouseX, mouseY);\n   *\n   *       // Send the distance to the shader.\n   *       vertexProperty('aDistance', min(distance, 100));\n   *\n   *       vertex(x, y);\n   *       vertex(x + cellSize, y);\n   *       vertex(x + cellSize, y + cellSize);\n   *       vertex(x, y + cellSize);\n   *     }\n   *   }\n   *   endShape();\n   * }\n   * </code>\n   * </div>\n   */\n  fn.vertexProperty = function(attributeName, data){\n    // this._assert3d('vertexProperty');\n    // p5._validateParameters('vertexProperty', arguments);\n    this._renderer.vertexProperty(attributeName, data);\n  };\n}\n\nif(typeof p5 !== 'undefined'){\n  vertex(p5, p5.prototype);\n}\n\nexport { vertex as default };\n"],"names":[],"mappings":"AAAA;;;;;;CAMC;;;AAGD,SAAS,OAAO,GAAE,EAAE,EAAE;IACpB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAkYC,GACD,GAAG,UAAU,GAAG,SAAS,IAAI;QAC3B,mDAAmD;QACnD,IAAI,CAAC,SAAS,CAAC,UAAU,IAAI;IAC/B;IAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAgRC,GAED;;;;;;;GAOC,GACD,GAAG,YAAY,GAAG,SAAS,GAAG,IAAI;QAChC,IAAI,CAAC,SAAS,CAAC,YAAY,IAAI;IACjC;IAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAyLC,GACD,GAAG,QAAQ,GAAG,SAAS,IAAI,EAAE,QAAQ,CAAC;QACpC,iDAAiD;QACjD,IAAI,QAAQ,GAAG;YACb,QAAQ,GAAG,CAAC;YACZ,QAAQ;QACV;QAEA,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,MAAM;IAChC;IAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA6KC,GAED;;;;;;GAMC,GACD,GAAG,MAAM,GAAG,SAAS,CAAC,EAAE,CAAC,EAAE,CAAC;QAC1B,IAAI,CAAC,SAAS,CAAC;QACf,+CAA+C;QAC/C,IAAI,CAAC,SAAS,CAAC,MAAM,IAAI;QAEzB,OAAO,IAAI;IACb;IAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAuKC,GACD,GAAG,cAAc,GAAG,SAAS,aAAa,EAAE,IAAI;QAC9C,oCAAoC;QACpC,uDAAuD;QACvD,IAAI,CAAC,SAAS,CAAC,cAAc,CAAC,eAAe;IAC/C;AACF;AAEA,IAAG,OAAO,OAAO,aAAY;IAC3B,OAAO,IAAI,GAAG,SAAS;AACzB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6365, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Users/Ryan%20Purnomo/Bahasa-Pemrograman/Website/Javascript/NextJS/CG-GAMES/node_modules/p5/dist/shape/index.js"],"sourcesContent":["import primitives from './2d_primitives.js';\nimport attributes from './attributes.js';\nimport curves from './curves.js';\nimport vertex from './vertex.js';\nimport customShapes from './custom_shapes.js';\nimport '../constants-C-g_eAdC.js';\nimport '../core/helpers.js';\nimport '../creating_reading-D4AAKRbx.js';\nimport 'colorjs.io/fn';\nimport '../color/color_spaces/hsb.js';\nimport '../math/p5.Vector.js';\n\nfunction shape(p5){\n  p5.registerAddon(primitives);\n  p5.registerAddon(attributes);\n  p5.registerAddon(curves);\n  p5.registerAddon(vertex);\n  p5.registerAddon(customShapes);\n}\n\nexport { shape as default };\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;AAEA,SAAS,MAAM,EAAE;IACf,GAAG,aAAa,CAAC,oJAAA,CAAA,UAAU;IAC3B,GAAG,aAAa,CAAC,iJAAA,CAAA,UAAU;IAC3B,GAAG,aAAa,CAAC,6IAAA,CAAA,UAAM;IACvB,GAAG,aAAa,CAAC,6IAAA,CAAA,UAAM;IACvB,GAAG,aAAa,CAAC,oJAAA,CAAA,UAAY;AAC/B","ignoreList":[0],"debugId":null}}]
}