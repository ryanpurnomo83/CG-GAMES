{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///home/user/cg-game-apps/node_modules/p5/dist/webgl/p5.DataArray.js"],"sourcesContent":["class DataArray {\n  constructor(initialLength = 128) {\n    this.length = 0;\n    this.data = new Float32Array(initialLength);\n    this.initialLength = initialLength;\n  }\n\n  /**\n   * Returns a Float32Array window sized to the exact length of the data\n   */\n  dataArray() {\n    return this.subArray(0, this.length);\n  }\n\n  /**\n   * A \"soft\" clear, which keeps the underlying storage size the same, but\n   * empties the contents of its dataArray()\n   */\n  clear() {\n    this.length = 0;\n  }\n\n  /**\n   * Can be used to scale a DataArray back down to fit its contents.\n   */\n  rescale() {\n    if (this.length < this.data.length / 2) {\n      // Find the power of 2 size that fits the data\n      const targetLength = 1 << Math.ceil(Math.log2(this.length));\n      const newData = new Float32Array(targetLength);\n      newData.set(this.data.subarray(0, this.length), 0);\n      this.data = newData;\n    }\n  }\n\n  /**\n   * A full reset, which allocates a new underlying Float32Array at its initial\n   * length\n   */\n  reset() {\n    this.clear();\n    this.data = new Float32Array(this.initialLength);\n  }\n\n  /**\n   * Adds values to the DataArray, expanding its internal storage to\n   * accommodate the new items.\n   */\n  push(...values) {\n    this.ensureLength(this.length + values.length);\n    this.data.set(values, this.length);\n    this.length += values.length;\n  }\n\n  /**\n   * Returns a copy of the data from the index `from`, inclusive, to the index\n   * `to`, exclusive\n   */\n  slice(from, to) {\n    return this.data.slice(from, Math.min(to, this.length));\n  }\n\n  /**\n   * Returns a mutable Float32Array window from the index `from`, inclusive, to\n   * the index `to`, exclusive\n   */\n  subArray(from, to) {\n    return this.data.subarray(from, Math.min(to, this.length));\n  }\n\n  /**\n   * Expand capacity of the internal storage until it can fit a target size\n   */\n  ensureLength(target) {\n    while (this.data.length < target) {\n      const newData = new Float32Array(this.data.length * 2);\n      newData.set(this.data, 0);\n      this.data = newData;\n    }\n  }\n}\nfunction dataArray(p5, fn){\n  /**\n   * An internal class to store data that will be sent to a p5.RenderBuffer.\n   * Those need to eventually go into a Float32Array, so this class provides a\n   * variable-length array container backed by a Float32Array so that it can be\n   * sent to the GPU without allocating a new array each frame.\n   *\n   * Like a C++ vector, its fixed-length Float32Array backing its contents will\n   * double in size when it goes over its capacity.\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Initialize storage with a capacity of 4\n   * const storage = new DataArray(4);\n   * console.log(storage.data.length); // 4\n   * console.log(storage.length); // 0\n   * console.log(storage.dataArray()); // Empty Float32Array\n   *\n   * storage.push(1, 2, 3, 4, 5, 6);\n   * console.log(storage.data.length); // 8\n   * console.log(storage.length); // 6\n   * console.log(storage.dataArray()); // Float32Array{1, 2, 3, 4, 5, 6}\n   * </code>\n   * </div>\n   */\n  p5.DataArray = DataArray;\n}\n\nif(typeof p5 !== 'undefined'){\n  dataArray(p5, p5.prototype);\n}\n\nexport { DataArray, dataArray as default };\n"],"names":[],"mappings":";;;;AAAA,MAAM;IACJ,YAAY,gBAAgB,GAAG,CAAE;QAC/B,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,IAAI,GAAG,IAAI,aAAa;QAC7B,IAAI,CAAC,aAAa,GAAG;IACvB;IAEA;;GAEC,GACD,YAAY;QACV,OAAO,IAAI,CAAC,QAAQ,CAAC,GAAG,IAAI,CAAC,MAAM;IACrC;IAEA;;;GAGC,GACD,QAAQ;QACN,IAAI,CAAC,MAAM,GAAG;IAChB;IAEA;;GAEC,GACD,UAAU;QACR,IAAI,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,GAAG;YACtC,8CAA8C;YAC9C,MAAM,eAAe,KAAK,KAAK,IAAI,CAAC,KAAK,IAAI,CAAC,IAAI,CAAC,MAAM;YACzD,MAAM,UAAU,IAAI,aAAa;YACjC,QAAQ,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,IAAI,CAAC,MAAM,GAAG;YAChD,IAAI,CAAC,IAAI,GAAG;QACd;IACF;IAEA;;;GAGC,GACD,QAAQ;QACN,IAAI,CAAC,KAAK;QACV,IAAI,CAAC,IAAI,GAAG,IAAI,aAAa,IAAI,CAAC,aAAa;IACjD;IAEA;;;GAGC,GACD,KAAK,GAAG,MAAM,EAAE;QACd,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,MAAM,GAAG,OAAO,MAAM;QAC7C,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,QAAQ,IAAI,CAAC,MAAM;QACjC,IAAI,CAAC,MAAM,IAAI,OAAO,MAAM;IAC9B;IAEA;;;GAGC,GACD,MAAM,IAAI,EAAE,EAAE,EAAE;QACd,OAAO,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,KAAK,GAAG,CAAC,IAAI,IAAI,CAAC,MAAM;IACvD;IAEA;;;GAGC,GACD,SAAS,IAAI,EAAE,EAAE,EAAE;QACjB,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,KAAK,GAAG,CAAC,IAAI,IAAI,CAAC,MAAM;IAC1D;IAEA;;GAEC,GACD,aAAa,MAAM,EAAE;QACnB,MAAO,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,OAAQ;YAChC,MAAM,UAAU,IAAI,aAAa,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG;YACpD,QAAQ,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE;YACvB,IAAI,CAAC,IAAI,GAAG;QACd;IACF;AACF;AACA,SAAS,UAAU,GAAE,EAAE,EAAE;IACvB;;;;;;;;;;;;;;;;;;;;;;;;GAwBC,GACD,IAAG,SAAS,GAAG;AACjB;AAEA,IAAG,OAAO,OAAO,aAAY;IAC3B,UAAU,IAAI,GAAG,SAAS;AAC5B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 113, "column": 0}, "map": {"version":3,"sources":["file:///home/user/cg-game-apps/node_modules/p5/dist/webgl/p5.Geometry.js"],"sourcesContent":["import { F as FLAT, y as SMOOTH } from '../constants-C-g_eAdC.js';\nimport { DataArray } from './p5.DataArray.js';\nimport { Vector } from '../math/p5.Vector.js';\n\n/**\n * @module Shape\n * @submodule 3D Primitives\n * @for p5\n * @requires core\n * @requires p5.Geometry\n */\n\n\nclass Geometry {\n  constructor(detailX, detailY, callback, renderer) {\n    this.renderer = renderer;\n    this.vertices = [];\n\n    this.boundingBoxCache = null;\n\n\n    //an array containing every vertex for stroke drawing\n    this.lineVertices = new DataArray();\n\n    // The tangents going into or out of a vertex on a line. Along a straight\n    // line segment, both should be equal. At an endpoint, one or the other\n    // will not exist and will be all 0. In joins between line segments, they\n    // may be different, as they will be the tangents on either side of the join.\n    this.lineTangentsIn = new DataArray();\n    this.lineTangentsOut = new DataArray();\n\n    // When drawing lines with thickness, entries in this buffer represent which\n    // side of the centerline the vertex will be placed. The sign of the number\n    // will represent the side of the centerline, and the absolute value will be\n    // used as an enum to determine which part of the cap or join each vertex\n    // represents. See the doc comments for _addCap and _addJoin for diagrams.\n    this.lineSides = new DataArray();\n\n    this.vertexNormals = [];\n\n    this.faces = [];\n\n    this.uvs = [];\n    // a 2D array containing edge connectivity pattern for create line vertices\n    //based on faces for most objects;\n    this.edges = [];\n    this.vertexColors = [];\n\n    // One color per vertex representing the stroke color at that vertex\n    this.vertexStrokeColors = [];\n\n    this.userVertexProperties = {};\n\n    // One color per line vertex, generated automatically based on\n    // vertexStrokeColors in _edgesToVertices()\n    this.lineVertexColors = new DataArray();\n    this.detailX = detailX !== undefined ? detailX : 1;\n    this.detailY = detailY !== undefined ? detailY : 1;\n    this.dirtyFlags = {};\n\n    this._hasFillTransparency = undefined;\n    this._hasStrokeTransparency = undefined;\n\n    this.gid = `_p5_Geometry_${Geometry.nextId}`;\n    Geometry.nextId++;\n    if (callback instanceof Function) {\n      callback.call(this);\n    }\n  }\n\n  /**\n * Calculates the position and size of the smallest box that contains the geometry.\n *\n * A bounding box is the smallest rectangular prism that contains the entire\n * geometry. It's defined by the box's minimum and maximum coordinates along\n * each axis, as well as the size (length) and offset (center).\n *\n * Calling `myGeometry.calculateBoundingBox()` returns an object with four\n * properties that describe the bounding box:\n *\n * ```js\n * // Get myGeometry's bounding box.\n * let bbox = myGeometry.calculateBoundingBox();\n *\n * // Print the bounding box to the console.\n * console.log(bbox);\n *\n * // {\n * //  // The minimum coordinate along each axis.\n * //  min: { x: -1, y: -2, z: -3 },\n * //\n * //  // The maximum coordinate along each axis.\n * //  max: { x: 1, y: 2, z: 3},\n * //\n * //  // The size (length) along each axis.\n * //  size: { x: 2, y: 4, z: 6},\n * //\n * //  // The offset (center) along each axis.\n * //  offset: { x: 0, y: 0, z: 0}\n * // }\n * ```\n *\n * @returns {Object} bounding box of the geometry.\n *\n * @example\n * <div>\n * <code>\n * // Click and drag the mouse to view the scene from different angles.\n *\n * let particles;\n *\n * function setup() {\n *   createCanvas(100, 100, WEBGL);\n *\n *   // Create a new p5.Geometry object with random spheres.\n *   particles = buildGeometry(createParticles);\n *\n *   describe('Ten white spheres placed randomly against a gray background. A box encloses the spheres.');\n * }\n *\n * function draw() {\n *   background(50);\n *\n *   // Enable orbiting with the mouse.\n *   orbitControl();\n *\n *   // Turn on the lights.\n *   lights();\n *\n *   // Style the particles.\n *   noStroke();\n *   fill(255);\n *\n *   // Draw the particles.\n *   model(particles);\n *\n *   // Calculate the bounding box.\n *   let bbox = particles.calculateBoundingBox();\n *\n *   // Translate to the bounding box's center.\n *   translate(bbox.offset.x, bbox.offset.y, bbox.offset.z);\n *\n *   // Style the bounding box.\n *   stroke(255);\n *   noFill();\n *\n *   // Draw the bounding box.\n *   box(bbox.size.x, bbox.size.y, bbox.size.z);\n * }\n *\n * function createParticles() {\n *   for (let i = 0; i < 10; i += 1) {\n *     // Calculate random coordinates.\n *     let x = randomGaussian(0, 15);\n *     let y = randomGaussian(0, 15);\n *     let z = randomGaussian(0, 15);\n *\n *     push();\n *     // Translate to the particle's coordinates.\n *     translate(x, y, z);\n *     // Draw the particle.\n *     sphere(3);\n *     pop();\n *   }\n * }\n * </code>\n * </div>\n */\n  calculateBoundingBox() {\n    if (this.boundingBoxCache) {\n      return this.boundingBoxCache; // Return cached result if available\n    }\n\n    let minVertex = new Vector(\n      Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n    let maxVertex = new Vector(\n      Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE);\n\n    for (let i = 0; i < this.vertices.length; i++) {\n      let vertex = this.vertices[i];\n      minVertex.x = Math.min(minVertex.x, vertex.x);\n      minVertex.y = Math.min(minVertex.y, vertex.y);\n      minVertex.z = Math.min(minVertex.z, vertex.z);\n\n      maxVertex.x = Math.max(maxVertex.x, vertex.x);\n      maxVertex.y = Math.max(maxVertex.y, vertex.y);\n      maxVertex.z = Math.max(maxVertex.z, vertex.z);\n    }\n    // Calculate size and offset properties\n    let size = new Vector(maxVertex.x - minVertex.x,\n      maxVertex.y - minVertex.y, maxVertex.z - minVertex.z);\n    let offset = new Vector((minVertex.x + maxVertex.x) / 2,\n      (minVertex.y + maxVertex.y) / 2, (minVertex.z + maxVertex.z) / 2);\n\n    // Cache the result for future access\n    this.boundingBoxCache = {\n      min: minVertex,\n      max: maxVertex,\n      size: size,\n      offset: offset\n    };\n\n    return this.boundingBoxCache;\n  }\n\n  reset() {\n    this._hasFillTransparency = undefined;\n    this._hasStrokeTransparency = undefined;\n\n    this.lineVertices.clear();\n    this.lineTangentsIn.clear();\n    this.lineTangentsOut.clear();\n    this.lineSides.clear();\n\n    this.vertices.length = 0;\n    this.edges.length = 0;\n    this.vertexColors.length = 0;\n    this.vertexStrokeColors.length = 0;\n    this.lineVertexColors.clear();\n    this.vertexNormals.length = 0;\n    this.uvs.length = 0;\n\n    for (const propName in this.userVertexProperties){\n      this.userVertexProperties[propName].delete();\n    }\n    this.userVertexProperties = {};\n\n    this.dirtyFlags = {};\n  }\n\n  hasFillTransparency() {\n    if (this._hasFillTransparency === undefined) {\n      this._hasFillTransparency = false;\n      for (let i = 0; i < this.vertexColors.length; i += 4) {\n        if (this.vertexColors[i + 3] < 1) {\n          this._hasFillTransparency = true;\n          break;\n        }\n      }\n    }\n    return this._hasFillTransparency;\n  }\n  hasStrokeTransparency() {\n    if (this._hasStrokeTransparency === undefined) {\n      this._hasStrokeTransparency = false;\n      for (let i = 0; i < this.lineVertexColors.length; i += 4) {\n        if (this.lineVertexColors[i + 3] < 1) {\n          this._hasStrokeTransparency = true;\n          break;\n        }\n      }\n    }\n    return this._hasStrokeTransparency;\n  }\n\n  /**\n   * Removes the geometry’s internal colors.\n   *\n   * `p5.Geometry` objects can be created with \"internal colors\" assigned to\n   * vertices or the entire shape. When a geometry has internal colors,\n   * <a href=\"#/p5/fill\">fill()</a> has no effect. Calling\n   * `myGeometry.clearColors()` allows the\n   * <a href=\"#/p5/fill\">fill()</a> function to apply color to the geometry.\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   // Create a p5.Geometry object.\n   *   // Set its internal color to red.\n   *   let myGeometry = buildGeometry(function() {\n   *     fill(255, 0, 0);\n   *     plane(20);\n   *   });\n   *\n   *   // Style the shape.\n   *   noStroke();\n   *\n   *   // Draw the p5.Geometry object (center).\n   *   model(myGeometry);\n   *\n   *   // Translate the origin to the bottom-right.\n   *   translate(25, 25, 0);\n   *\n   *   // Try to fill the geometry with green.\n   *   fill(0, 255, 0);\n   *\n   *   // Draw the geometry again (bottom-right).\n   *   model(myGeometry);\n   *\n   *   // Clear the geometry's colors.\n   *   myGeometry.clearColors();\n   *\n   *   // Fill the geometry with blue.\n   *   fill(0, 0, 255);\n   *\n   *   // Translate the origin up.\n   *   translate(0, -50, 0);\n   *\n   *   // Draw the geometry again (top-right).\n   *   model(myGeometry);\n   *\n   *   describe(\n   *     'Three squares drawn against a gray background. Red squares are at the center and the bottom-right. A blue square is at the top-right.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   */\n  clearColors() {\n    this.vertexColors = [];\n    return this;\n  }\n\n  /**\n   * The `saveObj()` function exports `p5.Geometry` objects as\n   * 3D models in the Wavefront .obj file format.\n   * This way, you can use the 3D shapes you create in p5.js in other software\n   * for rendering, animation, 3D printing, or more.\n   *\n   * The exported .obj file will include the faces and vertices of the `p5.Geometry`,\n   * as well as its texture coordinates and normals, if it has them.\n   *\n   * @method saveObj\n   * @param {String} [fileName='model.obj'] The name of the file to save the model as.\n   *                                        If not specified, the default file name will be 'model.obj'.\n   * @example\n   * <div>\n   * <code>\n   * let myModel;\n   * let saveBtn;\n   * function setup() {\n   *   createCanvas(200, 200, WEBGL);\n   *   myModel = buildGeometry(function()) {\n   *     for (let i = 0; i < 5; i++) {\n   *       push();\n   *       translate(\n   *         random(-75, 75),\n   *         random(-75, 75),\n   *         random(-75, 75)\n   *       );\n   *       sphere(random(5, 50));\n   *       pop();\n   *     }\n   *   });\n   *\n   *   saveBtn = createButton('Save .obj');\n   *   saveBtn.mousePressed(() => myModel.saveObj());\n   *\n   *   describe('A few spheres rotating in space');\n   * }\n   *\n   * function draw() {\n   *   background(0);\n   *   noStroke();\n   *   lights();\n   *   rotateX(millis() * 0.001);\n   *   rotateY(millis() * 0.002);\n   *   model(myModel);\n   * }\n   * </code>\n   * </div>\n   */\n  saveObj(fileName = 'model.obj') {\n    let objStr= '';\n\n\n    // Vertices\n    this.vertices.forEach(v => {\n      objStr += `v ${v.x} ${v.y} ${v.z}\\n`;\n    });\n\n    // Texture Coordinates (UVs)\n    if (this.uvs && this.uvs.length > 0) {\n      for (let i = 0; i < this.uvs.length; i += 2) {\n        objStr += `vt ${this.uvs[i]} ${this.uvs[i + 1]}\\n`;\n      }\n    }\n\n    // Vertex Normals\n    if (this.vertexNormals && this.vertexNormals.length > 0) {\n      this.vertexNormals.forEach(n => {\n        objStr += `vn ${n.x} ${n.y} ${n.z}\\n`;\n      });\n\n    }\n    // Faces, obj vertex indices begin with 1 and not 0\n    // texture coordinate (uvs) and vertexNormal indices\n    // are indicated with trailing ints vertex/normal/uv\n    // ex 1/1/1 or 2//2 for vertices without uvs\n    this.faces.forEach(face => {\n      let faceStr = 'f';\n      face.forEach(index =>{\n        faceStr += ' ';\n        faceStr += index + 1;\n        if (this.vertexNormals.length > 0 || this.uvs.length > 0) {\n          faceStr += '/';\n          if (this.uvs.length > 0) {\n            faceStr += index + 1;\n          }\n          faceStr += '/';\n          if (this.vertexNormals.length > 0) {\n            faceStr += index + 1;\n          }\n        }\n      });\n      objStr += faceStr + '\\n';\n    });\n\n    const blob = new Blob([objStr], { type: 'text/plain' });\n    fn.downloadFile(blob, fileName , 'obj');\n\n  }\n\n  /**\n   * The `saveStl()` function exports `p5.Geometry` objects as\n   * 3D models in the STL stereolithography file format.\n   * This way, you can use the 3D shapes you create in p5.js in other software\n   * for rendering, animation, 3D printing, or more.\n   *\n   * The exported .stl file will include the faces, vertices, and normals of the `p5.Geometry`.\n   *\n   * By default, this method saves a text-based .stl file. Alternatively, you can save a more compact\n   * but less human-readable binary .stl file by passing `{ binary: true }` as a second parameter.\n   *\n   * @method saveStl\n   * @param {String} [fileName='model.stl'] The name of the file to save the model as.\n   *                                        If not specified, the default file name will be 'model.stl'.\n   * @param {Object} [options] Optional settings. Options can include a boolean `binary` property, which\n   * controls whether or not a binary .stl file is saved. It defaults to false.\n   * @example\n   * <div>\n   * <code>\n   * let myModel;\n   * let saveBtn1;\n   * let saveBtn2;\n   * function setup() {\n   *   createCanvas(200, 200, WEBGL);\n   *   myModel = buildGeometry(function() {\n   *     for (let i = 0; i < 5; i++) {\n   *       push();\n   *       translate(\n   *         random(-75, 75),\n   *         random(-75, 75),\n   *         random(-75, 75)\n   *       );\n   *       sphere(random(5, 50));\n   *       pop();\n   *     }\n   *   });\n   *\n   *   saveBtn1 = createButton('Save .stl');\n   *   saveBtn1.mousePressed(function() {\n   *     myModel.saveStl();\n   *   });\n   *   saveBtn2 = createButton('Save binary .stl');\n   *   saveBtn2.mousePressed(function() {\n   *     myModel.saveStl('model.stl', { binary: true });\n   *   });\n   *\n   *   describe('A few spheres rotating in space');\n   * }\n   *\n   * function draw() {\n   *   background(0);\n   *   noStroke();\n   *   lights();\n   *   rotateX(millis() * 0.001);\n   *   rotateY(millis() * 0.002);\n   *   model(myModel);\n   * }\n   * </code>\n   * </div>\n   */\n  saveStl(fileName = 'model.stl', { binary = false } = {}){\n    let modelOutput;\n    let name = fileName.substring(0, fileName.lastIndexOf('.'));\n    let faceNormals = [];\n    for (let f of this.faces) {\n      const U = Vector.sub(this.vertices[f[1]], this.vertices[f[0]]);\n      const V = Vector.sub(this.vertices[f[2]], this.vertices[f[0]]);\n      const nx = U.y * V.z - U.z * V.y;\n      const ny = U.z * V.x - U.x * V.z;\n      const nz = U.x * V.y - U.y * V.x;\n      faceNormals.push(new Vector(nx, ny, nz).normalize());\n    }\n    if (binary) {\n      let offset = 80;\n      const bufferLength =\n        this.faces.length * 2 + this.faces.length * 3 * 4 * 4 + 80 + 4;\n      const arrayBuffer = new ArrayBuffer(bufferLength);\n      modelOutput = new DataView(arrayBuffer);\n      modelOutput.setUint32(offset, this.faces.length, true);\n      offset += 4;\n      for (const [key, f] of Object.entries(this.faces)) {\n        const norm = faceNormals[key];\n        modelOutput.setFloat32(offset, norm.x, true);\n        offset += 4;\n        modelOutput.setFloat32(offset, norm.y, true);\n        offset += 4;\n        modelOutput.setFloat32(offset, norm.z, true);\n        offset += 4;\n        for (let vertexIndex of f) {\n          const vert = this.vertices[vertexIndex];\n          modelOutput.setFloat32(offset, vert.x, true);\n          offset += 4;\n          modelOutput.setFloat32(offset, vert.y, true);\n          offset += 4;\n          modelOutput.setFloat32(offset, vert.z, true);\n          offset += 4;\n        }\n        modelOutput.setUint16(offset, 0, true);\n        offset += 2;\n      }\n    } else {\n      modelOutput = 'solid ' + name + '\\n';\n\n      for (const [key, f] of Object.entries(this.faces)) {\n        const norm = faceNormals[key];\n        modelOutput +=\n          ' facet norm ' + norm.x + ' ' + norm.y + ' ' + norm.z + '\\n';\n        modelOutput += '  outer loop' + '\\n';\n        for (let vertexIndex of f) {\n          const vert = this.vertices[vertexIndex];\n          modelOutput +=\n            '   vertex ' + vert.x + ' ' + vert.y + ' ' + vert.z + '\\n';\n        }\n        modelOutput += '  endloop' + '\\n';\n        modelOutput += ' endfacet' + '\\n';\n      }\n      modelOutput += 'endsolid ' + name + '\\n';\n    }\n    const blob = new Blob([modelOutput], { type: 'text/plain' });\n    fn.downloadFile(blob, fileName, 'stl');\n  }\n\n  /**\n   * Flips the geometry’s texture u-coordinates.\n   *\n   * In order for <a href=\"#/p5/texture\">texture()</a> to work, the geometry\n   * needs a way to map the points on its surface to the pixels in a rectangular\n   * image that's used as a texture. The geometry's vertex at coordinates\n   * `(x, y, z)` maps to the texture image's pixel at coordinates `(u, v)`.\n   *\n   * The <a href=\"#/p5.Geometry/uvs\">myGeometry.uvs</a> array stores the\n   * `(u, v)` coordinates for each vertex in the order it was added to the\n   * geometry. Calling `myGeometry.flipU()` flips a geometry's u-coordinates\n   * so that the texture appears mirrored horizontally.\n   *\n   * For example, a plane's four vertices are added clockwise starting from the\n   * top-left corner. Here's how calling `myGeometry.flipU()` would change a\n   * plane's texture coordinates:\n   *\n   * ```js\n   * // Print the original texture coordinates.\n   * // Output: [0, 0, 1, 0, 0, 1, 1, 1]\n   * console.log(myGeometry.uvs);\n   *\n   * // Flip the u-coordinates.\n   * myGeometry.flipU();\n   *\n   * // Print the flipped texture coordinates.\n   * // Output: [1, 0, 0, 0, 1, 1, 0, 1]\n   * console.log(myGeometry.uvs);\n   *\n   * // Notice the swaps:\n   * // Top vertices: [0, 0, 1, 0] --> [1, 0, 0, 0]\n   * // Bottom vertices: [0, 1, 1, 1] --> [1, 1, 0, 1]\n   * ```\n   *\n   * @for p5.Geometry\n   *\n   * @example\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   img = await loadImage('assets/laDefense.jpg');\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   // Create p5.Geometry objects.\n   *   let geom1 = buildGeometry(createShape);\n   *   let geom2 = buildGeometry(createShape);\n   *\n   *   // Flip geom2's U texture coordinates.\n   *   geom2.flipU();\n   *\n   *   // Left (original).\n   *   push();\n   *   translate(-25, 0, 0);\n   *   texture(img);\n   *   noStroke();\n   *   model(geom1);\n   *   pop();\n   *\n   *   // Right (flipped).\n   *   push();\n   *   translate(25, 0, 0);\n   *   texture(img);\n   *   noStroke();\n   *   model(geom2);\n   *   pop();\n   *\n   *   describe(\n   *     'Two photos of a ceiling on a gray background. The photos are mirror images of each other.'\n   *   );\n   * }\n   *\n   * function createShape() {\n   *   plane(40);\n   * }\n   * </code>\n   * </div>\n   */\n  flipU() {\n    this.uvs = this.uvs.flat().map((val, index) => {\n      if (index % 2 === 0) {\n        return 1 - val;\n      } else {\n        return val;\n      }\n    });\n  }\n\n  /**\n   * Flips the geometry’s texture v-coordinates.\n   *\n   * In order for <a href=\"#/p5/texture\">texture()</a> to work, the geometry\n   * needs a way to map the points on its surface to the pixels in a rectangular\n   * image that's used as a texture. The geometry's vertex at coordinates\n   * `(x, y, z)` maps to the texture image's pixel at coordinates `(u, v)`.\n   *\n   * The <a href=\"#/p5.Geometry/uvs\">myGeometry.uvs</a> array stores the\n   * `(u, v)` coordinates for each vertex in the order it was added to the\n   * geometry. Calling `myGeometry.flipV()` flips a geometry's v-coordinates\n   * so that the texture appears mirrored vertically.\n   *\n   * For example, a plane's four vertices are added clockwise starting from the\n   * top-left corner. Here's how calling `myGeometry.flipV()` would change a\n   * plane's texture coordinates:\n   *\n   * ```js\n   * // Print the original texture coordinates.\n   * // Output: [0, 0, 1, 0, 0, 1, 1, 1]\n   * console.log(myGeometry.uvs);\n   *\n   * // Flip the v-coordinates.\n   * myGeometry.flipV();\n   *\n   * // Print the flipped texture coordinates.\n   * // Output: [0, 1, 1, 1, 0, 0, 1, 0]\n   * console.log(myGeometry.uvs);\n   *\n   * // Notice the swaps:\n   * // Left vertices: [0, 0] <--> [1, 0]\n   * // Right vertices: [1, 0] <--> [1, 1]\n   * ```\n   *\n   * @method flipV\n   * @for p5.Geometry\n   *\n   * @example\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   img = await loadImage('assets/laDefense.jpg');\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   // Create p5.Geometry objects.\n   *   let geom1 = buildGeometry(createShape);\n   *   let geom2 = buildGeometry(createShape);\n   *\n   *   // Flip geom2's V texture coordinates.\n   *   geom2.flipV();\n   *\n   *   // Left (original).\n   *   push();\n   *   translate(-25, 0, 0);\n   *   texture(img);\n   *   noStroke();\n   *   model(geom1);\n   *   pop();\n   *\n   *   // Right (flipped).\n   *   push();\n   *   translate(25, 0, 0);\n   *   texture(img);\n   *   noStroke();\n   *   model(geom2);\n   *   pop();\n   *\n   *   describe(\n   *     'Two photos of a ceiling on a gray background. The photos are mirror images of each other.'\n   *   );\n   * }\n   *\n   * function createShape() {\n   *   plane(40);\n   * }\n   * </code>\n   * </div>\n   */\n  flipV() {\n    this.uvs = this.uvs.flat().map((val, index) => {\n      if (index % 2 === 0) {\n        return val;\n      } else {\n        return 1 - val;\n      }\n    });\n  }\n\n  /**\n   * Computes the geometry's faces using its vertices.\n   *\n   * All 3D shapes are made by connecting sets of points called *vertices*. A\n   * geometry's surface is formed by connecting vertices to form triangles that\n   * are stitched together. Each triangular patch on the geometry's surface is\n   * called a *face*. `myGeometry.computeFaces()` performs the math needed to\n   * define each face based on the distances between vertices.\n   *\n   * The geometry's vertices are stored as <a href=\"#/p5.Vector\">p5.Vector</a>\n   * objects in the <a href=\"#/p5.Geometry/vertices\">myGeometry.vertices</a>\n   * array. The geometry's first vertex is the\n   * <a href=\"#/p5.Vector\">p5.Vector</a> object at `myGeometry.vertices[0]`,\n   * its second vertex is `myGeometry.vertices[1]`, its third vertex is\n   * `myGeometry.vertices[2]`, and so on.\n   *\n   * Calling `myGeometry.computeFaces()` fills the\n   * <a href=\"#/p5.Geometry/faces\">myGeometry.faces</a> array with three-element\n   * arrays that list the vertices that form each face. For example, a geometry\n   * made from a rectangle has two faces because a rectangle is made by joining\n   * two triangles. <a href=\"#/p5.Geometry/faces\">myGeometry.faces</a> for a\n   * rectangle would be the two-dimensional array\n   * `[[0, 1, 2], [2, 1, 3]]`. The first face, `myGeometry.faces[0]`, is the\n   * array `[0, 1, 2]` because it's formed by connecting\n   * `myGeometry.vertices[0]`, `myGeometry.vertices[1]`,and\n   * `myGeometry.vertices[2]`. The second face, `myGeometry.faces[1]`, is the\n   * array `[2, 1, 3]` because it's formed by connecting\n   * `myGeometry.vertices[2]`, `myGeometry.vertices[1]`, and\n   * `myGeometry.vertices[3]`.\n   *\n   * Note: `myGeometry.computeFaces()` only works when geometries have four or more vertices.\n   *\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object.\n   *   myGeometry = new p5.Geometry();\n   *\n   *   // Create p5.Vector objects to position the vertices.\n   *   let v0 = createVector(-40, 0, 0);\n   *   let v1 = createVector(0, -40, 0);\n   *   let v2 = createVector(0, 40, 0);\n   *   let v3 = createVector(40, 0, 0);\n   *\n   *   // Add the vertices to myGeometry's vertices array.\n   *   myGeometry.vertices.push(v0, v1, v2, v3);\n   *\n   *   // Compute myGeometry's faces array.\n   *   myGeometry.computeFaces();\n   *\n   *   describe('A red square drawn on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Style the shape.\n   *   noStroke();\n   *   fill(255, 0, 0);\n   *\n   *   // Draw the p5.Geometry object.\n   *   model(myGeometry);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object using a callback function.\n   *   myGeometry = new p5.Geometry(1, 1, createShape);\n   *\n   *   describe('A red square drawn on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Style the shape.\n   *   noStroke();\n   *   fill(255, 0, 0);\n   *\n   *   // Draw the p5.Geometry object.\n   *   model(myGeometry);\n   * }\n   *\n   * function createShape() {\n   *   // Create p5.Vector objects to position the vertices.\n   *   let v0 = createVector(-40, 0, 0);\n   *   let v1 = createVector(0, -40, 0);\n   *   let v2 = createVector(0, 40, 0);\n   *   let v3 = createVector(40, 0, 0);\n   *\n   *   // Add the vertices to the p5.Geometry object's vertices array.\n   *   this.vertices.push(v0, v1, v2, v3);\n   *\n   *   // Compute the faces array.\n   *   this.computeFaces();\n   * }\n   * </code>\n   * </div>\n   */\n  computeFaces() {\n    this.faces.length = 0;\n    const sliceCount = this.detailX + 1;\n    let a, b, c, d;\n    for (let i = 0; i < this.detailY; i++) {\n      for (let j = 0; j < this.detailX; j++) {\n        a = i * sliceCount + j; // + offset;\n        b = i * sliceCount + j + 1; // + offset;\n        c = (i + 1) * sliceCount + j + 1; // + offset;\n        d = (i + 1) * sliceCount + j; // + offset;\n        this.faces.push([a, b, d]);\n        this.faces.push([d, b, c]);\n      }\n    }\n    return this;\n  }\n\n  _getFaceNormal(faceId) {\n    //This assumes that vA->vB->vC is a counter-clockwise ordering\n    const face = this.faces[faceId];\n    const vA = this.vertices[face[0]];\n    const vB = this.vertices[face[1]];\n    const vC = this.vertices[face[2]];\n    const ab = Vector.sub(vB, vA);\n    const ac = Vector.sub(vC, vA);\n    const n = Vector.cross(ab, ac);\n    const ln = Vector.mag(n);\n    let sinAlpha = ln / (Vector.mag(ab) * Vector.mag(ac));\n    if (sinAlpha === 0 || isNaN(sinAlpha)) {\n      console.warn(\n        'p5.Geometry.prototype._getFaceNormal:',\n        'face has colinear sides or a repeated vertex'\n      );\n      return n;\n    }\n    if (sinAlpha > 1) sinAlpha = 1; // handle float rounding error\n    return n.mult(Math.asin(sinAlpha) / ln);\n  }\n  /**\n   * Calculates the normal vector for each vertex on the geometry.\n   *\n   * All 3D shapes are made by connecting sets of points called *vertices*. A\n   * geometry's surface is formed by connecting vertices to create triangles\n   * that are stitched together. Each triangular patch on the geometry's\n   * surface is called a *face*. `myGeometry.computeNormals()` performs the\n   * math needed to orient each face. Orientation is important for lighting\n   * and other effects.\n   *\n   * A face's orientation is defined by its *normal vector* which points out\n   * of the face and is normal (perpendicular) to the surface. Calling\n   * `myGeometry.computeNormals()` first calculates each face's normal vector.\n   * Then it calculates the normal vector for each vertex by averaging the\n   * normal vectors of the faces surrounding the vertex. The vertex normals\n   * are stored as <a href=\"#/p5.Vector\">p5.Vector</a> objects in the\n   * <a href=\"#/p5.Geometry/vertexNormals\">myGeometry.vertexNormals</a> array.\n   *\n   * The first parameter, `shadingType`, is optional. Passing the constant\n   * `FLAT`, as in `myGeometry.computeNormals(FLAT)`, provides neighboring\n   * faces with their own copies of the vertices they share. Surfaces appear\n   * tiled with flat shading. Passing the constant `SMOOTH`, as in\n   * `myGeometry.computeNormals(SMOOTH)`, makes neighboring faces reuse their\n   * shared vertices. Surfaces appear smoother with smooth shading. By\n   * default, `shadingType` is `FLAT`.\n   *\n   * The second parameter, `options`, is also optional. If an object with a\n   * `roundToPrecision` property is passed, as in\n   * `myGeometry.computeNormals(SMOOTH, { roundToPrecision: 5 })`, it sets the\n   * number of decimal places to use for calculations. By default,\n   * `roundToPrecision` uses 3 decimal places.\n   *\n   * @param {(FLAT|SMOOTH)} [shadingType=FLAT] shading type. either FLAT or SMOOTH. Defaults to `FLAT`.\n   * @param {Object} [options] shading options.\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object.\n   *   myGeometry = buildGeometry(function() {\n   *     torus();\n   *   });\n   *\n   *   // Compute the vertex normals.\n   *   myGeometry.computeNormals();\n   *\n   *   describe(\n   *     \"A white torus drawn on a dark gray background. Red lines extend outward from the torus' vertices.\"\n   *   );\n   * }\n   *\n   * function draw() {\n   *   background(50);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Rotate the coordinate system.\n   *   rotateX(1);\n   *\n   *   // Style the helix.\n   *   stroke(0);\n   *\n   *   // Display the helix.\n   *   model(myGeometry);\n   *\n   *   // Style the normal vectors.\n   *   stroke(255, 0, 0);\n   *\n   *   // Iterate over the vertices and vertexNormals arrays.\n   *   for (let i = 0; i < myGeometry.vertices.length; i += 1) {\n   *\n   *     // Get the vertex p5.Vector object.\n   *     let v = myGeometry.vertices[i];\n   *\n   *     // Get the vertex normal p5.Vector object.\n   *     let n = myGeometry.vertexNormals[i];\n   *\n   *     // Calculate a point along the vertex normal.\n   *     let p = p5.Vector.mult(n, 5);\n   *\n   *     // Draw the vertex normal as a red line.\n   *     push();\n   *     translate(v);\n   *     line(0, 0, 0, p.x, p.y, p.z);\n   *     pop();\n   *   }\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object using a callback function.\n   *   myGeometry = new p5.Geometry();\n   *\n   *   // Create p5.Vector objects to position the vertices.\n   *   let v0 = createVector(-40, 0, 0);\n   *   let v1 = createVector(0, -40, 0);\n   *   let v2 = createVector(0, 40, 0);\n   *   let v3 = createVector(40, 0, 0);\n   *\n   *   // Add the vertices to the p5.Geometry object's vertices array.\n   *   myGeometry.vertices.push(v0, v1, v2, v3);\n   *\n   *   // Compute the faces array.\n   *   myGeometry.computeFaces();\n   *\n   *   // Compute the surface normals.\n   *   myGeometry.computeNormals();\n   *\n   *   describe('A red square drawn on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Add a white point light.\n   *   pointLight(255, 255, 255, 0, 0, 10);\n   *\n   *   // Style the p5.Geometry object.\n   *   noStroke();\n   *   fill(255, 0, 0);\n   *\n   *   // Draw the p5.Geometry object.\n   *   model(myGeometry);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object.\n   *   myGeometry = buildGeometry(createShape);\n   *\n   *   // Compute normals using default (FLAT) shading.\n   *   myGeometry.computeNormals(FLAT);\n   *\n   *   describe('A white, helical structure drawn on a dark gray background. Its faces appear faceted.');\n   * }\n   *\n   * function draw() {\n   *   background(50);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Rotate the coordinate system.\n   *   rotateX(1);\n   *\n   *   // Style the helix.\n   *   noStroke();\n   *\n   *   // Display the helix.\n   *   model(myGeometry);\n   * }\n   *\n   * function createShape() {\n   *   // Create a helical shape.\n   *   beginShape();\n   *   for (let i = 0; i < TWO_PI * 3; i += 0.5) {\n   *     let x = 30 * cos(i);\n   *     let y = 30 * sin(i);\n   *     let z = map(i, 0, TWO_PI * 3, -40, 40);\n   *     vertex(x, y, z);\n   *   }\n   *   endShape();\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object.\n   *   myGeometry = buildGeometry(createShape);\n   *\n   *   // Compute normals using smooth shading.\n   *   myGeometry.computeNormals(SMOOTH);\n   *\n   *   describe('A white, helical structure drawn on a dark gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(50);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Rotate the coordinate system.\n   *   rotateX(1);\n   *\n   *   // Style the helix.\n   *   noStroke();\n   *\n   *   // Display the helix.\n   *   model(myGeometry);\n   * }\n   *\n   * function createShape() {\n   *   // Create a helical shape.\n   *   beginShape();\n   *   for (let i = 0; i < TWO_PI * 3; i += 0.5) {\n   *     let x = 30 * cos(i);\n   *     let y = 30 * sin(i);\n   *     let z = map(i, 0, TWO_PI * 3, -40, 40);\n   *     vertex(x, y, z);\n   *   }\n   *   endShape();\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object.\n   *   myGeometry = buildGeometry(createShape);\n   *\n   *   // Create an options object.\n   *   let options = { roundToPrecision: 5 };\n   *\n   *   // Compute normals using smooth shading.\n   *   myGeometry.computeNormals(SMOOTH, options);\n   *\n   *   describe('A white, helical structure drawn on a dark gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(50);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Rotate the coordinate system.\n   *   rotateX(1);\n   *\n   *   // Style the helix.\n   *   noStroke();\n   *\n   *   // Display the helix.\n   *   model(myGeometry);\n   * }\n   *\n   * function createShape() {\n   *   // Create a helical shape.\n   *   beginShape();\n   *   for (let i = 0; i < TWO_PI * 3; i += 0.5) {\n   *     let x = 30 * cos(i);\n   *     let y = 30 * sin(i);\n   *     let z = map(i, 0, TWO_PI * 3, -40, 40);\n   *     vertex(x, y, z);\n   *   }\n   *   endShape();\n   * }\n   * </code>\n   * </div>\n   */\n  computeNormals(shadingType = FLAT, { roundToPrecision = 3 } = {}) {\n    const vertexNormals = this.vertexNormals;\n    let vertices = this.vertices;\n    const faces = this.faces;\n    let iv;\n\n    if (shadingType === SMOOTH) {\n      const vertexIndices = {};\n      const uniqueVertices = [];\n\n      const power = Math.pow(10, roundToPrecision);\n      const rounded = val => Math.round(val * power) / power;\n      const getKey = vert =>\n        `${rounded(vert.x)},${rounded(vert.y)},${rounded(vert.z)}`;\n\n      // loop through each vertex and add uniqueVertices\n      for (let i = 0; i < vertices.length; i++) {\n        const vertex = vertices[i];\n        const key = getKey(vertex);\n        if (vertexIndices[key] === undefined) {\n          vertexIndices[key] = uniqueVertices.length;\n          uniqueVertices.push(vertex);\n        }\n      }\n\n      // update face indices to use the deduplicated vertex indices\n      faces.forEach(face => {\n        for (let fv = 0; fv < 3; ++fv) {\n          const originalVertexIndex = face[fv];\n          const originalVertex = vertices[originalVertexIndex];\n          const key = getKey(originalVertex);\n          face[fv] = vertexIndices[key];\n        }\n      });\n\n      // update edge indices to use the deduplicated vertex indices\n      this.edges.forEach(edge => {\n        for (let ev = 0; ev < 2; ++ev) {\n          const originalVertexIndex = edge[ev];\n          const originalVertex = vertices[originalVertexIndex];\n          const key = getKey(originalVertex);\n          edge[ev] = vertexIndices[key];\n        }\n      });\n\n      // update the deduplicated vertices\n      this.vertices = vertices = uniqueVertices;\n    }\n\n    // initialize the vertexNormals array with empty vectors\n    vertexNormals.length = 0;\n    for (iv = 0; iv < vertices.length; ++iv) {\n      vertexNormals.push(new Vector());\n    }\n\n    // loop through all the faces adding its normal to the normal\n    // of each of its vertices\n    faces.forEach((face, f) => {\n      const faceNormal = this._getFaceNormal(f);\n\n      // all three vertices get the normal added\n      for (let fv = 0; fv < 3; ++fv) {\n        const vertexIndex = face[fv];\n        vertexNormals[vertexIndex].add(faceNormal);\n      }\n    });\n\n    // normalize the normals\n    for (iv = 0; iv < vertices.length; ++iv) {\n      vertexNormals[iv].normalize();\n    }\n\n    return this;\n  }\n\n  /**\n   * Averages the vertex normals. Used in curved\n   * surfaces\n   * @private\n   * @chainable\n   */\n  averageNormals() {\n    for (let i = 0; i <= this.detailY; i++) {\n      const offset = this.detailX + 1;\n      let temp = Vector.add(\n        this.vertexNormals[i * offset],\n        this.vertexNormals[i * offset + this.detailX]\n      );\n\n      temp = Vector.div(temp, 2);\n      this.vertexNormals[i * offset] = temp;\n      this.vertexNormals[i * offset + this.detailX] = temp;\n    }\n    return this;\n  }\n\n  /**\n   * Averages pole normals.  Used in spherical primitives\n   * @private\n   * @chainable\n   */\n  averagePoleNormals() {\n    //average the north pole\n    let sum = new Vector(0, 0, 0);\n    for (let i = 0; i < this.detailX; i++) {\n      sum.add(this.vertexNormals[i]);\n    }\n    sum = Vector.div(sum, this.detailX);\n\n    for (let i = 0; i < this.detailX; i++) {\n      this.vertexNormals[i] = sum;\n    }\n\n    //average the south pole\n    sum = new Vector(0, 0, 0);\n    for (\n      let i = this.vertices.length - 1;\n      i > this.vertices.length - 1 - this.detailX;\n      i--\n    ) {\n      sum.add(this.vertexNormals[i]);\n    }\n    sum = Vector.div(sum, this.detailX);\n\n    for (\n      let i = this.vertices.length - 1;\n      i > this.vertices.length - 1 - this.detailX;\n      i--\n    ) {\n      this.vertexNormals[i] = sum;\n    }\n    return this;\n  }\n\n  /**\n   * Create a 2D array for establishing stroke connections\n   * @private\n   * @chainable\n   */\n  _makeTriangleEdges() {\n    this.edges.length = 0;\n\n    for (let j = 0; j < this.faces.length; j++) {\n      this.edges.push([this.faces[j][0], this.faces[j][1]]);\n      this.edges.push([this.faces[j][1], this.faces[j][2]]);\n      this.edges.push([this.faces[j][2], this.faces[j][0]]);\n    }\n\n    return this;\n  }\n\n  /**\n   * @example\n   * <div>\n   * <code>\n   * let tetrahedron;\n   * function setup() {\n   *   createCanvas(200, 200, WEBGL);\n   *   describe('A rotating tetrahedron');\n   *\n   *   tetrahedron = new p5.Geometry();\n   *\n   *   // Give each geometry a unique gid\n   *   tetrahedron.gid = 'tetrahedron';\n   *\n   *   // Add four points of the tetrahedron\n   *\n   *   let radius = 50;\n   *   // A 2D triangle:\n   *   tetrahedron.vertices.push(createVector(radius, 0, 0));\n   *   tetrahedron.vertices.push(createVector(radius, 0, 0).rotate(TWO_PI / 3));\n   *   tetrahedron.vertices.push(createVector(radius, 0, 0).rotate(TWO_PI * 2 / 3));\n   *   // Add a tip in the z axis:\n   *   tetrahedron.vertices.push(createVector(0, 0, radius));\n   *\n   *   // Create the four faces by connecting the sets of three points\n   *   tetrahedron.faces.push([0, 1, 2]);\n   *   tetrahedron.faces.push([0, 1, 3]);\n   *   tetrahedron.faces.push([0, 2, 3]);\n   *   tetrahedron.faces.push([1, 2, 3]);\n   *   tetrahedron.makeEdgesFromFaces();\n   * }\n   * function draw() {\n   *   background(200);\n   *   strokeWeight(2);\n   *   orbitControl();\n   *   rotateY(millis() * 0.001);\n   *   model(tetrahedron);\n   * }\n   * </code>\n   * </div>\n   */\n  makeEdgesFromFaces() {\n    this._makeTriangleEdges();\n  }\n\n  /**\n   * Converts each line segment into the vertices and vertex attributes needed\n   * to turn the line into a polygon on screen. This will include:\n   * - Two triangles line segment to create a rectangle\n   * - Two triangles per endpoint to create a stroke cap rectangle. A fragment\n   *   shader is responsible for displaying the appropriate cap style within\n   *   that rectangle.\n   * - Four triangles per join between adjacent line segments, creating a quad on\n   *   either side of the join, perpendicular to the lines. A vertex shader will\n   *   discard the quad in the \"elbow\" of the join, and a fragment shader will\n   *   display the appropriate join style within the remaining quad.\n   *\n   * @private\n   * @chainable\n   */\n  _edgesToVertices() {\n    this.lineVertices.clear();\n    this.lineTangentsIn.clear();\n    this.lineTangentsOut.clear();\n    this.lineSides.clear();\n\n    const potentialCaps = new Map();\n    const connected = new Set();\n    let lastValidDir;\n    for (let i = 0; i < this.edges.length; i++) {\n      const prevEdge = this.edges[i - 1];\n      const currEdge = this.edges[i];\n      const begin = this.vertices[currEdge[0]];\n      const end = this.vertices[currEdge[1]];\n      const prevColor = (this.vertexStrokeColors.length > 0 && prevEdge)\n        ? this.vertexStrokeColors.slice(\n          prevEdge[1] * 4,\n          (prevEdge[1] + 1) * 4\n        )\n        : [0, 0, 0, 0];\n      const fromColor = this.vertexStrokeColors.length > 0\n        ? this.vertexStrokeColors.slice(\n          currEdge[0] * 4,\n          (currEdge[0] + 1) * 4\n        )\n        : [0, 0, 0, 0];\n      const toColor = this.vertexStrokeColors.length > 0\n        ? this.vertexStrokeColors.slice(\n          currEdge[1] * 4,\n          (currEdge[1] + 1) * 4\n        )\n        : [0, 0, 0, 0];\n      const dir = end\n        .copy()\n        .sub(begin)\n        .normalize();\n      const dirOK = dir.magSq() > 0;\n      if (dirOK) {\n        this._addSegment(begin, end, fromColor, toColor, dir);\n      }\n      if (!this.renderer?._simpleLines) {\n        if (i > 0 && prevEdge[1] === currEdge[0]) {\n          if (!connected.has(currEdge[0])) {\n            connected.add(currEdge[0]);\n            potentialCaps.delete(currEdge[0]);\n            // Add a join if this segment shares a vertex with the previous. Skip\n            // actually adding join vertices if either the previous segment or this\n            // one has a length of 0.\n            //\n            // Don't add a join if the tangents point in the same direction, which\n            // would mean the edges line up exactly, and there is no need for a join.\n            if (lastValidDir && dirOK && dir.dot(lastValidDir) < 1 - 1e-8) {\n              this._addJoin(begin, lastValidDir, dir, fromColor);\n            }\n          }\n        } else {\n          // Start a new line\n          if (dirOK && !connected.has(currEdge[0])) {\n            const existingCap = potentialCaps.get(currEdge[0]);\n            if (existingCap) {\n              this._addJoin(\n                begin,\n                existingCap.dir,\n                dir,\n                fromColor\n              );\n              potentialCaps.delete(currEdge[0]);\n              connected.add(currEdge[0]);\n            } else {\n              potentialCaps.set(currEdge[0], {\n                point: begin,\n                dir: dir.copy().mult(-1),\n                color: fromColor\n              });\n            }\n          }\n          if (lastValidDir && !connected.has(prevEdge[1])) {\n            const existingCap = potentialCaps.get(prevEdge[1]);\n            if (existingCap) {\n              this._addJoin(\n                this.vertices[prevEdge[1]],\n                lastValidDir,\n                existingCap.dir.copy().mult(-1),\n                prevColor\n              );\n              potentialCaps.delete(prevEdge[1]);\n              connected.add(prevEdge[1]);\n            } else {\n              // Close off the last segment with a cap\n              potentialCaps.set(prevEdge[1], {\n                point: this.vertices[prevEdge[1]],\n                dir: lastValidDir,\n                color: prevColor\n              });\n            }\n            lastValidDir = undefined;\n          }\n        }\n\n        if (i === this.edges.length - 1 && !connected.has(currEdge[1])) {\n          const existingCap = potentialCaps.get(currEdge[1]);\n          if (existingCap) {\n            this._addJoin(\n              end,\n              dir,\n              existingCap.dir.copy().mult(-1),\n              toColor\n            );\n            potentialCaps.delete(currEdge[1]);\n            connected.add(currEdge[1]);\n          } else {\n            potentialCaps.set(currEdge[1], {\n              point: end,\n              dir,\n              color: toColor\n            });\n          }\n        }\n\n        if (dirOK) {\n          lastValidDir = dir;\n        }\n      }\n    }\n    for (const { point, dir, color } of potentialCaps.values()) {\n      this._addCap(point, dir, color);\n    }\n    return this;\n  }\n\n  /**\n   * Adds the vertices and vertex attributes for two triangles making a rectangle\n   * for a straight line segment. A vertex shader is responsible for picking\n   * proper coordinates on the screen given the centerline positions, the tangent,\n   * and the side of the centerline each vertex belongs to. Sides follow the\n   * following scheme:\n   *\n   *  -1            -1\n   *   o-------------o\n   *   |             |\n   *   o-------------o\n   *   1             1\n   *\n   * @private\n   * @chainable\n   */\n  _addSegment(\n    begin,\n    end,\n    fromColor,\n    toColor,\n    dir\n  ) {\n    const a = begin.array();\n    const b = end.array();\n    const dirArr = dir.array();\n    this.lineSides.push(1, 1, -1, 1, -1, -1);\n    for (const tangents of [this.lineTangentsIn, this.lineTangentsOut]) {\n      for (let i = 0; i < 6; i++) {\n        tangents.push(...dirArr);\n      }\n    }\n    this.lineVertices.push(...a, ...b, ...a, ...b, ...b, ...a);\n    if (!this.renderer?._simpleLines) {\n      this.lineVertexColors.push(\n        ...fromColor,\n        ...toColor,\n        ...fromColor,\n        ...toColor,\n        ...toColor,\n        ...fromColor\n      );\n    }\n    return this;\n  }\n\n  /**\n   * Adds the vertices and vertex attributes for two triangles representing the\n   * stroke cap of a line. A fragment shader is responsible for displaying the\n   * appropriate cap style within the rectangle they make.\n   *\n   * The lineSides buffer will include the following values for the points on\n   * the cap rectangle:\n   *\n   *           -1  -2\n   * -----------o---o\n   *            |   |\n   * -----------o---o\n   *            1   2\n   * @private\n   * @chainable\n   */\n  _addCap(point, tangent, color) {\n    const ptArray = point.array();\n    const tanInArray = tangent.array();\n    const tanOutArray = [0, 0, 0];\n    for (let i = 0; i < 6; i++) {\n      this.lineVertices.push(...ptArray);\n      this.lineTangentsIn.push(...tanInArray);\n      this.lineTangentsOut.push(...tanOutArray);\n      this.lineVertexColors.push(...color);\n    }\n    this.lineSides.push(-1, 2, -2, 1, 2, -1);\n    return this;\n  }\n\n  /**\n   * Adds the vertices and vertex attributes for four triangles representing a\n   * join between two adjacent line segments. This creates a quad on either side\n   * of the shared vertex of the two line segments, with each quad perpendicular\n   * to the lines. A vertex shader will discard all but the quad in the \"elbow\" of\n   * the join, and a fragment shader will display the appropriate join style\n   * within the remaining quad.\n   *\n   * The lineSides buffer will include the following values for the points on\n   * the join rectangles:\n   *\n   *            -1     -2\n   * -------------o----o\n   *              |    |\n   *       1 o----o----o -3\n   *         |    | 0  |\n   * --------o----o    |\n   *        2|    3    |\n   *         |         |\n   *         |         |\n   * @private\n   * @chainable\n   */\n  _addJoin(\n    point,\n    fromTangent,\n    toTangent,\n    color\n  ) {\n    const ptArray = point.array();\n    const tanInArray = fromTangent.array();\n    const tanOutArray = toTangent.array();\n    for (let i = 0; i < 12; i++) {\n      this.lineVertices.push(...ptArray);\n      this.lineTangentsIn.push(...tanInArray);\n      this.lineTangentsOut.push(...tanOutArray);\n      this.lineVertexColors.push(...color);\n    }\n    this.lineSides.push(-1, -3, -2, -1, 0, -3);\n    this.lineSides.push(3, 1, 2, 3, 0, 1);\n    return this;\n  }\n\n  /**\n   * Transforms the geometry's vertices to fit snugly within a 100×100×100 box\n   * centered at the origin.\n   *\n   * Calling `myGeometry.normalize()` translates the geometry's vertices so that\n   * they're centered at the origin `(0, 0, 0)`. Then it scales the vertices so\n   * that they fill a 100×100×100 box. As a result, small geometries will grow\n   * and large geometries will shrink.\n   *\n   * Note: `myGeometry.normalize()` only works when called in the\n   * <a href=\"#/p5/setup\">setup()</a> function.\n   *\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a very small torus.\n   *   myGeometry = buildGeometry(function() {;\n   *     torus(1, 0.25);\n   *   });\n   *\n   *   // Normalize the torus so its vertices fill\n   *   // the range [-100, 100].\n   *   myGeometry.normalize();\n   *\n   *   describe('A white torus rotates slowly against a dark gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(50);\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Rotate around the y-axis.\n   *   rotateY(frameCount * 0.01);\n   *\n   *   // Style the torus.\n   *   noStroke();\n   *\n   *   // Draw the torus.\n   *   model(myGeometry);\n   * }\n   * </code>\n   * </div>\n   */\n  normalize() {\n    if (this.vertices.length > 0) {\n      // Find the corners of our bounding box\n      const maxPosition = this.vertices[0].copy();\n      const minPosition = this.vertices[0].copy();\n\n      for (let i = 0; i < this.vertices.length; i++) {\n        maxPosition.x = Math.max(maxPosition.x, this.vertices[i].x);\n        minPosition.x = Math.min(minPosition.x, this.vertices[i].x);\n        maxPosition.y = Math.max(maxPosition.y, this.vertices[i].y);\n        minPosition.y = Math.min(minPosition.y, this.vertices[i].y);\n        maxPosition.z = Math.max(maxPosition.z, this.vertices[i].z);\n        minPosition.z = Math.min(minPosition.z, this.vertices[i].z);\n      }\n\n      const center = Vector.lerp(maxPosition, minPosition, 0.5);\n      const dist = Vector.sub(maxPosition, minPosition);\n      const longestDist = Math.max(Math.max(dist.x, dist.y), dist.z);\n      const scale = 200 / longestDist;\n\n      for (let i = 0; i < this.vertices.length; i++) {\n        this.vertices[i].sub(center);\n        this.vertices[i].mult(scale);\n      }\n    }\n    return this;\n  }\n\n  /** Sets the shader's vertex property or attribute variables.\n   *\n   * A vertex property, or vertex attribute, is a variable belonging to a vertex in a shader. p5.js provides some\n   * default properties, such as `aPosition`, `aNormal`, `aVertexColor`, etc. These are\n   * set using <a href=\"#/p5/vertex\">vertex()</a>, <a href=\"#/p5/normal\">normal()</a>\n   * and <a href=\"#/p5/fill\">fill()</a> respectively. Custom properties can also\n   * be defined within <a href=\"#/p5/beginShape\">beginShape()</a> and\n   * <a href=\"#/p5/endShape\">endShape()</a>.\n   *\n   * The first parameter, `propertyName`, is a string with the property's name.\n   * This is the same variable name which should be declared in the shader, as in\n   * `in vec3 aProperty`, similar to .`setUniform()`.\n   *\n   * The second parameter, `data`, is the value assigned to the shader variable. This value\n   * will be pushed directly onto the Geometry object. There should be the same number\n   * of custom property values as vertices, this method should be invoked once for each\n   * vertex.\n   *\n   * The `data` can be a Number or an array of numbers. Tn the shader program the type\n   * can be declared according to the WebGL specification. Common types include `float`,\n   * `vec2`, `vec3`, `vec4` or matrices.\n   *\n   * See also the global <a href=\"#/p5/vertexProperty\">vertexProperty()</a> function.\n   *\n   * @example\n   * <div>\n   * <code>\n   * let geo;\n   *\n   * function cartesianToSpherical(x, y, z) {\n   *   let r = sqrt(pow(x, 2) + pow(y, 2) + pow(z, 2));\n   *   let theta = acos(z / r);\n   *   let phi = atan2(y, x);\n   *   return { theta, phi };\n   * }\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Modify the material shader to display roughness.\n   *   const myShader = baseMaterialShader().modify({\n   *     vertexDeclarations:`in float aRoughness;\n   *                         out float vRoughness;`,\n   *     fragmentDeclarations: 'in float vRoughness;',\n   *     'void afterVertex': `() {\n   *         vRoughness = aRoughness;\n   *     }`,\n   *     'vec4 combineColors': `(ColorComponents components) {\n   *             vec4 color = vec4(0.);\n   *             color.rgb += components.diffuse * components.baseColor * (1.0-vRoughness);\n   *             color.rgb += components.ambient * components.ambientColor;\n   *             color.rgb += components.specular * components.specularColor * (1.0-vRoughness);\n   *             color.a = components.opacity;\n   *             return color;\n   *     }`\n   *   });\n   *\n   *   // Create the Geometry object.\n   *   geo = buildGeometry(function() {\n   *     fill('hotpink');\n   *     sphere(45, 50, 50);\n   *   });\n   *\n   *   // Set the roughness value for every vertex.\n   *   for (let v of geo.vertices){\n   *\n   *     // convert coordinates to spherical coordinates\n   *     let spherical = cartesianToSpherical(v.x, v.y, v.z);\n   *\n   *     // Set the custom roughness vertex property.\n   *     let roughness = noise(spherical.theta*5, spherical.phi*5);\n   *     geo.vertexProperty('aRoughness', roughness);\n   *   }\n   *\n   *   // Use the custom shader.\n   *   shader(myShader);\n   *\n   *   describe('A rough pink sphere rotating on a blue background.');\n   * }\n   *\n   * function draw() {\n   *   // Set some styles and lighting\n   *   background('lightblue');\n   *   noStroke();\n   *\n   *   specularMaterial(255,125,100);\n   *   shininess(2);\n   *\n   *   directionalLight('white', -1, 1, -1);\n   *   ambientLight(320);\n   *\n   *   rotateY(millis()*0.001);\n   *\n   *   // Draw the geometry\n   *   model(geo);\n   * }\n   * </code>\n   * </div>\n   *\n   * @param {String} propertyName the name of the vertex property.\n   * @param {Number|Number[]} data the data tied to the vertex property.\n   * @param {Number} [size] optional size of each unit of data.\n   */\n  vertexProperty(propertyName, data, size){\n    let prop;\n    if (!this.userVertexProperties[propertyName]){\n      prop = this.userVertexProperties[propertyName] =\n        this._userVertexPropertyHelper(propertyName, data, size);\n    }\n    prop = this.userVertexProperties[propertyName];\n    if (size){\n      prop.pushDirect(data);\n    } else {\n      prop.setCurrentData(data);\n      prop.pushCurrentData();\n    }\n  }\n\n  _userVertexPropertyHelper(propertyName, data, size){\n    const geometryInstance = this;\n    const prop = this.userVertexProperties[propertyName] = {\n      name: propertyName,\n      dataSize: size ? size : data.length ? data.length : 1,\n      geometry: geometryInstance,\n      // Getters\n      getName(){\n        return this.name;\n      },\n      getCurrentData(){\n        if (this.currentData === undefined) {\n          this.currentData = new Array(this.getDataSize()).fill(0);\n        }\n        return this.currentData;\n      },\n      getDataSize() {\n        return this.dataSize;\n      },\n      getSrcName() {\n        const src = this.name.concat('Src');\n        return src;\n      },\n      getDstName() {\n        const dst = this.name.concat('Buffer');\n        return dst;\n      },\n      getSrcArray() {\n        const srcName = this.getSrcName();\n        return this.geometry[srcName];\n      },\n      //Setters\n      setCurrentData(data) {\n        data.length ? data.length : 1;\n        // if (size != this.getDataSize()){\n        //   p5._friendlyError(`Custom vertex property '${this.name}' has been set with various data sizes. You can change it's name, or if it was an accident, set '${this.name}' to have the same number of inputs each time!`, 'vertexProperty()');\n        // }\n        this.currentData = data;\n      },\n      // Utilities\n      pushCurrentData(){\n        const data = this.getCurrentData();\n        this.pushDirect(data);\n      },\n      pushDirect(data) {\n        if (data.length){\n          this.getSrcArray().push(...data);\n        } else {\n          this.getSrcArray().push(data);\n        }\n      },\n      resetSrcArray(){\n        this.geometry[this.getSrcName()] = [];\n      },\n      delete() {\n        const srcName = this.getSrcName();\n        delete this.geometry[srcName];\n        delete this;\n      }\n    };\n    this[prop.getSrcName()] = [];\n    return this.userVertexProperties[propertyName];\n  }\n}\n/**\n * Keeps track of how many custom geometry objects have been made so that each\n * can be assigned a unique ID.\n */\nGeometry.nextId = 0;\n\nfunction geometry(p5, fn){\n  /**\n   * A class to describe a 3D shape.\n   *\n   * Each `p5.Geometry` object represents a 3D shape as a set of connected\n   * points called *vertices*. All 3D shapes are made by connecting vertices to\n   * form triangles that are stitched together. Each triangular patch on the\n   * geometry's surface is called a *face*. The geometry stores information\n   * about its vertices and faces for use with effects such as lighting and\n   * texture mapping.\n   *\n   * The first parameter, `detailX`, is optional. If a number is passed, as in\n   * `new p5.Geometry(24)`, it sets the number of triangle subdivisions to use\n   * along the geometry's x-axis. By default, `detailX` is 1.\n   *\n   * The second parameter, `detailY`, is also optional. If a number is passed,\n   * as in `new p5.Geometry(24, 16)`, it sets the number of triangle\n   * subdivisions to use along the geometry's y-axis. By default, `detailX` is\n   * 1.\n   *\n   * The third parameter, `callback`, is also optional. If a function is passed,\n   * as in `new p5.Geometry(24, 16, createShape)`, it will be called once to add\n   * vertices to the new 3D shape.\n   *\n   * @class p5.Geometry\n   * @param  {Integer} [detailX] number of vertices along the x-axis.\n   * @param  {Integer} [detailY] number of vertices along the y-axis.\n   * @param {function} [callback] function to call once the geometry is created.\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object.\n   *   myGeometry = new p5.Geometry();\n   *\n   *   // Create p5.Vector objects to position the vertices.\n   *   let v0 = createVector(-40, 0, 0);\n   *   let v1 = createVector(0, -40, 0);\n   *   let v2 = createVector(40, 0, 0);\n   *\n   *   // Add the vertices to the p5.Geometry object's vertices array.\n   *   myGeometry.vertices.push(v0, v1, v2);\n   *\n   *   describe('A white triangle drawn on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the p5.Geometry object.\n   *   model(myGeometry);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object using a callback function.\n   *   myGeometry = new p5.Geometry(1, 1, createShape);\n   *\n   *   describe('A white triangle drawn on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the p5.Geometry object.\n   *   model(myGeometry);\n   * }\n   *\n   * function createShape() {\n   *   // Create p5.Vector objects to position the vertices.\n   *   let v0 = createVector(-40, 0, 0);\n   *   let v1 = createVector(0, -40, 0);\n   *   let v2 = createVector(40, 0, 0);\n   *\n   *   // \"this\" refers to the p5.Geometry object being created.\n   *\n   *   // Add the vertices to the p5.Geometry object's vertices array.\n   *   this.vertices.push(v0, v1, v2);\n   *\n   *   // Add an array to list which vertices belong to the face.\n   *   // Vertices are listed in clockwise \"winding\" order from\n   *   // left to top to right.\n   *   this.faces.push([0, 1, 2]);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object using a callback function.\n   *   myGeometry = new p5.Geometry(1, 1, createShape);\n   *\n   *   describe('A white triangle drawn on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the p5.Geometry object.\n   *   model(myGeometry);\n   * }\n   *\n   * function createShape() {\n   *   // Create p5.Vector objects to position the vertices.\n   *   let v0 = createVector(-40, 0, 0);\n   *   let v1 = createVector(0, -40, 0);\n   *   let v2 = createVector(40, 0, 0);\n   *\n   *   // \"this\" refers to the p5.Geometry object being created.\n   *\n   *   // Add the vertices to the p5.Geometry object's vertices array.\n   *   this.vertices.push(v0, v1, v2);\n   *\n   *   // Add an array to list which vertices belong to the face.\n   *   // Vertices are listed in clockwise \"winding\" order from\n   *   // left to top to right.\n   *   this.faces.push([0, 1, 2]);\n   *\n   *   // Compute the surface normals to help with lighting.\n   *   this.computeNormals();\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * // Adapted from Paul Wheeler's wonderful p5.Geometry tutorial.\n   * // https://www.paulwheeler.us/articles/custom-3d-geometry-in-p5js/\n   * // CC-BY-SA 4.0\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create the p5.Geometry object.\n   *   // Set detailX to 48 and detailY to 2.\n   *   // >>> try changing them.\n   *   myGeometry = new p5.Geometry(48, 2, createShape);\n   * }\n   *\n   * function draw() {\n   *   background(50);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Style the p5.Geometry object.\n   *   strokeWeight(0.2);\n   *\n   *   // Draw the p5.Geometry object.\n   *   model(myGeometry);\n   * }\n   *\n   * function createShape() {\n   *   // \"this\" refers to the p5.Geometry object being created.\n   *\n   *   // Define the Möbius strip with a few parameters.\n   *   let spread = 0.1;\n   *   let radius = 30;\n   *   let stripWidth = 15;\n   *   let xInterval = 4 * PI / this.detailX;\n   *   let yOffset = -stripWidth / 2;\n   *   let yInterval = stripWidth / this.detailY;\n   *\n   *   for (let j = 0; j <= this.detailY; j += 1) {\n   *     // Calculate the \"vertical\" point along the strip.\n   *     let v = yOffset + yInterval * j;\n   *\n   *     for (let i = 0; i <= this.detailX; i += 1) {\n   *       // Calculate the angle of rotation around the strip.\n   *       let u = i * xInterval;\n   *\n   *       // Calculate the coordinates of the vertex.\n   *       let x = (radius + v * cos(u / 2)) * cos(u) - sin(u / 2) * 2 * spread;\n   *       let y = (radius + v * cos(u / 2)) * sin(u);\n   *       if (u < TWO_PI) {\n   *         y += sin(u) * spread;\n   *       } else {\n   *         y -= sin(u) * spread;\n   *       }\n   *       let z = v * sin(u / 2) + sin(u / 4) * 4 * spread;\n   *\n   *       // Create a p5.Vector object to position the vertex.\n   *       let vert = createVector(x, y, z);\n   *\n   *       // Add the vertex to the p5.Geometry object's vertices array.\n   *       this.vertices.push(vert);\n   *     }\n   *   }\n   *\n   *   // Compute the faces array.\n   *   this.computeFaces();\n   *\n   *   // Compute the surface normals to help with lighting.\n   *   this.computeNormals();\n   * }\n   * </code>\n   * </div>\n   */\n  p5.Geometry = Geometry;\n\n  /**\n   * An array with the geometry's vertices.\n   *\n   * The geometry's vertices are stored as\n   * <a href=\"#/p5.Vector\">p5.Vector</a> objects in the `myGeometry.vertices`\n   * array. The geometry's first vertex is the\n   * <a href=\"#/p5.Vector\">p5.Vector</a> object at `myGeometry.vertices[0]`,\n   * its second vertex is `myGeometry.vertices[1]`, its third vertex is\n   * `myGeometry.vertices[2]`, and so on.\n   *\n   * @property vertices\n   * @for p5.Geometry\n   * @name vertices\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object.\n   *   myGeometry = new p5.Geometry();\n   *\n   *   // Create p5.Vector objects to position the vertices.\n   *   let v0 = createVector(-40, 0, 0);\n   *   let v1 = createVector(0, -40, 0);\n   *   let v2 = createVector(40, 0, 0);\n   *\n   *   // Add the vertices to the p5.Geometry object's vertices array.\n   *   myGeometry.vertices.push(v0, v1, v2);\n   *\n   *   describe('A white triangle drawn on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the p5.Geometry object.\n   *   model(myGeometry);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object.\n   *   myGeometry = buildGeometry(function() {\n   *     torus(30, 15, 10, 8);\n   *   });\n   *\n   *   describe('A white torus rotates slowly against a dark gray background. Red spheres mark its vertices.');\n   * }\n   *\n   * function draw() {\n   *   background(50);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Rotate the coordinate system.\n   *   rotateY(frameCount * 0.01);\n   *\n   *   // Style the p5.Geometry object.\n   *   fill(255);\n   *   stroke(0);\n   *\n   *   // Display the p5.Geometry object.\n   *   model(myGeometry);\n   *\n   *   // Style the vertices.\n   *   fill(255, 0, 0);\n   *   noStroke();\n   *\n   *   // Iterate over the vertices array.\n   *   for (let v of myGeometry.vertices) {\n   *     // Draw a sphere to mark the vertex.\n   *     push();\n   *     translate(v);\n   *     sphere(2.5);\n   *     pop();\n   *   }\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * An array with the vectors that are normal to the geometry's vertices.\n   *\n   * A face's orientation is defined by its *normal vector* which points out\n   * of the face and is normal (perpendicular) to the surface. Calling\n   * `myGeometry.computeNormals()` first calculates each face's normal\n   * vector. Then it calculates the normal vector for each vertex by\n   * averaging the normal vectors of the faces surrounding the vertex. The\n   * vertex normals are stored as <a href=\"#/p5.Vector\">p5.Vector</a>\n   * objects in the `myGeometry.vertexNormals` array.\n   *\n   * @property vertexNormals\n   * @name vertexNormals\n   * @for p5.Geometry\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object.\n   *   myGeometry = buildGeometry(function() {\n   *     torus(30, 15, 10, 8);\n   *   });\n   *\n   *   // Compute the vertex normals.\n   *   myGeometry.computeNormals();\n   *\n   *   describe(\n   *     'A white torus rotates against a dark gray background. Red lines extend outward from its vertices.'\n   *   );\n   * }\n   *\n   * function draw() {\n   *   background(50);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Rotate the coordinate system.\n   *   rotateY(frameCount * 0.01);\n   *\n   *   // Style the p5.Geometry object.\n   *   stroke(0);\n   *\n   *   // Display the p5.Geometry object.\n   *   model(myGeometry);\n   *\n   *   // Style the normal vectors.\n   *   stroke(255, 0, 0);\n   *\n   *   // Iterate over the vertices and vertexNormals arrays.\n   *   for (let i = 0; i < myGeometry.vertices.length; i += 1) {\n   *\n   *     // Get the vertex p5.Vector object.\n   *     let v = myGeometry.vertices[i];\n   *\n   *     // Get the vertex normal p5.Vector object.\n   *     let n = myGeometry.vertexNormals[i];\n   *\n   *     // Calculate a point along the vertex normal.\n   *     let p = p5.Vector.mult(n, 8);\n   *\n   *     // Draw the vertex normal as a red line.\n   *     push();\n   *     translate(v);\n   *     line(0, 0, 0, p.x, p.y, p.z);\n   *     pop();\n   *   }\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object.\n   *   myGeometry = new p5.Geometry();\n   *\n   *   // Create p5.Vector objects to position the vertices.\n   *   let v0 = createVector(-40, 0, 0);\n   *   let v1 = createVector(0, -40, 0);\n   *   let v2 = createVector(0, 40, 0);\n   *   let v3 = createVector(40, 0, 0);\n   *\n   *   // Add the vertices to the p5.Geometry object's vertices array.\n   *   myGeometry.vertices.push(v0, v1, v2, v3);\n   *\n   *   // Compute the faces array.\n   *   myGeometry.computeFaces();\n   *\n   *   // Compute the surface normals.\n   *   myGeometry.computeNormals();\n   *\n   *   describe('A red square drawn on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Add a white point light.\n   *   pointLight(255, 255, 255, 0, 0, 10);\n   *\n   *   // Style the p5.Geometry object.\n   *   noStroke();\n   *   fill(255, 0, 0);\n   *\n   *   // Display the p5.Geometry object.\n   *   model(myGeometry);\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * An array that lists which of the geometry's vertices form each of its\n   * faces.\n   *\n   * All 3D shapes are made by connecting sets of points called *vertices*. A\n   * geometry's surface is formed by connecting vertices to form triangles\n   * that are stitched together. Each triangular patch on the geometry's\n   * surface is called a *face*.\n   *\n   * The geometry's vertices are stored as\n   * <a href=\"#/p5.Vector\">p5.Vector</a> objects in the\n   * <a href=\"#/p5.Geometry/vertices\">myGeometry.vertices</a> array. The\n   * geometry's first vertex is the <a href=\"#/p5.Vector\">p5.Vector</a>\n   * object at `myGeometry.vertices[0]`, its second vertex is\n   * `myGeometry.vertices[1]`, its third vertex is `myGeometry.vertices[2]`,\n   * and so on.\n   *\n   * For example, a geometry made from a rectangle has two faces because a\n   * rectangle is made by joining two triangles. `myGeometry.faces` for a\n   * rectangle would be the two-dimensional array `[[0, 1, 2], [2, 1, 3]]`.\n   * The first face, `myGeometry.faces[0]`, is the array `[0, 1, 2]` because\n   * it's formed by connecting `myGeometry.vertices[0]`,\n   * `myGeometry.vertices[1]`,and `myGeometry.vertices[2]`. The second face,\n   * `myGeometry.faces[1]`, is the array `[2, 1, 3]` because it's formed by\n   * connecting `myGeometry.vertices[2]`, `myGeometry.vertices[1]`,and\n   * `myGeometry.vertices[3]`.\n   *\n   * @property faces\n   * @name faces\n   * @for p5.Geometry\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object.\n   *   myGeometry = buildGeometry(function() {\n   *     sphere();\n   *   });\n   *\n   *   describe(\"A sphere drawn on a gray background. The sphere's surface is a grayscale patchwork of triangles.\");\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Style the p5.Geometry object.\n   *   noStroke();\n   *\n   *   // Set a random seed.\n   *   randomSeed(1234);\n   *\n   *   // Iterate over the faces array.\n   *   for (let face of myGeometry.faces) {\n   *\n   *     // Style the face.\n   *     let g = random(0, 255);\n   *     fill(g);\n   *\n   *     // Draw the face.\n   *     beginShape();\n   *     // Iterate over the vertices that form the face.\n   *     for (let f of face) {\n   *       // Get the vertex's p5.Vector object.\n   *       let v = myGeometry.vertices[f];\n   *       vertex(v.x, v.y, v.z);\n   *     }\n   *     endShape();\n   *\n   *   }\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * An array that lists the texture coordinates for each of the geometry's\n   * vertices.\n   *\n   * In order for <a href=\"#/p5/texture\">texture()</a> to work, the geometry\n   * needs a way to map the points on its surface to the pixels in a\n   * rectangular image that's used as a texture. The geometry's vertex at\n   * coordinates `(x, y, z)` maps to the texture image's pixel at coordinates\n   * `(u, v)`.\n   *\n   * The `myGeometry.uvs` array stores the `(u, v)` coordinates for each\n   * vertex in the order it was added to the geometry. For example, the\n   * first vertex, `myGeometry.vertices[0]`, has its `(u, v)` coordinates\n   * stored at `myGeometry.uvs[0]` and `myGeometry.uvs[1]`.\n   *\n   * @property uvs\n   * @name uvs\n   * @for p5.Geometry\n   *\n   * @example\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   img = await loadImage('assets/laDefense.jpg');\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   // Create p5.Geometry objects.\n   *   let geom1 = buildGeometry(createShape);\n   *   let geom2 = buildGeometry(createShape);\n   *\n   *   // Left (original).\n   *   push();\n   *   translate(-25, 0, 0);\n   *   texture(img);\n   *   noStroke();\n   *   model(geom1);\n   *   pop();\n   *\n   *   // Set geom2's texture coordinates.\n   *   geom2.uvs = [0.25, 0.25, 0.75, 0.25, 0.25, 0.75, 0.75, 0.75];\n   *\n   *   // Right (zoomed in).\n   *   push();\n   *   translate(25, 0, 0);\n   *   texture(img);\n   *   noStroke();\n   *   model(geom2);\n   *   pop();\n   *\n   *   describe(\n   *     'Two photos of a ceiling on a gray background. The photo on the right zooms in to the center of the photo.'\n   *   );\n   * }\n   *\n   * function createShape() {\n   *   plane(40);\n   * }\n   * </code>\n   * </div>\n   */\n}\n\nif(typeof p5 !== 'undefined'){\n  geometry(p5, p5.prototype);\n}\n\nexport { Geometry, geometry as default };\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2546, "column": 0}, "map": {"version":3,"sources":["file:///home/user/cg-game-apps/node_modules/p5/dist/webgl/GeometryBuilder.js"],"sourcesContent":["import { r as TRIANGLE_STRIP, s as QUAD_STRIP, q as TRIANGLE_FAN } from '../constants-C-g_eAdC.js';\nimport '../math/p5.Matrix.js';\nimport { Geometry } from './p5.Geometry.js';\nimport { Matrix } from '../math/Matrices/Matrix.js';\nimport '../math/p5.Vector.js';\nimport '../math/Matrices/MatrixInterface.js';\nimport './p5.DataArray.js';\n\n/**\n * @private\n * A class responsible for converting successive WebGL draw calls into a single\n * `p5.Geometry` that can be reused and drawn with `model()`.\n */\nclass GeometryBuilder {\n  constructor(renderer) {\n    this.renderer = renderer;\n    renderer._pInst.push();\n    this.identityMatrix = new Matrix(4);\n    renderer.states.setValue('uModelMatrix', new Matrix(4));\n    this.geometry = new Geometry(undefined, undefined, undefined, this.renderer);\n    this.geometry.gid = `_p5_GeometryBuilder_${GeometryBuilder.nextGeometryId}`;\n    GeometryBuilder.nextGeometryId++;\n    this.hasTransform = false;\n  }\n\n  /**\n   * @private\n   * Applies the current transformation matrix to each vertex.\n   */\n  transformVertices(vertices) {\n    if (!this.hasTransform) return vertices;\n\n    return vertices.map(v => this.renderer.states.uModelMatrix.multiplyPoint(v));\n  }\n\n  /**\n   * @private\n   * Applies the current normal matrix to each normal.\n   */\n  transformNormals(normals) {\n    if (!this.hasTransform) return normals;\n\n    return normals.map(\n      v => this.renderer.scratchMat3.multiplyVec(v) // this is a vec3\n    );\n  }\n\n  /**\n   * @private\n   * Adds a p5.Geometry to the builder's combined geometry, flattening\n   * transformations.\n   */\n  addGeometry(input) {\n    this.hasTransform = !this.renderer.states.uModelMatrix.mat4\n      .every((v, i) => v === this.identityMatrix.mat4[i]);\n\n    if (this.hasTransform) {\n      this.renderer.scratchMat3.inverseTranspose4x4(this.renderer.states.uModelMatrix);\n    }\n\n    let startIdx = this.geometry.vertices.length;\n    this.geometry.vertices.push(...this.transformVertices(input.vertices));\n    this.geometry.vertexNormals.push(\n      ...this.transformNormals(input.vertexNormals)\n    );\n    this.geometry.uvs.push(...input.uvs);\n\n    const inputUserVertexProps = input.userVertexProperties;\n    const builtUserVertexProps = this.geometry.userVertexProperties;\n    const numPreviousVertices = this.geometry.vertices.length - input.vertices.length;\n\n    for (const propName in builtUserVertexProps){\n      if (propName in inputUserVertexProps){\n        continue;\n      }\n      const prop = builtUserVertexProps[propName];\n      const size = prop.getDataSize();\n      const numMissingValues = size * input.vertices.length;\n      const missingValues = Array(numMissingValues).fill(0);\n      prop.pushDirect(missingValues);\n    }\n    for (const propName in inputUserVertexProps){\n      const prop = inputUserVertexProps[propName];\n      const data = prop.getSrcArray();\n      const size = prop.getDataSize();\n      if (numPreviousVertices > 0 && !(propName in builtUserVertexProps)){\n        const numMissingValues = size * numPreviousVertices;\n        const missingValues = Array(numMissingValues).fill(0);\n        this.geometry.vertexProperty(propName, missingValues, size);\n      }\n      this.geometry.vertexProperty(propName, data, size);\n    }\n\n    if (this.renderer.states.fillColor) {\n      this.geometry.faces.push(\n        ...input.faces.map(f => f.map(idx => idx + startIdx))\n      );\n    }\n    if (this.renderer.states.strokeColor) {\n      this.geometry.edges.push(\n        ...input.edges.map(edge => edge.map(idx => idx + startIdx))\n      );\n    }\n    const vertexColors = [...input.vertexColors];\n    while (vertexColors.length < input.vertices.length * 4) {\n      vertexColors.push(...this.renderer.states.curFillColor);\n    }\n    this.geometry.vertexColors.push(...vertexColors);\n  }\n\n  /**\n   * Adds geometry from the renderer's immediate mode into the builder's\n   * combined geometry.\n   */\n  addImmediate(geometry, shapeMode) {\n    const faces = [];\n\n    if (this.renderer.states.fillColor) {\n      if (\n        shapeMode === TRIANGLE_STRIP ||\n        shapeMode === QUAD_STRIP\n      ) {\n        for (let i = 2; i < geometry.vertices.length; i++) {\n          if (i % 2 === 0) {\n            faces.push([i, i - 1, i - 2]);\n          } else {\n            faces.push([i, i - 2, i - 1]);\n          }\n        }\n      } else if (shapeMode === TRIANGLE_FAN) {\n        for (let i = 2; i < geometry.vertices.length; i++) {\n          faces.push([0, i - 1, i]);\n        }\n      } else {\n        for (let i = 0; i < geometry.vertices.length; i += 3) {\n          faces.push([i, i + 1, i + 2]);\n        }\n      }\n    }\n    this.addGeometry(Object.assign({}, geometry, { faces }));\n  }\n\n  /**\n   * Adds geometry from the renderer's retained mode into the builder's\n   * combined geometry.\n   */\n  addRetained(geometry) {\n    this.addGeometry(geometry);\n  }\n\n  /**\n   * Cleans up the state of the renderer and returns the combined geometry that\n   * was built.\n   * @returns p5.Geometry The flattened, combined geometry\n   */\n  finish() {\n    this.renderer._pInst.pop();\n    return this.geometry;\n  }\n}\n\n/**\n * Keeps track of how many custom geometry objects have been made so that each\n * can be assigned a unique ID.\n */\nGeometryBuilder.nextGeometryId = 0;\n\nexport { GeometryBuilder as default };\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2714, "column": 0}, "map": {"version":3,"sources":["file:///home/user/cg-game-apps/node_modules/p5/dist/webgl/p5.Quat.js"],"sourcesContent":["import { Vector } from '../math/p5.Vector.js';\nimport '../constants-C-g_eAdC.js';\n\n/**\n * @module Math\n * @submodule Quaternion\n */\n\n\nclass Quat {\n  constructor(w, x, y, z) {\n    this.w = w;\n    this.vec = new Vector(x, y, z);\n  }\n\n  /**\n     * Returns a Quaternion for the\n     * axis angle representation of the rotation\n     *\n     * @method fromAxisAngle\n     * @param {Number} [angle] Angle with which the points needs to be rotated\n     * @param {Number} [x] x component of the axis vector\n     * @param {Number} [y] y component of the axis vector\n     * @param {Number} [z] z component of the axis vector\n     * @chainable\n    */\n  static fromAxisAngle(angle, x, y, z) {\n    const w = Math.cos(angle/2);\n    const vec = new Vector(x, y, z).normalize().mult(Math.sin(angle/2));\n    return new Quat(w, vec.x, vec.y, vec.z);\n  }\n\n  conjugate() {\n    return new Quat(this.w, -this.vec.x, -this.vec.y, -this.vec.z);\n  }\n\n  /**\n     * Multiplies a quaternion with other quaternion.\n     * @method mult\n     * @param  {p5.Quat} [quat] quaternion to multiply with the quaternion calling the method.\n     * @chainable\n     */\n  multiply(quat) {\n    /* eslint-disable max-len */\n    return new Quat(\n      this.w * quat.w - this.vec.x * quat.vec.x - this.vec.y * quat.vec.y - this.vec.z - quat.vec.z,\n      this.w * quat.vec.x + this.vec.x * quat.w + this.vec.y * quat.vec.z - this.vec.z * quat.vec.y,\n      this.w * quat.vec.y - this.vec.x * quat.vec.z + this.vec.y * quat.w + this.vec.z * quat.vec.x,\n      this.w * quat.vec.z + this.vec.x * quat.vec.y - this.vec.y * quat.vec.x + this.vec.z * quat.w\n    );\n    /* eslint-enable max-len */\n  }\n\n  /**\n   * This is similar to quaternion multiplication\n   * but when multipying vector with quaternion\n   * the multiplication can be simplified to the below formula.\n   * This was taken from the below stackexchange link\n   * https://gamedev.stackexchange.com/questions/28395/rotating-vector3-by-a-quaternion/50545#50545\n   * @param {p5.Vector} [p] vector to rotate on the axis quaternion\n   */\n  rotateVector(p) {\n    return Vector.mult( p, this.w*this.w - this.vec.dot(this.vec) )\n      .add( Vector.mult( this.vec, 2 * p.dot(this.vec) ) )\n      .add( Vector.mult( this.vec, 2 * this.w ).cross( p ) )\n      .clampToZero();\n  }\n\n  /**\n     * Rotates the Quaternion by the quaternion passed\n     * which contains the axis of roation and angle of rotation\n     *\n     * @method rotateBy\n     * @param {p5.Quat} [axesQuat] axis quaternion which contains\n     *  the axis of rotation and angle of rotation\n     * @chainable\n     */\n  rotateBy(axesQuat) {\n    return axesQuat.multiply(this).multiply(axesQuat.conjugate()).\n      vec.clampToZero();\n  }\n}\n\nfunction quat(p5, fn){\n  /**\n   * A class to describe a Quaternion\n   * for vector rotations in the p5js webgl renderer.\n   * Please refer the following link for details on the implementation\n   * https://danceswithcode.net/engineeringnotes/quaternions/quaternions.html\n   * @class p5.Quat\n   * @constructor\n   * @param {Number} [w] Scalar part of the quaternion\n   * @param {Number} [x] x component of imaginary part of quaternion\n   * @param {Number} [y] y component of imaginary part of quaternion\n   * @param {Number} [z] z component of imaginary part of quaternion\n   * @private\n   */\n  p5.Quat = Quat;\n}\n\nif(typeof p5 !== 'undefined'){\n  quat(p5, p5.prototype);\n}\n\nexport { Quat, quat as default };\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2803, "column": 0}, "map": {"version":3,"sources":["file:///home/user/cg-game-apps/node_modules/p5/dist/webgl/p5.RenderBuffer.js"],"sourcesContent":["class RenderBuffer {\n  constructor(size, src, dst, attr, renderer, map) {\n    this.size = size; // the number of FLOATs in each vertex\n    this.src = src; // the name of the model's source array\n    this.dst = dst; // the name of the geometry's buffer\n    this.attr = attr; // the name of the vertex attribute\n    this._renderer = renderer;\n    this.map = map; // optional, a transformation function to apply to src\n  }\n\n  /**\n   * Enables and binds the buffers used by shader when the appropriate data exists in geometry.\n   * Must always be done prior to drawing geometry in WebGL.\n   * @param {p5.Geometry} geometry Geometry that is going to be drawn\n   * @param {p5.Shader} shader Active shader\n   * @private\n   */\n  _prepareBuffer(geometry, shader) {\n    const attributes = shader.attributes;\n    const gl = this._renderer.GL;\n    const glBuffers = this._renderer._getOrMakeCachedBuffers(geometry);\n\n    // loop through each of the buffer definitions\n    const attr = attributes[this.attr];\n    if (!attr) {\n      return;\n    }\n    // check if the geometry has the appropriate source array\n    let buffer = glBuffers[this.dst];\n    const src = geometry[this.src];\n    if (src && src.length > 0) {\n      // check if we need to create the GL buffer\n      const createBuffer = !buffer;\n      if (createBuffer) {\n        // create and remember the buffer\n        glBuffers[this.dst] = buffer = gl.createBuffer();\n      }\n      // bind the buffer\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n\n      // check if we need to fill the buffer with data\n      if (createBuffer || geometry.dirtyFlags[this.src] !== false) {\n        const map = this.map;\n        // get the values from the geometry, possibly transformed\n        const values = map ? map(src) : src;\n        // fill the buffer with the values\n        this._renderer._bindBuffer(buffer, gl.ARRAY_BUFFER, values);\n        // mark the geometry's source array as clean\n        geometry.dirtyFlags[this.src] = false;\n      }\n      // enable the attribute\n      shader.enableAttrib(attr, this.size);\n    } else {\n      const loc = attr.location;\n      if (loc === -1 || !this._renderer.registerEnabled.has(loc)) {\n        return;\n      }\n      // Disable register corresponding to unused attribute\n      gl.disableVertexAttribArray(loc);\n      // Record register availability\n      this._renderer.registerEnabled.delete(loc);\n    }\n  }\n}\n\nfunction renderBuffer(p5, fn) {\n  p5.RenderBuffer = RenderBuffer;\n}\n\nif (typeof p5 !== \"undefined\") {\n  renderBuffer(p5, p5.prototype);\n}\n\nexport { RenderBuffer, renderBuffer as default };\n"],"names":[],"mappings":";;;;AAAA,MAAM;IACJ,YAAY,IAAI,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,QAAQ,EAAE,GAAG,CAAE;QAC/C,IAAI,CAAC,IAAI,GAAG,MAAM,sCAAsC;QACxD,IAAI,CAAC,GAAG,GAAG,KAAK,uCAAuC;QACvD,IAAI,CAAC,GAAG,GAAG,KAAK,oCAAoC;QACpD,IAAI,CAAC,IAAI,GAAG,MAAM,mCAAmC;QACrD,IAAI,CAAC,SAAS,GAAG;QACjB,IAAI,CAAC,GAAG,GAAG,KAAK,sDAAsD;IACxE;IAEA;;;;;;GAMC,GACD,eAAe,QAAQ,EAAE,MAAM,EAAE;QAC/B,MAAM,aAAa,OAAO,UAAU;QACpC,MAAM,KAAK,IAAI,CAAC,SAAS,CAAC,EAAE;QAC5B,MAAM,YAAY,IAAI,CAAC,SAAS,CAAC,uBAAuB,CAAC;QAEzD,8CAA8C;QAC9C,MAAM,OAAO,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC;QAClC,IAAI,CAAC,MAAM;YACT;QACF;QACA,yDAAyD;QACzD,IAAI,SAAS,SAAS,CAAC,IAAI,CAAC,GAAG,CAAC;QAChC,MAAM,MAAM,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC;QAC9B,IAAI,OAAO,IAAI,MAAM,GAAG,GAAG;YACzB,2CAA2C;YAC3C,MAAM,eAAe,CAAC;YACtB,IAAI,cAAc;gBAChB,iCAAiC;gBACjC,SAAS,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,SAAS,GAAG,YAAY;YAChD;YACA,kBAAkB;YAClB,GAAG,UAAU,CAAC,GAAG,YAAY,EAAE;YAE/B,gDAAgD;YAChD,IAAI,gBAAgB,SAAS,UAAU,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,OAAO;gBAC3D,MAAM,MAAM,IAAI,CAAC,GAAG;gBACpB,yDAAyD;gBACzD,MAAM,SAAS,MAAM,IAAI,OAAO;gBAChC,kCAAkC;gBAClC,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,QAAQ,GAAG,YAAY,EAAE;gBACpD,4CAA4C;gBAC5C,SAAS,UAAU,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG;YAClC;YACA,uBAAuB;YACvB,OAAO,YAAY,CAAC,MAAM,IAAI,CAAC,IAAI;QACrC,OAAO;YACL,MAAM,MAAM,KAAK,QAAQ;YACzB,IAAI,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,eAAe,CAAC,GAAG,CAAC,MAAM;gBAC1D;YACF;YACA,qDAAqD;YACrD,GAAG,wBAAwB,CAAC;YAC5B,+BAA+B;YAC/B,IAAI,CAAC,SAAS,CAAC,eAAe,CAAC,MAAM,CAAC;QACxC;IACF;AACF;AAEA,SAAS,aAAa,GAAE,EAAE,EAAE;IAC1B,IAAG,YAAY,GAAG;AACpB;AAEA,IAAI,OAAO,OAAO,aAAa;IAC7B,aAAa,IAAI,GAAG,SAAS;AAC/B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2880, "column": 0}, "map": {"version":3,"sources":["file:///home/user/cg-game-apps/node_modules/p5/dist/webgl/ShapeBuilder.js"],"sourcesContent":["import { m as PATH, Q as QUADS, s as QUAD_STRIP, r as TRIANGLE_STRIP, p as TRIANGLES, a1 as IMAGE, L as LINES, q as TRIANGLE_FAN } from '../constants-C-g_eAdC.js';\nimport { Geometry } from './p5.Geometry.js';\nimport libtess from 'libtess';\nimport { Vector } from '../math/p5.Vector.js';\nimport { RenderBuffer } from './p5.RenderBuffer.js';\nimport './p5.DataArray.js';\n\nconst INITIAL_BUFFER_STRIDES = {\n  vertices: 1,\n  vertexNormals: 1,\n  vertexColors: 4,\n  vertexStrokeColors: 4,\n  uvs: 2\n};\n\n// The total number of properties per vertex, before additional\n// user attributes are added.\nconst INITIAL_VERTEX_SIZE =\n  Object.values(INITIAL_BUFFER_STRIDES).reduce((acc, next) => acc + next);\n\nclass ShapeBuilder {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this.shapeMode = PATH;\n    this.geometry = new Geometry(undefined, undefined, undefined, this.renderer);\n    this.geometry.gid = '__IMMEDIATE_MODE_GEOMETRY__';\n\n    this.contourIndices = [];\n    this._useUserVertexProperties = undefined;\n\n    this._bezierVertex = [];\n    this._quadraticVertex = [];\n    this._curveVertex = [];\n\n    // Used to distinguish between user calls to vertex() and internal calls\n    this.isProcessingVertices = false;\n\n    // Used for converting shape outlines into triangles for rendering\n    this._tessy = this._initTessy();\n    this.tessyVertexSize = INITIAL_VERTEX_SIZE;\n    this.bufferStrides = { ...INITIAL_BUFFER_STRIDES };\n  }\n\n  constructFromContours(shape, contours) {\n    if (this._useUserVertexProperties){\n      this._resetUserVertexProperties();\n    }\n    this.geometry.reset();\n    this.contourIndices = [];\n    // TODO: handle just some contours having non-PATH mode\n    this.shapeMode = shape.contours[0].kind;\n    const shouldProcessEdges = !!this.renderer.states.strokeColor;\n\n    const userVertexPropertyHelpers = {};\n    if (shape.userVertexProperties) {\n      this._useUserVertexProperties = true;\n      for (const key in shape.userVertexProperties) {\n        const name = shape.vertexPropertyName(key);\n        const prop = this.geometry._userVertexPropertyHelper(name, [], shape.userVertexProperties[key]);\n        userVertexPropertyHelpers[key] = prop;\n        this.tessyVertexSize += prop.getDataSize();\n        this.bufferStrides[prop.getSrcName()] = prop.getDataSize();\n        this.renderer.buffers.user.push(\n          new RenderBuffer(prop.getDataSize(), prop.getSrcName(), prop.getDstName(), name, this.renderer)\n        );\n      }\n    } else {\n      this._useUserVertexProperties = false;\n    }\n\n    for (const contour of contours) {\n      this.contourIndices.push(this.geometry.vertices.length);\n      for (const vertex of contour) {\n        // WebGL doesn't support QUADS or QUAD_STRIP, so we duplicate data to turn\n        // QUADS into TRIANGLES and QUAD_STRIP into TRIANGLE_STRIP. (There is no extra\n        // work to convert QUAD_STRIP here, since the only difference is in how edges\n        // are rendered.)\n        if (this.shapeMode === QUADS) {\n          // A finished quad turned into triangles should leave 6 vertices in the\n          // buffer:\n          // 0--3     0   3--5\n          // |  | --> | \\  \\ |\n          // 1--2     1--2   4\n          // When vertex index 3 is being added, add the necessary duplicates.\n          if (this.geometry.vertices.length % 6 === 3) {\n            for (const key in this.bufferStrides) {\n              const stride = this.bufferStrides[key];\n              const buffer = this.geometry[key];\n              buffer.push(\n                ...buffer.slice(\n                  buffer.length - 3 * stride,\n                  buffer.length - 2 * stride\n                ),\n                ...buffer.slice(buffer.length - stride, buffer.length),\n              );\n            }\n          }\n        }\n\n        this.geometry.vertices.push(vertex.position);\n        this.geometry.vertexNormals.push(vertex.normal || new Vector(0, 0, 0));\n        this.geometry.uvs.push(vertex.textureCoordinates.x, vertex.textureCoordinates.y);\n        if (this.renderer.states.fillColor) {\n          this.geometry.vertexColors.push(...vertex.fill.array());\n        } else {\n          this.geometry.vertexColors.push(0, 0, 0, 0);\n        }\n        if (this.renderer.states.strokeColor) {\n          this.geometry.vertexStrokeColors.push(...vertex.stroke.array());\n        } else {\n          this.geometry.vertexStrokeColors.push(0, 0, 0, 0);\n        }\n        for (const key in userVertexPropertyHelpers) {\n          const prop = userVertexPropertyHelpers[key];\n          if (key in vertex) {\n            prop.setCurrentData(vertex[key]);\n          }\n          prop.pushCurrentData();\n        }\n      }\n    }\n\n    if (shouldProcessEdges) {\n      this.geometry.edges = this._calculateEdges(this.shapeMode, this.geometry.vertices);\n    }\n    if (shouldProcessEdges && !this.renderer.geometryBuilder) {\n      this.geometry._edgesToVertices();\n    }\n\n    if (this.shapeMode === PATH) {\n      this.isProcessingVertices = true;\n      this._tesselateShape();\n      this.isProcessingVertices = false;\n    } else if (this.shapeMode === QUAD_STRIP) {\n      // The only difference between these two modes is which edges are\n      // displayed, so after we've updated the edges, we switch the mode\n      // to one that native WebGL knows how to render.\n      this.shapeMode = TRIANGLE_STRIP;\n    } else if (this.shapeMode === QUADS) {\n      // We translate QUADS to TRIANGLES when vertices are being added,\n      // since QUADS is just a p5 mode, whereas TRIANGLES is also a mode\n      // that native WebGL knows how to render. Once we've processed edges,\n      // everything should be set up for TRIANGLES mode.\n      this.shapeMode = TRIANGLES;\n    }\n\n    if (\n      this.renderer.states.textureMode === IMAGE &&\n      this.renderer.states._tex !== null &&\n      this.renderer.states._tex.width > 0 &&\n      this.renderer.states._tex.height > 0\n    ) {\n      this.geometry.uvs = this.geometry.uvs.map((val, i) => {\n        if (i % 2 === 0) {\n          return val / this.renderer.states._tex.width;\n        } else {\n          return val / this.renderer.states._tex.height;\n        }\n      });\n    }\n  }\n\n  _resetUserVertexProperties() {\n    const properties = this.geometry.userVertexProperties;\n    for (const propName in properties){\n      const prop = properties[propName];\n      delete this.bufferStrides[propName];\n      prop.delete();\n    }\n    this._useUserVertexProperties = false;\n    this.tessyVertexSize = INITIAL_VERTEX_SIZE;\n    this.geometry.userVertexProperties = {};\n  }\n\n  /**\n   * Called from _processVertices(). This function calculates the stroke vertices for custom shapes and\n   * tesselates shapes when applicable.\n   * @private\n   * @returns  {Number[]} indices for custom shape vertices indicating edges.\n   */\n  _calculateEdges(\n    shapeMode,\n    verts,\n  ) {\n    const res = [];\n    let i = 0;\n    const contourIndices = this.contourIndices.slice();\n    let contourStart = -1;\n    switch (shapeMode) {\n      case TRIANGLE_STRIP:\n        for (i = 0; i < verts.length - 2; i++) {\n          res.push([i, i + 1]);\n          res.push([i, i + 2]);\n        }\n        res.push([i, i + 1]);\n        break;\n      case TRIANGLE_FAN:\n        for (i = 1; i < verts.length - 1; i++) {\n          res.push([0, i]);\n          res.push([i, i + 1]);\n        }\n        res.push([0, verts.length - 1]);\n        break;\n      case TRIANGLES:\n        for (i = 0; i < verts.length - 2; i = i + 3) {\n          res.push([i, i + 1]);\n          res.push([i + 1, i + 2]);\n          res.push([i + 2, i]);\n        }\n        break;\n      case LINES:\n        for (i = 0; i < verts.length - 1; i = i + 2) {\n          res.push([i, i + 1]);\n        }\n        break;\n      case QUADS:\n        // Quads have been broken up into two triangles by `vertex()`:\n        // 0   3--5\n        // | \\  \\ |\n        // 1--2   4\n        for (i = 0; i < verts.length - 5; i += 6) {\n          res.push([i, i + 1]);\n          res.push([i + 1, i + 2]);\n          res.push([i + 2, i + 5]);\n          res.push([i + 5, i]);\n        }\n        break;\n      case QUAD_STRIP:\n        // 0---2---4\n        // |   |   |\n        // 1---3---5\n        for (i = 0; i < verts.length - 2; i += 2) {\n          res.push([i, i + 1]);\n          res.push([i + 1, i + 3]);\n          res.push([i, i + 2]);\n        }\n        res.push([i, i + 1]);\n        break;\n      default:\n        // TODO: handle contours in other modes too\n        for (i = 0; i < verts.length; i++) {\n          if (i === contourIndices[0]) {\n            contourStart = contourIndices.shift();\n          } else if (\n            verts[contourStart] &&\n            verts[i].equals(verts[contourStart])\n          ) {\n            res.push([i - 1, contourStart]);\n          } else {\n            res.push([i - 1, i]);\n          }\n        }\n        break;\n    }\n    return res;\n  }\n\n  /**\n   * Called from _processVertices() when applicable. This function tesselates immediateMode.geometry.\n   * @private\n   */\n  _tesselateShape() {\n    // TODO: handle non-PATH shape modes that have contours\n    this.shapeMode = TRIANGLES;\n    // const contours = [[]];\n    const contours = [];\n    for (let i = 0; i < this.geometry.vertices.length; i++) {\n      if (\n        this.contourIndices.length > 0 &&\n        this.contourIndices[0] === i\n      ) {\n        this.contourIndices.shift();\n        contours.push([]);\n      }\n      contours[contours.length-1].push(\n        this.geometry.vertices[i].x,\n        this.geometry.vertices[i].y,\n        this.geometry.vertices[i].z,\n        this.geometry.uvs[i * 2],\n        this.geometry.uvs[i * 2 + 1],\n        this.geometry.vertexColors[i * 4],\n        this.geometry.vertexColors[i * 4 + 1],\n        this.geometry.vertexColors[i * 4 + 2],\n        this.geometry.vertexColors[i * 4 + 3],\n        this.geometry.vertexNormals[i].x,\n        this.geometry.vertexNormals[i].y,\n        this.geometry.vertexNormals[i].z\n      );\n      for (const propName in this.geometry.userVertexProperties) {\n        const prop = this.geometry.userVertexProperties[propName];\n        const start = i * prop.getDataSize();\n        const end = start + prop.getDataSize();\n        const vals = prop.getSrcArray().slice(start, end);\n        contours[contours.length-1].push(...vals);\n      }\n    }\n\n    const polyTriangles = this._triangulate(contours);\n    const originalVertices = this.geometry.vertices;\n    this.geometry.vertices = [];\n    this.geometry.vertexNormals = [];\n    this.geometry.uvs = [];\n    for (const propName in this.geometry.userVertexProperties){\n      const prop = this.geometry.userVertexProperties[propName];\n      prop.resetSrcArray();\n    }\n    const colors = [];\n    for (\n      let j = 0, polyTriLength = polyTriangles.length;\n      j < polyTriLength;\n      j = j + this.tessyVertexSize\n    ) {\n      colors.push(...polyTriangles.slice(j + 5, j + 9));\n      this.geometry.vertexNormals.push(new Vector(...polyTriangles.slice(j + 9, j + 12)));\n      {\n        let offset = 12;\n        for (const propName in this.geometry.userVertexProperties){\n          const prop = this.geometry.userVertexProperties[propName];\n          const size = prop.getDataSize();\n          const start = j + offset;\n          const end = start + size;\n          prop.setCurrentData(polyTriangles.slice(start, end));\n          prop.pushCurrentData();\n          offset += size;\n        }\n      }\n      this.geometry.vertices.push(new Vector(...polyTriangles.slice(j, j + 3)));\n      this.geometry.uvs.push(...polyTriangles.slice(j + 3, j + 5));\n    }\n    if (this.renderer.geometryBuilder) {\n      // Tesselating the face causes the indices of edge vertices to stop being\n      // correct. When rendering, this is not a problem, since _edgesToVertices\n      // will have been called before this, and edge vertex indices are no longer\n      // needed. However, the geometry builder still needs this information, so\n      // when one is active, we need to update the indices.\n      //\n      // We record index mappings in a Map so that once we have found a\n      // corresponding vertex, we don't need to loop to find it again.\n      const newIndex = new Map();\n      this.geometry.edges =\n        this.geometry.edges.map(edge => edge.map(origIdx => {\n          if (!newIndex.has(origIdx)) {\n            const orig = originalVertices[origIdx];\n            let newVertIndex = this.geometry.vertices.findIndex(\n              v =>\n                orig.x === v.x &&\n                orig.y === v.y &&\n                orig.z === v.z\n            );\n            if (newVertIndex === -1) {\n              // The tesselation process didn't output a vertex with the exact\n              // coordinate as before, potentially due to numerical issues. This\n              // doesn't happen often, but in this case, pick the closest point\n              let closestDist = Infinity;\n              let closestIndex = 0;\n              for (\n                let i = 0;\n                i < this.geometry.vertices.length;\n                i++\n              ) {\n                const vert = this.geometry.vertices[i];\n                const dX = orig.x - vert.x;\n                const dY = orig.y - vert.y;\n                const dZ = orig.z - vert.z;\n                const dist = dX*dX + dY*dY + dZ*dZ;\n                if (dist < closestDist) {\n                  closestDist = dist;\n                  closestIndex = i;\n                }\n              }\n              newVertIndex = closestIndex;\n            }\n            newIndex.set(origIdx, newVertIndex);\n          }\n          return newIndex.get(origIdx);\n        }));\n    }\n    this.geometry.vertexColors = colors;\n  }\n\n  _initTessy() {\n    // function called for each vertex of tesselator output\n    function vertexCallback(data, polyVertArray) {\n      for (const element of data) {\n        polyVertArray.push(element);\n      }\n    }\n\n    function begincallback(type) {\n      if (type !== libtess.primitiveType.GL_TRIANGLES) {\n        console.log(`expected TRIANGLES but got type: ${type}`);\n      }\n    }\n\n    function errorcallback(errno) {\n      console.log('error callback');\n      console.log(`error number: ${errno}`);\n    }\n\n    // callback for when segments intersect and must be split\n    const combinecallback = (coords, data, weight) => {\n      const result = new Array(this.tessyVertexSize).fill(0);\n      for (let i = 0; i < weight.length; i++) {\n        for (let j = 0; j < result.length; j++) {\n          if (weight[i] === 0 || !data[i]) continue;\n          result[j] += data[i][j] * weight[i];\n        }\n      }\n      return result;\n    };\n\n    function edgeCallback(flag) {\n      // don't really care about the flag, but need no-strip/no-fan behavior\n    }\n\n    const tessy = new libtess.GluTesselator();\n    tessy.gluTessCallback(libtess.gluEnum.GLU_TESS_VERTEX_DATA, vertexCallback);\n    tessy.gluTessCallback(libtess.gluEnum.GLU_TESS_BEGIN, begincallback);\n    tessy.gluTessCallback(libtess.gluEnum.GLU_TESS_ERROR, errorcallback);\n    tessy.gluTessCallback(libtess.gluEnum.GLU_TESS_COMBINE, combinecallback);\n    tessy.gluTessCallback(libtess.gluEnum.GLU_TESS_EDGE_FLAG, edgeCallback);\n    tessy.gluTessProperty(\n      libtess.gluEnum.GLU_TESS_WINDING_RULE,\n      libtess.windingRule.GLU_TESS_WINDING_NONZERO\n    );\n\n    return tessy;\n  }\n\n  /**\n   * Runs vertices through libtess to convert them into triangles\n   * @private\n   */\n  _triangulate(contours) {\n    // libtess will take 3d verts and flatten to a plane for tesselation.\n    // libtess is capable of calculating a plane to tesselate on, but\n    // if all of the vertices have the same z values, we'll just\n    // assume the face is facing the camera, letting us skip any performance\n    // issues or bugs in libtess's automatic calculation.\n    const z = contours[0] ? contours[0][2] : undefined;\n    let allSameZ = true;\n    for (const contour of contours) {\n      for (\n        let j = 0;\n        j < contour.length;\n        j += this.tessyVertexSize\n      ) {\n        if (contour[j + 2] !== z) {\n          allSameZ = false;\n          break;\n        }\n      }\n    }\n    if (allSameZ) {\n      this._tessy.gluTessNormal(0, 0, 1);\n    } else {\n      // Let libtess pick a plane for us\n      this._tessy.gluTessNormal(0, 0, 0);\n    }\n\n    const triangleVerts = [];\n    this._tessy.gluTessBeginPolygon(triangleVerts);\n\n    for (const contour of contours) {\n      this._tessy.gluTessBeginContour();\n      for (\n        let j = 0;\n        j < contour.length;\n        j += this.tessyVertexSize\n      ) {\n        const coords = contour.slice(\n          j,\n          j + this.tessyVertexSize\n        );\n        this._tessy.gluTessVertex(coords, coords);\n      }\n      this._tessy.gluTessEndContour();\n    }\n\n    // finish polygon\n    this._tessy.gluTessEndPolygon();\n\n    return triangleVerts;\n  }\n}\n\nexport { ShapeBuilder };\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3346, "column": 0}, "map": {"version":3,"sources":["file:///home/user/cg-game-apps/node_modules/p5/dist/webgl/GeometryBufferCache.js"],"sourcesContent":["class GeometryBufferCache {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this.cache = {};\n  }\n\n  numCached() {\n    return Object.keys(this.cache).length;\n  }\n\n  isCached(gid) {\n    return this.cache[gid] !== undefined;\n  }\n\n  getGeometryByID(gid) {\n    return this.cache[gid]?.geometry;\n  }\n\n  getCached(model) {\n    return this.getCachedID(model.gid);\n  }\n\n  getCachedID(gid) {\n    return this.cache[gid];\n  }\n\n  ensureCached(geometry) {\n    const gid = geometry.gid;\n    if (!gid) {\n      throw new Error('The p5.Geometry you passed in has no gid property!');\n    }\n\n    if (this.isCached(geometry.gid)) return this.getCached(geometry);\n\n    const gl = this.renderer.GL;\n\n    //initialize the gl buffers for our geom groups\n    this.freeBuffers(gid);\n\n    if (Object.keys(this.cache).length > 1000) {\n      const key = Object.keys(this.cache)[0];\n      this.freeBuffers(key);\n    }\n\n    //create a new entry in our cache\n    const buffers = {};\n    this.cache[gid] = buffers;\n\n    buffers.geometry = geometry;\n\n    let indexBuffer = buffers.indexBuffer;\n\n    if (geometry.faces.length) {\n      // allocate space for faces\n      if (!indexBuffer) indexBuffer = buffers.indexBuffer = gl.createBuffer();\n      const vals = geometry.faces.flat();\n\n      // If any face references a vertex with an index greater than the maximum\n      // un-singed 16 bit integer, then we need to use a Uint32Array instead of a\n      // Uint16Array\n      const hasVertexIndicesOverMaxUInt16 = vals.some(v => v > 65535);\n      let type = hasVertexIndicesOverMaxUInt16 ? Uint32Array : Uint16Array;\n      this.renderer._bindBuffer(indexBuffer, gl.ELEMENT_ARRAY_BUFFER, vals, type);\n\n      // If we're using a Uint32Array for our indexBuffer we will need to pass a\n      // different enum value to WebGL draw triangles. This happens in\n      // the _drawElements function.\n      buffers.indexBufferType = hasVertexIndicesOverMaxUInt16\n        ? gl.UNSIGNED_INT\n        : gl.UNSIGNED_SHORT;\n    } else {\n      // the index buffer is unused, remove it\n      if (indexBuffer) {\n        gl.deleteBuffer(indexBuffer);\n        buffers.indexBuffer = null;\n      }\n    }\n\n    return buffers;\n  }\n\n  freeBuffers(gid) {\n    const buffers = this.cache[gid];\n    if (!buffers) {\n      return;\n    }\n\n    delete this.cache[gid];\n\n    const gl = this.renderer.GL;\n    if (buffers.indexBuffer) {\n      gl.deleteBuffer(buffers.indexBuffer);\n    }\n\n    function freeBuffers(defs) {\n      for (const def of defs) {\n        if (buffers[def.dst]) {\n          gl.deleteBuffer(buffers[def.dst]);\n          buffers[def.dst] = null;\n        }\n      }\n    }\n\n    // free all the buffers\n    freeBuffers(this.renderer.buffers.stroke);\n    freeBuffers(this.renderer.buffers.fill);\n    freeBuffers(this.renderer.buffers.user);\n  }\n}\n\nexport { GeometryBufferCache };\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3441, "column": 0}, "map": {"version":3,"sources":["file:///home/user/cg-game-apps/node_modules/p5/dist/webgl/interaction.js"],"sourcesContent":["import { G as GRID, A as AXES } from '../constants-C-g_eAdC.js';\nimport { Vector } from '../math/p5.Vector.js';\n\n/**\n * @module 3D\n * @submodule Interaction\n * @for p5\n * @requires core\n */\n\n\nfunction interaction(p5, fn){\n  /**\n   * Allows the user to orbit around a 3D sketch using a mouse, trackpad, or\n   * touchscreen.\n   *\n   * 3D sketches are viewed through an imaginary camera. Calling\n   * `orbitControl()` within the <a href=\"#/p5/draw\">draw()</a> function allows\n   * the user to change the camera’s position:\n   *\n   * ```js\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Rest of sketch.\n   * }\n   * ```\n   *\n   * Left-clicking and dragging or swipe motion will rotate the camera position\n   * about the center of the sketch. Right-clicking and dragging or multi-swipe\n   * will pan the camera position without rotation. Using the mouse wheel\n   * (scrolling) or pinch in/out will move the camera further or closer from the\n   * center of the sketch.\n   *\n   * The first three parameters, `sensitivityX`, `sensitivityY`, and\n   * `sensitivityZ`, are optional. They’re numbers that set the sketch’s\n   * sensitivity to movement along each axis. For example, calling\n   * `orbitControl(1, 2, -1)` keeps movement along the x-axis at its default\n   * value, makes the sketch twice as sensitive to movement along the y-axis,\n   * and reverses motion along the z-axis. By default, all sensitivity values\n   * are 1.\n   *\n   * The fourth parameter, `options`, is also optional. It’s an object that\n   * changes the behavior of orbiting. For example, calling\n   * `orbitControl(1, 1, 1, options)` keeps the default sensitivity values while\n   * changing the behaviors set with `options`. The object can have the\n   * following properties:\n   *\n   * ```js\n   * let options = {\n   *   // Setting this to false makes mobile interactions smoother by\n   *   // preventing accidental interactions with the page while orbiting.\n   *   // By default, it's true.\n   *   disableTouchActions: true,\n   *\n   *   // Setting this to true makes the camera always rotate in the\n   *   // direction the mouse/touch is moving.\n   *   // By default, it's false.\n   *   freeRotation: false\n   * };\n   *\n   * orbitControl(1, 1, 1, options);\n   * ```\n   *\n   * @method orbitControl\n   * @for p5\n   * @param  {Number} [sensitivityX] sensitivity to movement along the x-axis. Defaults to 1.\n   * @param  {Number} [sensitivityY] sensitivity to movement along the y-axis. Defaults to 1.\n   * @param  {Number} [sensitivityZ] sensitivity to movement along the z-axis. Defaults to 1.\n   * @param  {Object} [options] object with two optional properties, `disableTouchActions`\n   *                            and `freeRotation`. Both are `Boolean`s. `disableTouchActions`\n   *                            defaults to `true` and `freeRotation` defaults to `false`.\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A multicolor box on a gray background. The camera angle changes when the user interacts using a mouse, trackpad, or touchscreen.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Style the box.\n   *   normalMaterial();\n   *\n   *   // Draw the box.\n   *   box(30, 50);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A multicolor box on a gray background. The camera angle changes when the user interacts using a mouse, trackpad, or touchscreen.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   // Make the interactions 3X sensitive.\n   *   orbitControl(3, 3, 3);\n   *\n   *   // Style the box.\n   *   normalMaterial();\n   *\n   *   // Draw the box.\n   *   box(30, 50);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A multicolor box on a gray background. The camera angle changes when the user interacts using a mouse, trackpad, or touchscreen.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Create an options object.\n   *   let options = {\n   *     disableTouchActions: false,\n   *     freeRotation: true\n   *   };\n   *\n   *   // Enable orbiting with the mouse.\n   *   // Prevent accidental touch actions on touchscreen devices\n   *   // and enable free rotation.\n   *   orbitControl(1, 1, 1, options);\n   *\n   *   // Style the box.\n   *   normalMaterial();\n   *\n   *   // Draw the box.\n   *   box(30, 50);\n   * }\n   * </code>\n   * </div>\n   */\n\n  // implementation based on three.js 'orbitControls':\n  // https://github.com/mrdoob/three.js/blob/6afb8595c0bf8b2e72818e42b64e6fe22707d896/examples/jsm/controls/OrbitControls.js#L22\n  fn.orbitControl = function(\n    sensitivityX,\n    sensitivityY,\n    sensitivityZ,\n    options\n  ) {\n    this._assert3d('orbitControl');\n    // p5._validateParameters('orbitControl', arguments);\n\n    const cam = this._renderer.states.curCamera;\n\n    if (typeof sensitivityX === 'undefined') {\n      sensitivityX = 1;\n    }\n    if (typeof sensitivityY === 'undefined') {\n      sensitivityY = sensitivityX;\n    }\n    if (typeof sensitivityZ === 'undefined') {\n      sensitivityZ = 1;\n    }\n    if (typeof options !== 'object') {\n      options = {};\n    }\n\n    // default right-mouse and mouse-wheel behaviors (context menu and scrolling,\n    // respectively) are disabled here to allow use of those events for panning and\n    // zooming. However, whether or not to disable touch actions is an option.\n\n    // disable context menu for canvas element and add 'contextMenuDisabled'\n    // flag to p5 instance\n    if (this.contextMenuDisabled !== true) {\n      this.canvas.oncontextmenu = () => false;\n      this.contextMenuDisabled = true;\n    }\n\n    // disable default scrolling behavior on the canvas element and add\n    // 'wheelDefaultDisabled' flag to p5 instance\n    if (this.wheelDefaultDisabled !== true) {\n      this.canvas.onwheel = () => false;\n      this.wheelDefaultDisabled = true;\n    }\n\n    // disable default touch behavior on the canvas element and add\n    // 'touchActionsDisabled' flag to p5 instance\n    const { disableTouchActions = true } = options;\n    if (this.touchActionsDisabled !== true && disableTouchActions) {\n      this.canvas.style['touch-action'] = 'none';\n      this.touchActionsDisabled = true;\n    }\n\n    // If option.freeRotation is true, the camera always rotates freely in the direction\n    // the pointer moves. default value is false (normal behavior)\n    const { freeRotation = false } = options;\n\n    // get moved touches.\n    const movedTouches = [];\n\n    this.touches.forEach(curTouch => {\n      this._renderer.prevTouches.forEach(prevTouch => {\n        if (curTouch.id === prevTouch.id) {\n          const movedTouch = {\n            x: curTouch.x,\n            y: curTouch.y,\n            px: prevTouch.x,\n            py: prevTouch.y\n          };\n          movedTouches.push(movedTouch);\n        }\n      });\n    });\n\n    this._renderer.prevTouches = this.touches;\n\n    // The idea of using damping is based on the following website. thank you.\n    // https://github.com/freshfork/p5.EasyCam/blob/9782964680f6a5c4c9bee825c475d9f2021d5134/p5.easycam.js#L1124\n\n    // variables for interaction\n    let deltaRadius = 0;\n    let deltaTheta = 0;\n    let deltaPhi = 0;\n    let moveDeltaX = 0;\n    let moveDeltaY = 0;\n    // constants for dampingProcess\n    const damping = 0.85;\n    const rotateAccelerationFactor = 0.6;\n    const moveAccelerationFactor = 0.15;\n    // For touches, the appropriate scale is different\n    // because the distance difference is multiplied.\n    const mouseZoomScaleFactor = 0.01;\n    const touchZoomScaleFactor = 0.0004;\n    const scaleFactor = this.height < this.width ? this.height : this.width;\n    // Flag whether the mouse or touch pointer is inside the canvas\n    let pointersInCanvas = false;\n\n    // calculate and determine flags and variables.\n    if (movedTouches.length > 0) {\n      /* for touch */\n      // if length === 1, rotate\n      // if length > 1, zoom and move\n\n      // for touch, it is calculated based on one moved touch pointer position.\n      pointersInCanvas =\n        movedTouches[0].x > 0 && movedTouches[0].x < this.width &&\n        movedTouches[0].y > 0 && movedTouches[0].y < this.height;\n\n      if (movedTouches.length === 1) {\n        const t = movedTouches[0];\n        deltaTheta = -sensitivityX * (t.x - t.px) / scaleFactor;\n        deltaPhi = sensitivityY * (t.y - t.py) / scaleFactor;\n      } else {\n        const t0 = movedTouches[0];\n        const t1 = movedTouches[1];\n        const distWithTouches = Math.hypot(t0.x - t1.x, t0.y - t1.y);\n        const prevDistWithTouches = Math.hypot(t0.px - t1.px, t0.py - t1.py);\n        const changeDist = distWithTouches - prevDistWithTouches;\n        // move the camera farther when the distance between the two touch points\n        // decreases, move the camera closer when it increases.\n        deltaRadius = -changeDist * sensitivityZ * touchZoomScaleFactor;\n        // Move the center of the camera along with the movement of\n        // the center of gravity of the two touch points.\n        moveDeltaX = 0.5 * (t0.x + t1.x) - 0.5 * (t0.px + t1.px);\n        moveDeltaY = 0.5 * (t0.y + t1.y) - 0.5 * (t0.py + t1.py);\n      }\n      if (this.touches.length > 0) {\n        if (pointersInCanvas) {\n          // Initiate an interaction if touched in the canvas\n          this._renderer.executeRotateAndMove = true;\n          this._renderer.executeZoom = true;\n        }\n      } else {\n        // End an interaction when the touch is released\n        this._renderer.executeRotateAndMove = false;\n        this._renderer.executeZoom = false;\n      }\n    } else {\n      /* for mouse */\n      // if wheelDeltaY !== 0, zoom\n      // if mouseLeftButton is down, rotate\n      // if mouseRightButton is down, move\n\n      // For mouse, it is calculated based on the mouse position.\n      pointersInCanvas =\n        (this.mouseX > 0 && this.mouseX < this.width) &&\n        (this.mouseY > 0 && this.mouseY < this.height);\n\n      if (this._mouseWheelDeltaY !== 0) {\n        // zoom the camera depending on the value of _mouseWheelDeltaY.\n        // move away if positive, move closer if negative\n        deltaRadius = Math.sign(this._mouseWheelDeltaY) * sensitivityZ;\n        deltaRadius *= mouseZoomScaleFactor;\n        this._mouseWheelDeltaY = 0;\n        // start zoom when the mouse is wheeled within the canvas.\n        if (pointersInCanvas) this._renderer.executeZoom = true;\n      } else {\n        // quit zoom when you stop wheeling.\n        this._renderer.executeZoom = false;\n      }\n      if (this.mouseIsPressed) {\n        if (this.mouseButton.left) {\n          deltaTheta = -sensitivityX * this.movedX / scaleFactor;\n          deltaPhi = sensitivityY * this.movedY / scaleFactor;\n        } else if (this.mouseButton.right) {\n          moveDeltaX = this.movedX;\n          moveDeltaY =  this.movedY * cam.yScale;\n        }\n        // start rotate and move when mouse is pressed within the canvas.\n        if (pointersInCanvas) this._renderer.executeRotateAndMove = true;\n      } else {\n        // quit rotate and move if mouse is released.\n        this._renderer.executeRotateAndMove = false;\n      }\n    }\n\n    // interactions\n\n    // zoom process\n    if (deltaRadius !== 0 && this._renderer.executeZoom) {\n      // accelerate zoom velocity\n      this._renderer.zoomVelocity += deltaRadius;\n    }\n    if (Math.abs(this._renderer.zoomVelocity) > 0.001) {\n      // if freeRotation is true, we use _orbitFree() instead of _orbit()\n      if (freeRotation) {\n        cam._orbitFree(\n          0, 0, this._renderer.zoomVelocity\n        );\n      } else {\n        cam._orbit(\n          0, 0, this._renderer.zoomVelocity\n        );\n      }\n      // In orthogonal projection, the scale does not change even if\n      // the distance to the gaze point is changed, so the projection matrix\n      // needs to be modified.\n      if (cam.projMatrix.mat4[15] !== 0) {\n        cam.projMatrix.mat4[0] *= Math.pow(\n          10, -this._renderer.zoomVelocity\n        );\n        cam.projMatrix.mat4[5] *= Math.pow(\n          10, -this._renderer.zoomVelocity\n        );\n        // modify uPMatrix\n        this._renderer.states.setValue('uPMatrix', this._renderer.states.uPMatrix.clone());\n        this._renderer.states.uPMatrix.mat4[0] = cam.projMatrix.mat4[0];\n        this._renderer.states.uPMatrix.mat4[5] = cam.projMatrix.mat4[5];\n      }\n      // damping\n      this._renderer.zoomVelocity *= damping;\n    } else {\n      this._renderer.zoomVelocity = 0;\n    }\n\n    // rotate process\n    if ((deltaTheta !== 0 || deltaPhi !== 0) &&\n    this._renderer.executeRotateAndMove) {\n      // accelerate rotate velocity\n      this._renderer.rotateVelocity.add(\n        deltaTheta * rotateAccelerationFactor,\n        deltaPhi * rotateAccelerationFactor\n      );\n    }\n    if (this._renderer.rotateVelocity.magSq() > 0.000001) {\n      // if freeRotation is true, the camera always rotates freely in the direction the pointer moves\n      if (freeRotation) {\n        cam._orbitFree(\n          -this._renderer.rotateVelocity.x,\n          this._renderer.rotateVelocity.y,\n          0\n        );\n      } else {\n        cam._orbit(\n          this._renderer.rotateVelocity.x,\n          this._renderer.rotateVelocity.y,\n          0\n        );\n      }\n      // damping\n      this._renderer.rotateVelocity.mult(damping);\n    } else {\n      this._renderer.rotateVelocity.set(0, 0);\n    }\n\n    // move process\n    if ((moveDeltaX !== 0 || moveDeltaY !== 0) &&\n    this._renderer.executeRotateAndMove) {\n      // Normalize movement distance\n      const ndcX = moveDeltaX * 2/this.width;\n      const ndcY = -moveDeltaY * 2/this.height;\n      // accelerate move velocity\n      this._renderer.moveVelocity.add(\n        ndcX * moveAccelerationFactor,\n        ndcY * moveAccelerationFactor\n      );\n    }\n    if (this._renderer.moveVelocity.magSq() > 0.000001) {\n      // Translate the camera so that the entire object moves\n      // perpendicular to the line of sight when the mouse is moved\n      // or when the centers of gravity of the two touch pointers move.\n      const local = cam._getLocalAxes();\n\n      // Calculate the z coordinate in the view coordinates of\n      // the center, that is, the distance to the view point\n      const diffX = cam.eyeX - cam.centerX;\n      const diffY = cam.eyeY - cam.centerY;\n      const diffZ = cam.eyeZ - cam.centerZ;\n      const viewZ = Math.sqrt(diffX * diffX + diffY * diffY + diffZ * diffZ);\n\n      // position vector of the center.\n      let cv = new Vector(cam.centerX, cam.centerY, cam.centerZ);\n\n      // Calculate the normalized device coordinates of the center.\n      cv = cam.cameraMatrix.multiplyPoint(cv);\n      cv = this._renderer.states.uPMatrix.multiplyAndNormalizePoint(cv);\n\n      // Move the center by this distance\n      // in the normalized device coordinate system.\n      cv.x -= this._renderer.moveVelocity.x;\n      cv.y -= this._renderer.moveVelocity.y;\n\n      // Calculate the translation vector\n      // in the direction perpendicular to the line of sight of center.\n      let dx, dy;\n      const uP = this._renderer.states.uPMatrix.mat4;\n\n      if (uP[15] === 0) {\n        dx = ((uP[8] + cv.x)/uP[0]) * viewZ;\n        dy = ((uP[9] + cv.y)/uP[5]) * viewZ;\n      } else {\n        dx = (cv.x - uP[12])/uP[0];\n        dy = (cv.y - uP[13])/uP[5];\n      }\n\n      // translate the camera.\n      cam.setPosition(\n        cam.eyeX + dx * local.x[0] + dy * local.y[0],\n        cam.eyeY + dx * local.x[1] + dy * local.y[1],\n        cam.eyeZ + dx * local.x[2] + dy * local.y[2]\n      );\n      // damping\n      this._renderer.moveVelocity.mult(damping);\n    } else {\n      this._renderer.moveVelocity.set(0, 0);\n    }\n\n    return this;\n  };\n\n\n  /**\n   * Adds a grid and an axes icon to clarify orientation in 3D sketches.\n   *\n   * `debugMode()` adds a grid that shows where the “ground” is in a sketch. By\n   * default, the grid will run through the origin `(0, 0, 0)` of the sketch\n   * along the XZ plane. `debugMode()` also adds an axes icon that points along\n   * the positive x-, y-, and z-axes. Calling `debugMode()` displays the grid\n   * and axes icon with their default size and position.\n   *\n   * There are four ways to call `debugMode()` with optional parameters to\n   * customize the debugging environment.\n   *\n   * The first way to call `debugMode()` has one parameter, `mode`. If the\n   * system constant `GRID` is passed, as in `debugMode(GRID)`, then the grid\n   * will be displayed and the axes icon will be hidden. If the constant `AXES`\n   * is passed, as in `debugMode(AXES)`, then the axes icon will be displayed\n   * and the grid will be hidden.\n   *\n   * The second way to call `debugMode()` has six parameters. The first\n   * parameter, `mode`, selects either `GRID` or `AXES` to be displayed. The\n   * next five parameters, `gridSize`, `gridDivisions`, `xOff`, `yOff`, and\n   * `zOff` are optional. They’re numbers that set the appearance of the grid\n   * (`gridSize` and `gridDivisions`) and the placement of the axes icon\n   * (`xOff`, `yOff`, and `zOff`). For example, calling\n   * `debugMode(20, 5, 10, 10, 10)` sets the `gridSize` to 20 pixels, the number\n   * of `gridDivisions` to 5, and offsets the axes icon by 10 pixels along the\n   * x-, y-, and z-axes.\n   *\n   * The third way to call `debugMode()` has five parameters. The first\n   * parameter, `mode`, selects either `GRID` or `AXES` to be displayed. The\n   * next four parameters, `axesSize`, `xOff`, `yOff`, and `zOff` are optional.\n   * They’re numbers that set the appearance of the size of the axes icon\n   * (`axesSize`) and its placement (`xOff`, `yOff`, and `zOff`).\n   *\n   * The fourth way to call `debugMode()` has nine optional parameters. The\n   * first five parameters, `gridSize`, `gridDivisions`, `gridXOff`, `gridYOff`,\n   * and `gridZOff` are numbers that set the appearance of the grid. For\n   * example, calling `debugMode(100, 5, 0, 0, 0)` sets the `gridSize` to 100,\n   * the number of `gridDivisions` to 5, and sets all the offsets to 0 so that\n   * the grid is centered at the origin. The next four parameters, `axesSize`,\n   * `xOff`, `yOff`, and `zOff` are numbers that set the appearance of the size\n   * of the axes icon (`axesSize`) and its placement (`axesXOff`, `axesYOff`,\n   * and `axesZOff`). For example, calling\n   * `debugMode(100, 5, 0, 0, 0, 50, 10, 10, 10)` sets the `gridSize` to 100,\n   * the number of `gridDivisions` to 5, and sets all the offsets to 0 so that\n   * the grid is centered at the origin. It then sets the `axesSize` to 50 and\n   * offsets the icon 10 pixels along each axis.\n   *\n   * @method debugMode\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Enable debug mode.\n   *   debugMode();\n   *\n   *   describe('A multicolor box on a gray background. A grid and axes icon are displayed near the box.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Style the box.\n   *   normalMaterial();\n   *\n   *   // Draw the box.\n   *   box(20, 40);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Enable debug mode.\n   *   // Only display the axes icon.\n   *   debugMode(AXES);\n   *\n   *   describe('A multicolor box on a gray background. A grid and axes icon are displayed near the box.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Style the box.\n   *   normalMaterial();\n   *\n   *   // Draw the box.\n   *   box(20, 40);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Enable debug mode.\n   *   // Only display the grid and customize it:\n   *   // - size: 50\n   *   // - divisions: 10\n   *   // - offsets: 0, 20, 0\n   *   debugMode(GRID, 50, 10, 0, 20, 0);\n   *\n   *   describe('A multicolor box on a gray background. A grid is displayed below the box.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Style the box.\n   *   normalMaterial();\n   *\n   *   // Draw the box.\n   *   box(20, 40);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Enable debug mode.\n   *   // Display the grid and axes icon and customize them:\n   *   // Grid\n   *   // ----\n   *   // - size: 50\n   *   // - divisions: 10\n   *   // - offsets: 0, 20, 0\n   *   // Axes\n   *   // ----\n   *   // - size: 50\n   *   // - offsets: 0, 0, 0\n   *   debugMode(50, 10, 0, 20, 0, 50, 0, 0, 0);\n   *\n   *   describe('A multicolor box on a gray background. A grid is displayed below the box. An axes icon is displayed at the center of the box.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Style the box.\n   *   normalMaterial();\n   *\n   *   // Draw the box.\n   *   box(20, 40);\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * @method debugMode\n   * @param {(GRID|AXES)} mode either GRID or AXES\n   */\n\n  /**\n   * @method debugMode\n   * @param {(GRID|AXES)} mode\n   * @param {Number} [gridSize] side length of the grid.\n   * @param {Number} [gridDivisions] number of divisions in the grid.\n   * @param {Number} [xOff] offset from origin along the x-axis.\n   * @param {Number} [yOff] offset from origin along the y-axis.\n   * @param {Number} [zOff] offset from origin along the z-axis.\n   */\n\n  /**\n   * @method debugMode\n   * @param {(GRID|AXES)} mode\n   * @param {Number} [axesSize] length of axes icon markers.\n   * @param {Number} [xOff]\n   * @param {Number} [yOff]\n   * @param {Number} [zOff]\n   */\n\n  /**\n   * @method debugMode\n   * @param {Number} [gridSize]\n   * @param {Number} [gridDivisions]\n   * @param {Number} [gridXOff] grid offset from the origin along the x-axis.\n   * @param {Number} [gridYOff] grid offset from the origin along the y-axis.\n   * @param {Number} [gridZOff] grid offset from the origin along the z-axis.\n   * @param {Number} [axesSize]\n   * @param {Number} [axesXOff] axes icon offset from the origin along the x-axis.\n   * @param {Number} [axesYOff] axes icon offset from the origin along the y-axis.\n   * @param {Number} [axesZOff] axes icon offset from the origin along the z-axis.\n   */\n\n  fn.debugMode = function(...args) {\n    this._assert3d('debugMode');\n    // p5._validateParameters('debugMode', args);\n\n    // start by removing existing 'post' registered debug methods\n    for (let i = p5.lifecycleHooks.postdraw.length - 1; i >= 0; i--) {\n      // test for equality...\n      if (\n        p5.lifecycleHooks.postdraw[i].toString() === this._grid().toString() ||\n        p5.lifecycleHooks.postdraw[i].toString() === this._axesIcon().toString()\n      ) {\n        p5.lifecycleHooks.postdraw.splice(i, 1);\n      }\n    }\n\n    // then add new debugMode functions according to the argument list\n    if (args[0] === GRID) {\n      p5.lifecycleHooks.postdraw.push(\n        this._grid(args[1], args[2], args[3], args[4], args[5])\n      );\n    } else if (args[0] === AXES) {\n      p5.lifecycleHooks.postdraw.push(\n        this._axesIcon(args[1], args[2], args[3], args[4])\n      );\n    } else {\n      p5.lifecycleHooks.postdraw.push(\n        this._grid(args[0], args[1], args[2], args[3], args[4])\n      );\n      p5.lifecycleHooks.postdraw.push(\n        this._axesIcon(args[5], args[6], args[7], args[8])\n      );\n    }\n  };\n\n  /**\n   * Turns off <a href=\"#/p5/debugMode\">debugMode()</a> in a 3D sketch.\n   *\n   * @method noDebugMode\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Enable debug mode.\n   *   debugMode();\n   *\n   *   describe('A multicolor box on a gray background. A grid and axes icon are displayed near the box. They disappear when the user double-clicks.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Style the box.\n   *   normalMaterial();\n   *\n   *   // Draw the box.  box(20, 40);\n   * }\n   *\n   * // Disable debug mode when the user double-clicks.\n   * function doubleClicked() {\n   *   noDebugMode();\n   * }\n   * </code>\n   * </div>\n   */\n  fn.noDebugMode = function() {\n    this._assert3d('noDebugMode');\n\n    // start by removing existing 'post' registered debug methods\n    for (let i = p5.lifecycleHooks.postdraw.length - 1; i >= 0; i--) {\n      // test for equality...\n      if (\n        p5.lifecycleHooks.postdraw[i].toString() === this._grid().toString() ||\n        p5.lifecycleHooks.postdraw[i].toString() === this._axesIcon().toString()\n      ) {\n        p5.lifecycleHooks.postdraw.splice(i, 1);\n      }\n    }\n  };\n\n  /**\n   * For use with debugMode\n   * @private\n   * @method _grid\n   * @param {Number} [size] size of grid sides\n   * @param {Number} [div] number of grid divisions\n   * @param {Number} [xOff] offset of grid center from origin in X axis\n   * @param {Number} [yOff] offset of grid center from origin in Y axis\n   * @param {Number} [zOff] offset of grid center from origin in Z axis\n   */\n  fn._grid = function(size, numDivs, xOff, yOff, zOff) {\n    if (typeof size === 'undefined') {\n      size = this.width / 2;\n    }\n    if (typeof numDivs === 'undefined') {\n      // ensure at least 2 divisions\n      numDivs = Math.round(size / 30) < 4 ? 4 : Math.round(size / 30);\n    }\n    if (typeof xOff === 'undefined') {\n      xOff = 0;\n    }\n    if (typeof yOff === 'undefined') {\n      yOff = 0;\n    }\n    if (typeof zOff === 'undefined') {\n      zOff = 0;\n    }\n\n    const spacing = size / numDivs;\n    const halfSize = size / 2;\n\n    return function() {\n      this.push();\n      this.stroke(\n        this._renderer.states.curStrokeColor[0] * 255,\n        this._renderer.states.curStrokeColor[1] * 255,\n        this._renderer.states.curStrokeColor[2] * 255\n      );\n      this._renderer.states.setValue('uModelMatrix', this._renderer.states.uModelMatrix.clone());\n      this._renderer.states.uModelMatrix.reset();\n\n      // Lines along X axis\n      for (let q = 0; q <= numDivs; q++) {\n        this.beginShape(this.LINES);\n        this.vertex(-halfSize + xOff, yOff, q * spacing - halfSize + zOff);\n        this.vertex(+halfSize + xOff, yOff, q * spacing - halfSize + zOff);\n        this.endShape();\n      }\n\n      // Lines along Z axis\n      for (let i = 0; i <= numDivs; i++) {\n        this.beginShape(this.LINES);\n        this.vertex(i * spacing - halfSize + xOff, yOff, -halfSize + zOff);\n        this.vertex(i * spacing - halfSize + xOff, yOff, +halfSize + zOff);\n        this.endShape();\n      }\n\n      this.pop();\n    };\n  };\n\n  /**\n   * For use with debugMode\n   * @private\n   * @method _axesIcon\n   * @param {Number} [size] size of axes icon lines\n   * @param {Number} [xOff] offset of icon from origin in X axis\n   * @param {Number} [yOff] offset of icon from origin in Y axis\n   * @param {Number} [zOff] offset of icon from origin in Z axis\n   */\n  fn._axesIcon = function(size, xOff, yOff, zOff) {\n    if (typeof size === 'undefined') {\n      size = this.width / 20 > 40 ? this.width / 20 : 40;\n    }\n    if (typeof xOff === 'undefined') {\n      xOff = -this.width / 4;\n    }\n    if (typeof yOff === 'undefined') {\n      yOff = xOff;\n    }\n    if (typeof zOff === 'undefined') {\n      zOff = xOff;\n    }\n\n    return () => {\n      this.push();\n      this._renderer.states.setValue('uModelMatrix', this._renderer.states.uModelMatrix.clone());\n      this._renderer.states.uModelMatrix.reset();\n\n      // X axis\n      this.strokeWeight(2);\n      this.stroke(255, 0, 0);\n      this.beginShape(this.LINES);\n      this.vertex(xOff, yOff, zOff);\n      this.vertex(xOff + size, yOff, zOff);\n      this.endShape();\n      // Y axis\n      this.stroke(0, 255, 0);\n      this.beginShape(this.LINES);\n      this.vertex(xOff, yOff, zOff);\n      this.vertex(xOff, yOff + size, zOff);\n      this.endShape();\n      // Z axis\n      this.stroke(0, 0, 255);\n      this.beginShape(this.LINES);\n      this.vertex(xOff, yOff, zOff);\n      this.vertex(xOff, yOff, zOff + size);\n      this.endShape();\n      this.pop();\n    };\n  };\n}\n\nif(typeof p5 !== 'undefined'){\n  interaction(p5, p5.prototype);\n}\n\nexport { interaction as default };\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4224, "column": 0}, "map": {"version":3,"sources":["file:///home/user/cg-game-apps/node_modules/p5/dist/webgl/loading.js"],"sourcesContent":["import { Geometry } from './p5.Geometry.js';\nimport { Vector } from '../math/p5.Vector.js';\nimport { a as request } from '../rendering--aAe5aq3.js';\nimport '../constants-C-g_eAdC.js';\nimport './p5.DataArray.js';\nimport '../creating_reading-D4AAKRbx.js';\nimport 'colorjs.io/fn';\nimport '../color/color_spaces/hsb.js';\nimport '../dom/p5.Element.js';\nimport '../dom/p5.File.js';\nimport '../io/p5.XML.js';\nimport '../p5.Renderer-CwAYZOC2.js';\nimport '../image/filters.js';\nimport '../shape/custom_shapes.js';\nimport '../core/States.js';\nimport '../io/utilities.js';\nimport 'file-saver';\nimport '../dom/p5.MediaElement.js';\nimport '../shape/2d_primitives.js';\nimport '../core/helpers.js';\nimport '../shape/attributes.js';\nimport '../shape/curves.js';\nimport '../shape/vertex.js';\nimport '../color/setting.js';\nimport 'omggif';\nimport '../io/csv.js';\nimport 'gifenc';\nimport '../image/pixels.js';\nimport '../core/transform.js';\nimport './GeometryBuilder.js';\nimport '../math/p5.Matrix.js';\nimport '../math/Matrices/Matrix.js';\nimport '../math/Matrices/MatrixInterface.js';\nimport './p5.Quat.js';\nimport './p5.RenderBuffer.js';\nimport './ShapeBuilder.js';\nimport 'libtess';\nimport './GeometryBufferCache.js';\nimport '../image/const.js';\nimport '../math/trigonometry.js';\n\n/**\n * @module Shape\n * @submodule 3D Models\n * @for p5\n * @requires core\n * @requires p5.Geometry\n */\n\n\nasync function fileExists(url) {\n  try {\n    const response = await fetch(url, { method: 'HEAD' });\n    return response.ok;\n  } catch (error) {\n    return false;\n  }\n}\n\nfunction loading(p5, fn){\n  /**\n   * Loads a 3D model to create a\n   * <a href=\"#/p5.Geometry\">p5.Geometry</a> object.\n   *\n   * `loadModel()` can load 3D models from OBJ and STL files. Once the model is\n   * loaded, it can be displayed with the\n   * <a href=\"#/p5/model\">model()</a> function, as in `model(shape)`.\n   *\n   * There are three ways to call `loadModel()` with optional parameters to help\n   * process the model.\n   *\n   * The first parameter, `path`, is a `String` with the path to the file. Paths\n   * to local files should be relative, as in `loadModel('assets/model.obj')`.\n   * URLs such as `'https://example.com/model.obj'` may be blocked due to browser\n   * security. The `path` parameter can also be defined as a [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request)\n   * object for more advanced usage.\n   * Note: When loading a `.obj` file that references materials stored in\n   * `.mtl` files, p5.js will attempt to load and apply those materials.\n   * To ensure that the `.obj` file reads the `.mtl` file correctly include the\n   * `.mtl` file alongside it.\n   *\n   * The first way to call `loadModel()` has three optional parameters after the\n   * file path. The first optional parameter, `successCallback`, is a function\n   * to call once the model loads. For example,\n   * `loadModel('assets/model.obj', handleModel)` will call the `handleModel()`\n   * function once the model loads. The second optional parameter,\n   * `failureCallback`, is a function to call if the model fails to load. For\n   * example, `loadModel('assets/model.obj', handleModel, handleFailure)` will\n   * call the `handleFailure()` function if an error occurs while loading. The\n   * third optional parameter, `fileType`, is the model’s file extension as a\n   * string. For example,\n   * `loadModel('assets/model', handleModel, handleFailure, '.obj')` will try to\n   * load the file model as a `.obj` file.\n   *\n   * The second way to call `loadModel()` has four optional parameters after the\n   * file path. The first optional parameter is a `Boolean` value. If `true` is\n   * passed, as in `loadModel('assets/model.obj', true)`, then the model will be\n   * resized to ensure it fits the canvas. The next three parameters are\n   * `successCallback`, `failureCallback`, and `fileType` as described above.\n   *\n   * The third way to call `loadModel()` has one optional parameter after the\n   * file path. The optional parameter, `options`, is an `Object` with options,\n   * as in `loadModel('assets/model.obj', options)`. The `options` object can\n   * have the following properties:\n   *\n   * ```js\n   * let options = {\n   *   // Enables standardized size scaling during loading if set to true.\n   *   normalize: true,\n   *\n   *   // Function to call once the model loads.\n   *   successCallback: handleModel,\n   *\n   *   // Function to call if an error occurs while loading.\n   *   failureCallback: handleError,\n   *\n   *   // Model's file extension.\n   *   fileType: '.stl',\n   *\n   *   // Flips the U texture coordinates of the model.\n   *   flipU: false,\n   *\n   *   // Flips the V texture coordinates of the model.\n   *   flipV: false\n   * };\n   *\n   * // Pass the options object to loadModel().\n   * loadModel('assets/model.obj', options);\n   * ```\n   *\n   * This function returns a `Promise` and should be used in an `async` setup with\n   * `await`. See the examples for the usage syntax.\n   *\n   * Note: There’s no support for colored STL files. STL files with color will\n   * be rendered without color.\n   *\n   * @method loadModel\n   * @param  {String|Request} path      path of the model to be loaded.\n   * @param  {String} [fileType]          model’s file extension. Either `'.obj'` or `'.stl'`.\n   * @param  {Boolean} normalize        if `true`, scale the model to fit the canvas.\n   * @param  {function(p5.Geometry)} [successCallback] function to call once the model is loaded. Will be passed\n   *                                                   the <a href=\"#/p5.Geometry\">p5.Geometry</a> object.\n   * @param  {function(Event)} [failureCallback] function to call if the model fails to load. Will be passed an `Error` event object.\n   * @return {Promise<p5.Geometry>} the <a href=\"#/p5.Geometry\">p5.Geometry</a> object\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let shape;\n   *\n   * // Load the file and create a p5.Geometry object.\n   * async function setup() {\n   *   shape = await loadModel('assets/teapot.obj');\n   *\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A white teapot drawn against a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the shape.\n   *   model(shape);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let shape;\n   *\n   * // Load the file and create a p5.Geometry object.\n   * // Normalize the geometry's size to fit the canvas.\n   * async function setup() {\n   *   shape = await loadModel('assets/teapot.obj', true);\n   *\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A white teapot drawn against a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the shape.\n   *   model(shape);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let shape;\n   *\n   * // Load the file and create a p5.Geometry object.\n   * async function setup() {\n   *   await loadModel('assets/teapot.obj', true, handleModel);\n   *\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A white teapot drawn against a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the shape.\n   *   model(shape);\n   * }\n   *\n   * // Set the shape variable and log the geometry's\n   * // ID to the console.\n   * function handleModel(data) {\n   *   shape = data;\n   *   console.log(shape.gid);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div class='notest'>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let shape;\n   *\n   * // Load the file and create a p5.Geometry object.\n   * async function setup() {\n   *   await loadModel('assets/teapot.obj', true, handleModel, handleError);\n   *\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A white teapot drawn against a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the shape.\n   *   model(shape);\n   * }\n   *\n   * // Set the shape variable and print the geometry's\n   * // ID to the console.\n   * function handleModel(data) {\n   *   shape = data;\n   *   console.log(shape.gid);\n   * }\n   *\n   * // Print an error message if the file doesn't load.\n   * function handleError(error) {\n   *   console.error('Oops!', error);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let shape;\n   *\n   * // Load the file and create a p5.Geometry object.\n   * async function setup() {\n   *   await loadModel('assets/teapot.obj', '.obj', true, handleModel, handleError);\n   *\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A white teapot drawn against a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the shape.\n   *   model(shape);\n   * }\n   *\n   * // Set the shape variable and print the geometry's\n   * // ID to the console.\n   * function handleModel(data) {\n   *   shape = data;\n   *   console.log(shape.gid);\n   * }\n   *\n   * // Print an error message if the file doesn't load.\n   * function handleError(error) {\n   *   console.error('Oops!', error);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let shape;\n   * let options = {\n   *   fileType: '.obj',\n   *   normalize: true,\n   *   successCallback: handleModel,\n   *   failureCallback: handleError\n   * };\n   *\n   * // Load the file and create a p5.Geometry object.\n   * async function setup() {\n   *   await loadModel('assets/teapot.obj', options);\n   *\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A white teapot drawn against a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the shape.\n   *   model(shape);\n   * }\n   *\n   * // Set the shape variable and print the geometry's\n   * // ID to the console.\n   * function handleModel(data) {\n   *   shape = data;\n   *   console.log(shape.gid);\n   * }\n   *\n   * // Print an error message if the file doesn't load.\n   * function handleError(error) {\n   *   console.error('Oops!', error);\n   * }\n   * </code>\n   * </div>\n   */\n  /**\n   * @method loadModel\n   * @param  {String|Request} path\n   * @param  {String} [fileType]\n   * @param  {function(p5.Geometry)} [successCallback]\n   * @param  {function(Event)} [failureCallback]\n   * @return {Promise<p5.Geometry>} new <a href=\"#/p5.Geometry\">p5.Geometry</a> object.\n   */\n  /**\n   * @method loadModel\n   * @param  {String|Request} path\n   * @param  {Object} [options] loading options.\n   * @param  {String} [options.fileType]\n   * @param  {function(p5.Geometry)} [options.successCallback]\n   * @param  {function(Event)} [options.failureCallback]\n   * @param  {Boolean} [options.normalize]\n   * @param  {Boolean} [options.flipU]\n   * @param  {Boolean} [options.flipV]\n   * @return {Promise<p5.Geometry>} new <a href=\"#/p5.Geometry\">p5.Geometry</a> object.\n   */\n  fn.loadModel = async function (path, fileType, normalize, successCallback, failureCallback) {\n    // p5._validateParameters('loadModel', arguments);\n\n    let flipU = false;\n    let flipV = false;\n\n    if (typeof fileType === 'object') {\n      // Passing in options object\n      normalize = fileType.normalize || false;\n      successCallback = fileType.successCallback;\n      failureCallback = fileType.failureCallback;\n      fileType = fileType.fileType || fileType;\n      flipU = fileType.flipU || false;\n      flipV = fileType.flipV || false;\n\n    } else {\n      // Passing in individual parameters\n      if(typeof arguments[arguments.length-1] === 'function'){\n        if(typeof arguments[arguments.length-2] === 'function'){\n          successCallback = arguments[arguments.length-2];\n          failureCallback = arguments[arguments.length-1];\n        }else {\n          successCallback = arguments[arguments.length-1];\n        }\n      }\n\n      if (typeof fileType === 'string') {\n        if(typeof normalize !== 'boolean') normalize = false;\n\n      } else if (typeof fileType === 'boolean') {\n        normalize = fileType;\n        fileType = path.slice(-4);\n\n      } else {\n        fileType = path.slice(-4);\n        normalize = false;\n      }\n    }\n\n    if (fileType.toLowerCase() !== '.obj' && fileType.toLowerCase() !== '.stl') {\n      fileType = '.obj';\n    }\n\n    const model = new Geometry(undefined, undefined, undefined, this._renderer);\n    model.gid = `${path}|${normalize}`;\n\n    async function getMaterials(lines) {\n      const parsedMaterialPromises = [];\n\n      for (let line of lines) {\n        const mtllibMatch = line.match(/^mtllib (.+)/);\n\n        if (mtllibMatch) {\n          // Object has material\n          let mtlPath = '';\n          const mtlFilename = mtllibMatch[1];\n          const objPathParts = path.split('/');\n          if (objPathParts.length > 1) {\n            objPathParts.pop();\n            const objFolderPath = objPathParts.join('/');\n            mtlPath = objFolderPath + '/' + mtlFilename;\n          } else {\n            mtlPath = mtlFilename;\n          }\n\n          parsedMaterialPromises.push(\n            fileExists(mtlPath).then(exists => {\n              if (exists) {\n                return parseMtl(mtlPath);\n              } else {\n                console.warn(`MTL file not found or error in parsing; proceeding without materials: ${mtlPath}`);\n                return {};\n\n              }\n            }).catch(error => {\n              console.warn(`Error loading MTL file: ${mtlPath}`, error);\n              return {};\n            })\n          );\n        }\n      }\n\n      try {\n        const parsedMaterials = await Promise.all(parsedMaterialPromises);\n        const materials = Object.assign({}, ...parsedMaterials);\n        return materials;\n      } catch (error) {\n        return {};\n      }\n    }\n\n    try{\n      if (fileType.match(/\\.stl$/i)) {\n        const { data } = await request(path, 'arrayBuffer');\n        parseSTL(model, data);\n\n        if (normalize) {\n          model.normalize();\n        }\n\n        if (flipU) {\n          model.flipU();\n        }\n\n        if (flipV) {\n          model.flipV();\n        }\n        model._makeTriangleEdges();\n\n        if (successCallback) {\n          return successCallback(model);\n        } else {\n          return model;\n        }\n\n      } else if (fileType.match(/\\.obj$/i)) {\n        const { data } = await request(path, 'text');\n        const lines = data.split('\\n');\n\n        const parsedMaterials = await getMaterials(lines);\n        parseObj(model, lines, parsedMaterials);\n\n        if (normalize) {\n          model.normalize();\n        }\n        if (flipU) {\n          model.flipU();\n        }\n        if (flipV) {\n          model.flipV();\n        }\n        model._makeTriangleEdges();\n\n        if (successCallback) {\n          return successCallback(model);\n        } else {\n          return model;\n        }\n      }\n    } catch(err) {\n      p5._friendlyFileLoadError(3, path);\n      if(failureCallback) {\n        return failureCallback(err);\n      } else {\n        throw err;\n      }\n    }\n  };\n\n  /**\n   * @private\n   */\n  async function parseMtl(mtlPath) {\n    let currentMaterial = null;\n    let materials = {};\n\n    const { data } = await request(mtlPath, \"text\");\n    const lines = data.split('\\n');\n\n    for (let line = 0; line < lines.length; ++line) {\n      const tokens = lines[line].trim().split(/\\s+/);\n      if (tokens[0] === 'newmtl') {\n        const materialName = tokens[1];\n        currentMaterial = materialName;\n        materials[currentMaterial] = {};\n      } else if (tokens[0] === 'Kd') {\n        //Diffuse color\n        materials[currentMaterial].diffuseColor = [\n          parseFloat(tokens[1]),\n          parseFloat(tokens[2]),\n          parseFloat(tokens[3])\n        ];\n      } else if (tokens[0] === 'Ka') {\n        //Ambient Color\n        materials[currentMaterial].ambientColor = [\n          parseFloat(tokens[1]),\n          parseFloat(tokens[2]),\n          parseFloat(tokens[3])\n        ];\n      } else if (tokens[0] === 'Ks') {\n        //Specular color\n        materials[currentMaterial].specularColor = [\n          parseFloat(tokens[1]),\n          parseFloat(tokens[2]),\n          parseFloat(tokens[3])\n        ];\n\n      } else if (tokens[0] === 'map_Kd') {\n        //Texture path\n        materials[currentMaterial].texturePath = tokens[1];\n      }\n    }\n\n    return materials;\n  }\n\n  /**\n   * @private\n   * Parse OBJ lines into model. For reference, this is what a simple model of a\n   * square might look like:\n   *\n   * v -0.5 -0.5 0.5\n   * v -0.5 -0.5 -0.5\n   * v -0.5 0.5 -0.5\n   * v -0.5 0.5 0.5\n   *\n   * f 4 3 2 1\n   */\n  function parseObj(model, lines, materials = {}) {\n    // OBJ allows a face to specify an index for a vertex (in the above example),\n    // but it also allows you to specify a custom combination of vertex, UV\n    // coordinate, and vertex normal. So, \"3/4/3\" would mean, \"use vertex 3 with\n    // UV coordinate 4 and vertex normal 3\". In WebGL, every vertex with different\n    // parameters must be a different vertex, so loadedVerts is used to\n    // temporarily store the parsed vertices, normals, etc., and indexedVerts is\n    // used to map a specific combination (keyed on, for example, the string\n    // \"3/4/3\"), to the actual index of the newly created vertex in the final\n    // object.\n    const loadedVerts = {\n      v: [],\n      vt: [],\n      vn: []\n    };\n\n\n    // Map from source index → Map of material → destination index\n    const usedVerts = {}; // Track colored vertices\n    let currentMaterial = null;\n    let hasColoredVertices = false;\n    let hasColorlessVertices = false;\n    for (let line = 0; line < lines.length; ++line) {\n      // Each line is a separate object (vertex, face, vertex normal, etc)\n      // For each line, split it into tokens on whitespace. The first token\n      // describes the type.\n      const tokens = lines[line].trim().split(/\\b\\s+/);\n\n      if (tokens.length > 0) {\n        if (tokens[0] === 'usemtl') {\n          // Switch to a new material\n          currentMaterial = tokens[1];\n        } else if (tokens[0] === 'v' || tokens[0] === 'vn') {\n          // Check if this line describes a vertex or vertex normal.\n          // It will have three numeric parameters.\n          const vertex = new Vector(\n            parseFloat(tokens[1]),\n            parseFloat(tokens[2]),\n            parseFloat(tokens[3])\n          );\n          loadedVerts[tokens[0]].push(vertex);\n        } else if (tokens[0] === 'vt') {\n          // Check if this line describes a texture coordinate.\n          // It will have two numeric parameters U and V (W is omitted).\n          // Because of WebGL texture coordinates rendering behaviour, the V\n          // coordinate is inversed.\n          const texVertex = [parseFloat(tokens[1]), 1 - parseFloat(tokens[2])];\n          loadedVerts[tokens[0]].push(texVertex);\n        } else if (tokens[0] === 'f') {\n          // Check if this line describes a face.\n          // OBJ faces can have more than three points. Triangulate points.\n          for (let tri = 3; tri < tokens.length; ++tri) {\n            const face = [];\n            const vertexTokens = [1, tri - 1, tri];\n\n            for (let tokenInd = 0; tokenInd < vertexTokens.length; ++tokenInd) {\n              // Now, convert the given token into an index\n              const vertString = tokens[vertexTokens[tokenInd]];\n              let vertParts = vertString.split('/');\n\n              // TODO: Faces can technically use negative numbers to refer to the\n              // previous nth vertex. I haven't seen this used in practice, but\n              // it might be good to implement this in the future.\n\n              for (let i = 0; i < vertParts.length; i++) {\n                vertParts[i] = parseInt(vertParts[i]) - 1;\n              }\n\n              if (!usedVerts[vertString]) {\n                usedVerts[vertString] = {};\n              }\n\n              if (usedVerts[vertString][currentMaterial] === undefined) {\n                const vertIndex = model.vertices.length;\n                model.vertices.push(loadedVerts.v[vertParts[0]].copy());\n                model.uvs.push(loadedVerts.vt[vertParts[1]] ?\n                  loadedVerts.vt[vertParts[1]].slice() : [0, 0]);\n                model.vertexNormals.push(loadedVerts.vn[vertParts[2]] ?\n                  loadedVerts.vn[vertParts[2]].copy() : new Vector());\n\n                usedVerts[vertString][currentMaterial] = vertIndex;\n                face.push(vertIndex);\n                if (currentMaterial\n                  && materials[currentMaterial]\n                  && materials[currentMaterial].diffuseColor) {\n                  hasColoredVertices = true;\n                  const materialDiffuseColor =\n                    materials[currentMaterial].diffuseColor;\n                  model.vertexColors.push(materialDiffuseColor[0]);\n                  model.vertexColors.push(materialDiffuseColor[1]);\n                  model.vertexColors.push(materialDiffuseColor[2]);\n                  model.vertexColors.push(1);\n                } else {\n                  hasColorlessVertices = true;\n                }\n              } else {\n                face.push(usedVerts[vertString][currentMaterial]);\n              }\n            }\n\n            if (\n              face[0] !== face[1] &&\n              face[0] !== face[2] &&\n              face[1] !== face[2]\n            ) {\n              model.faces.push(face);\n            }\n          }\n        }\n      }\n    }\n    // If the model doesn't have normals, compute the normals\n    if (model.vertexNormals.length === 0) {\n      model.computeNormals();\n    }\n    if (hasColoredVertices === hasColorlessVertices) {\n      // If both are true or both are false, throw an error because the model is inconsistent\n      throw new Error('Model coloring is inconsistent. Either all vertices should have colors or none should.');\n    }\n\n    return model;\n  }\n\n  /**\n   * @private\n   * STL files can be of two types, ASCII and Binary,\n   *\n   * We need to convert the arrayBuffer to an array of strings,\n   * to parse it as an ASCII file.\n   */\n  function parseSTL(model, buffer) {\n    if (isBinary(buffer)) {\n      parseBinarySTL(model, buffer);\n    } else {\n      const reader = new DataView(buffer);\n\n      if (!('TextDecoder' in window)) {\n        console.warn(\n          'Sorry, ASCII STL loading only works in browsers that support TextDecoder (https://caniuse.com/#feat=textencoder)'\n        );\n        return model;\n      }\n\n      const decoder = new TextDecoder('utf-8');\n      const lines = decoder.decode(reader);\n      const lineArray = lines.split('\\n');\n      parseASCIISTL(model, lineArray);\n    }\n    return model;\n  }\n\n  /**\n   * @private\n   * This function checks if the file is in ASCII format or in Binary format\n   *\n   * It is done by searching keyword `solid` at the start of the file.\n   *\n   * An ASCII STL data must begin with `solid` as the first six bytes.\n   * However, ASCII STLs lacking the SPACE after the `d` are known to be\n   * plentiful. So, check the first 5 bytes for `solid`.\n   *\n   * Several encodings, such as UTF-8, precede the text with up to 5 bytes:\n   * https://en.wikipedia.org/wiki/Byte_order_mark#Byte_order_marks_by_encoding\n   * Search for `solid` to start anywhere after those prefixes.\n   */\n  function isBinary(data) {\n    const reader = new DataView(data);\n\n    // US-ASCII ordinal values for `s`, `o`, `l`, `i`, `d`\n    const solid = [115, 111, 108, 105, 100];\n    for (let off = 0; off < 5; off++) {\n      // If \"solid\" text is matched to the current offset, declare it to be an ASCII STL.\n      if (matchDataViewAt(solid, reader, off)) return false;\n    }\n\n    // Couldn't find \"solid\" text at the beginning; it is binary STL.\n    return true;\n  }\n\n  /**\n   * @private\n   * This function matches the `query` at the provided `offset`\n   */\n  function matchDataViewAt(query, reader, offset) {\n    // Check if each byte in query matches the corresponding byte from the current offset\n    for (let i = 0, il = query.length; i < il; i++) {\n      if (query[i] !== reader.getUint8(offset + i, false)) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * @private\n   * This function parses the Binary STL files.\n   * https://en.wikipedia.org/wiki/STL_%28file_format%29#Binary_STL\n   *\n   * Currently there is no support for the colors provided in STL files.\n   */\n  function parseBinarySTL(model, buffer) {\n    const reader = new DataView(buffer);\n\n    // Number of faces is present following the header\n    const faces = reader.getUint32(80, true);\n    let r,\n      g,\n      b,\n      hasColors = false,\n      colors;\n    let defaultR, defaultG, defaultB;\n\n    // Binary files contain 80-byte header, which is generally ignored.\n    for (let index = 0; index < 80 - 10; index++) {\n      // Check for `COLOR=`\n      if (\n        reader.getUint32(index, false) === 0x434f4c4f /*COLO*/ &&\n        reader.getUint8(index + 4) === 0x52 /*'R'*/ &&\n        reader.getUint8(index + 5) === 0x3d /*'='*/\n      ) {\n        hasColors = true;\n        colors = [];\n\n        defaultR = reader.getUint8(index + 6) / 255;\n        defaultG = reader.getUint8(index + 7) / 255;\n        defaultB = reader.getUint8(index + 8) / 255;\n        // To be used when color support is added\n        // alpha = reader.getUint8(index + 9) / 255;\n      }\n    }\n    const dataOffset = 84;\n    const faceLength = 12 * 4 + 2;\n\n    // Iterate the faces\n    for (let face = 0; face < faces; face++) {\n      const start = dataOffset + face * faceLength;\n      const normalX = reader.getFloat32(start, true);\n      const normalY = reader.getFloat32(start + 4, true);\n      const normalZ = reader.getFloat32(start + 8, true);\n\n      if (hasColors) {\n        const packedColor = reader.getUint16(start + 48, true);\n\n        if ((packedColor & 0x8000) === 0) {\n          // facet has its own unique color\n          r = (packedColor & 0x1f) / 31;\n          g = ((packedColor >> 5) & 0x1f) / 31;\n          b = ((packedColor >> 10) & 0x1f) / 31;\n        } else {\n          r = defaultR;\n          g = defaultG;\n          b = defaultB;\n        }\n      }\n      const newNormal = new Vector(normalX, normalY, normalZ);\n\n      for (let i = 1; i <= 3; i++) {\n        const vertexstart = start + i * 12;\n\n        const newVertex = new Vector(\n          reader.getFloat32(vertexstart, true),\n          reader.getFloat32(vertexstart + 4, true),\n          reader.getFloat32(vertexstart + 8, true)\n        );\n\n        model.vertices.push(newVertex);\n        model.vertexNormals.push(newNormal);\n\n        if (hasColors) {\n          colors.push(r, g, b);\n        }\n      }\n\n      model.faces.push([3 * face, 3 * face + 1, 3 * face + 2]);\n      model.uvs.push([0, 0], [0, 0], [0, 0]);\n    }\n    return model;\n  }\n\n  /**\n   * @private\n   * ASCII STL file starts with `solid 'nameOfFile'`\n   * Then contain the normal of the face, starting with `facet normal`\n   * Next contain a keyword indicating the start of face vertex, `outer loop`\n   * Next comes the three vertex, starting with `vertex x y z`\n   * Vertices ends with `endloop`\n   * Face ends with `endfacet`\n   * Next face starts with `facet normal`\n   * The end of the file is indicated by `endsolid`\n   */\n  function parseASCIISTL(model, lines) {\n    let state = '';\n    let curVertexIndex = [];\n    let newNormal, newVertex;\n\n    for (let iterator = 0; iterator < lines.length; ++iterator) {\n      const line = lines[iterator].trim();\n      const parts = line.split(' ');\n\n      for (let partsiterator = 0; partsiterator < parts.length; ++partsiterator) {\n        if (parts[partsiterator] === '') {\n          // Ignoring multiple whitespaces\n          parts.splice(partsiterator, 1);\n        }\n      }\n\n      if (parts.length === 0) {\n        // Remove newline\n        continue;\n      }\n\n      switch (state) {\n        case '': // First run\n          if (parts[0] !== 'solid') {\n            // Invalid state\n            console.error(line);\n            console.error(`Invalid state \"${parts[0]}\", should be \"solid\"`);\n            return;\n          } else {\n            state = 'solid';\n          }\n          break;\n\n        case 'solid': // First face\n          if (parts[0] !== 'facet' || parts[1] !== 'normal') {\n            // Invalid state\n            console.error(line);\n            console.error(\n              `Invalid state \"${parts[0]}\", should be \"facet normal\"`\n            );\n            return;\n          } else {\n            // Push normal for first face\n            newNormal = new Vector(\n              parseFloat(parts[2]),\n              parseFloat(parts[3]),\n              parseFloat(parts[4])\n            );\n            model.vertexNormals.push(newNormal, newNormal, newNormal);\n            state = 'facet normal';\n          }\n          break;\n\n        case 'facet normal': // After normal is defined\n          if (parts[0] !== 'outer' || parts[1] !== 'loop') {\n            // Invalid State\n            console.error(line);\n            console.error(`Invalid state \"${parts[0]}\", should be \"outer loop\"`);\n            return;\n          } else {\n            // Next should be vertices\n            state = 'vertex';\n          }\n          break;\n\n        case 'vertex':\n          if (parts[0] === 'vertex') {\n            //Vertex of triangle\n            newVertex = new Vector(\n              parseFloat(parts[1]),\n              parseFloat(parts[2]),\n              parseFloat(parts[3])\n            );\n            model.vertices.push(newVertex);\n            model.uvs.push([0, 0]);\n            curVertexIndex.push(model.vertices.indexOf(newVertex));\n          } else if (parts[0] === 'endloop') {\n            // End of vertices\n            model.faces.push(curVertexIndex);\n            curVertexIndex = [];\n            state = 'endloop';\n          } else {\n            // Invalid State\n            console.error(line);\n            console.error(\n              `Invalid state \"${parts[0]}\", should be \"vertex\" or \"endloop\"`\n            );\n            return;\n          }\n          break;\n\n        case 'endloop':\n          if (parts[0] !== 'endfacet') {\n            // End of face\n            console.error(line);\n            console.error(`Invalid state \"${parts[0]}\", should be \"endfacet\"`);\n            return;\n          } else {\n            state = 'endfacet';\n          }\n          break;\n\n        case 'endfacet':\n          if (parts[0] === 'endsolid') ; else if (parts[0] === 'facet' && parts[1] === 'normal') {\n            // Next face\n            newNormal = new Vector(\n              parseFloat(parts[2]),\n              parseFloat(parts[3]),\n              parseFloat(parts[4])\n            );\n            model.vertexNormals.push(newNormal, newNormal, newNormal);\n            state = 'facet normal';\n          } else {\n            // Invalid State\n            console.error(line);\n            console.error(\n              `Invalid state \"${parts[0]\n              }\", should be \"endsolid\" or \"facet normal\"`\n            );\n            return;\n          }\n          break;\n\n        default:\n          console.error(`Invalid state \"${state}\"`);\n          break;\n      }\n    }\n    return model;\n  }\n\n  /**\n   * Draws a <a href=\"#/p5.Geometry\">p5.Geometry</a> object to the canvas.\n   *\n   * The parameter, `model`, is the\n   * <a href=\"#/p5.Geometry\">p5.Geometry</a> object to draw.\n   * <a href=\"#/p5.Geometry\">p5.Geometry</a> objects can be built with\n   * <a href=\"#/p5/buildGeometry\">buildGeometry()</a>, or\n   * <a href=\"#/p5/beginGeometry\">beginGeometry()</a> and\n   * <a href=\"#/p5/endGeometry\">endGeometry()</a>. They can also be loaded from\n   * a file with <a href=\"#/p5/loadGeometry\">loadGeometry()</a>.\n   *\n   * Note: `model()` can only be used in WebGL mode.\n   *\n   * @method model\n   * @param  {p5.Geometry} model 3D shape to be drawn.\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let shape;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create the p5.Geometry object.\n   *   shape = buildGeometry(createShape);\n   *\n   *   describe('A white cone drawn on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the p5.Geometry object.\n   *   model(shape);\n   * }\n   *\n   * // Create p5.Geometry object from a single cone.\n   * function createShape() {\n   *   cone();\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let shape;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create the p5.Geometry object.\n   *   shape = buildGeometry(createArrow);\n   *\n   *   describe('Two white arrows drawn on a gray background. The arrow on the right rotates slowly.');\n   * }\n   *\n   * function draw() {\n   *   background(50);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Style the arrows.\n   *   noStroke();\n   *\n   *   // Draw the p5.Geometry object.\n   *   model(shape);\n   *\n   *   // Translate and rotate the coordinate system.\n   *   translate(30, 0, 0);\n   *   rotateZ(frameCount * 0.01);\n   *\n   *   // Draw the p5.Geometry object again.\n   *   model(shape);\n   * }\n   *\n   * function createArrow() {\n   *   // Add shapes to the p5.Geometry object.\n   *   push();\n   *   rotateX(PI);\n   *   cone(10);\n   *   translate(0, -10, 0);\n   *   cylinder(3, 20);\n   *   pop();\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let shape;\n   *\n   * async function setup() {\n   *   shape = await loadModel('assets/octahedron.obj');\n   *\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A white octahedron drawn against a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the shape.\n   *   model(shape);\n   * }\n   * </code>\n   * </div>\n   */\n  fn.model = function (model, count = 1) {\n    this._assert3d('model');\n    // p5._validateParameters('model', arguments);\n    this._renderer.model(model, count);\n  };\n\n  /**\n   * Load a 3d model from an OBJ or STL string.\n   *\n   * OBJ and STL files lack a built-in sense of scale, causing models exported from different programs to vary in size.\n   * If your model doesn't display correctly, consider using `loadModel()` with `normalize` set to `true` to standardize its size.\n   * Further adjustments can be made using the `scale()` function.\n   *\n   * Also, the support for colored STL files is not present. STL files with color will be\n   * rendered without color properties.\n   *\n   * * Options can include:\n   * - `modelString`: Specifies the plain text string of either an stl or obj file to be loaded.\n   * - `fileType`: Defines the file extension of the model.\n   * - `normalize`: Enables standardized size scaling during loading if set to true.\n   * - `successCallback`: Callback for post-loading actions with the 3D model object.\n   * - `failureCallback`: Handles errors if model loading fails, receiving an event error.\n   * - `flipU`: Flips the U texture coordinates of the model.\n   * - `flipV`: Flips the V texture coordinates of the model.\n   *\n   *\n   * @method createModel\n   * @param  {String} modelString         String of the object to be loaded\n   * @param  {String} [fileType]          The file extension of the model\n   *                                      (<code>.stl</code>, <code>.obj</code>).\n   * @param  {Boolean} normalize        If true, scale the model to a\n   *                                      standardized size when loading\n   * @param  {function(p5.Geometry)} [successCallback] Function to be called\n   *                                     once the model is loaded. Will be passed\n   *                                     the 3D model object.\n   * @param  {function(Event)} [failureCallback] called with event error if\n   *                                         the model fails to load.\n   * @return {p5.Geometry} the <a href=\"#/p5.Geometry\">p5.Geometry</a> object\n   *\n   * @example\n   * <div>\n   * <code>\n   * const octahedron_model = `\n   * v 0.000000E+00 0.000000E+00 40.0000\n   * v 22.5000 22.5000 0.000000E+00\n   * v 22.5000 -22.5000 0.000000E+00\n   * v -22.5000 -22.5000 0.000000E+00\n   * v -22.5000 22.5000 0.000000E+00\n   * v 0.000000E+00 0.000000E+00 -40.0000\n   * f     1 2 3\n   * f     1 3 4\n   * f     1 4 5\n   * f     1 5 2\n   * f     6 5 4\n   * f     6 4 3\n   * f     6 3 2\n   * f     6 2 5\n   * `;\n   * //draw a spinning octahedron\n   * let octahedron;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *   octahedron = createModel(octahedron_model, '.obj');\n   *   describe('Vertically rotating 3D octahedron.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *   rotateX(frameCount * 0.01);\n   *   rotateY(frameCount * 0.01);\n   *   model(octahedron);\n   *}\n   * </code>\n   * </div>\n   */\n  /**\n   * @method createModel\n   * @param  {String} modelString\n   * @param  {String} [fileType]\n   * @param  {function(p5.Geometry)} [successCallback]\n   * @param  {function(Event)} [failureCallback]\n   * @return {p5.Geometry} the <a href=\"#/p5.Geometry\">p5.Geometry</a> object\n   */\n  /**\n   * @method createModel\n   * @param  {String} modelString\n   * @param  {String} [fileType]\n   * @param  {Object} [options]\n   * @param  {function(p5.Geometry)} [options.successCallback]\n   * @param  {function(Event)} [options.failureCallback]\n   * @param  {boolean} [options.normalize]\n   * @param  {boolean} [options.flipU]\n   * @param  {boolean} [options.flipV]\n   * @return {p5.Geometry} the <a href=\"#/p5.Geometry\">p5.Geometry</a> object\n   */\n  let modelCounter = 0;\n  fn.createModel = function(modelString, fileType=' ', options) {\n    // p5._validateParameters('createModel', arguments);\n    let normalize= false;\n    let successCallback;\n    let failureCallback;\n    let flipU = false;\n    let flipV = false;\n    if (options && typeof options === 'object') {\n      normalize = options.normalize || false;\n      successCallback = options.successCallback;\n      failureCallback = options.failureCallback;\n      flipU = options.flipU || false;\n      flipV = options.flipV || false;\n    } else if (typeof options === 'boolean') {\n      normalize = options;\n      successCallback = arguments[3];\n      failureCallback = arguments[4];\n    } else {\n      successCallback = typeof arguments[2] === 'function' ? arguments[2] : undefined;\n      failureCallback = arguments[3];\n    }\n    const model = new p5.Geometry();\n    model.gid = `${fileType}|${normalize}|${modelCounter++}`;\n\n    if (fileType.match(/\\.stl$/i)) {\n      try {\n        let uint8array = new TextEncoder().encode(modelString);\n        let arrayBuffer = uint8array.buffer;\n        parseSTL(model, arrayBuffer);\n      } catch (error) {\n        if (failureCallback) {\n          failureCallback(error);\n        } else {\n          p5._friendlyError('Error during parsing: ' + error.message);\n        }\n        return;\n      }\n    } else if (fileType.match(/\\.obj$/i)) {\n      try {\n        const lines = modelString.split('\\n');\n        parseObj(model, lines);\n      } catch (error) {\n        if (failureCallback) {\n          failureCallback(error);\n        } else {\n          p5._friendlyError('Error during parsing: ' + error.message);\n        }\n        return;\n      }\n    } else {\n      p5._friendlyFileLoadError(3, modelString);\n      if (failureCallback) {\n        failureCallback();\n      } else {\n        p5._friendlyError(\n          'Sorry, the file type is invalid. Only OBJ and STL files are supported.'\n        );\n      }\n    }\n    if (normalize) {\n      model.normalize();\n    }\n\n    if (flipU) {\n      model.flipU();\n    }\n\n    if (flipV) {\n      model.flipV();\n    }\n\n    model._makeTriangleEdges();\n\n    if (typeof successCallback === 'function') {\n      successCallback(model);\n    }\n\n    return model;\n  };\n}\n\nif(typeof p5 !== 'undefined'){\n  loading(p5, p5.prototype);\n}\n\nexport { loading as default };\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5470, "column": 0}, "map": {"version":3,"sources":["file:///home/user/cg-game-apps/node_modules/p5/dist/webgl/text.js"],"sourcesContent":["import { T as TEXTURE } from '../constants-C-g_eAdC.js';\nimport { R as RendererGL } from '../rendering--aAe5aq3.js';\nimport { Vector } from '../math/p5.Vector.js';\nimport { Geometry } from './p5.Geometry.js';\nimport { Font, arrayCommandsToObjects } from '../type/p5.Font.js';\nimport '../creating_reading-D4AAKRbx.js';\nimport 'colorjs.io/fn';\nimport '../color/color_spaces/hsb.js';\nimport '../dom/p5.Element.js';\nimport '../dom/p5.File.js';\nimport '../io/p5.XML.js';\nimport '../p5.Renderer-CwAYZOC2.js';\nimport '../image/filters.js';\nimport '../shape/custom_shapes.js';\nimport '../core/States.js';\nimport '../io/utilities.js';\nimport 'file-saver';\nimport '../dom/p5.MediaElement.js';\nimport '../shape/2d_primitives.js';\nimport '../core/helpers.js';\nimport '../shape/attributes.js';\nimport '../shape/curves.js';\nimport '../shape/vertex.js';\nimport '../color/setting.js';\nimport 'omggif';\nimport '../io/csv.js';\nimport 'gifenc';\nimport '../image/pixels.js';\nimport '../core/transform.js';\nimport './GeometryBuilder.js';\nimport '../math/p5.Matrix.js';\nimport '../math/Matrices/Matrix.js';\nimport '../math/Matrices/MatrixInterface.js';\nimport './p5.Quat.js';\nimport './p5.RenderBuffer.js';\nimport './p5.DataArray.js';\nimport './ShapeBuilder.js';\nimport 'libtess';\nimport './GeometryBufferCache.js';\nimport '../image/const.js';\nimport '../math/trigonometry.js';\nimport '../type/textCore.js';\nimport '@japont/unicode-range';\nimport '../type/unicodeRanges.js';\nimport '../type/lib/Typr.js';\nimport 'pako';\nimport '@davepagurek/bezier-path';\n\nfunction text(p5, fn) {\n  RendererGL.prototype.maxCachedGlyphs = function() {\n    // TODO: use more than vibes to find a good value for this\n    return 200\n  };\n\n  RendererGL.prototype.freeGlyphInfo = function(gi) {\n    const datas = [\n      gi.strokeImageInfo.imageData,\n      gi.rowInfo.cellImageInfo.imageData,\n      gi.rowInfo.dimImageInfo.imageData,\n      gi.colInfo.cellImageInfo.imageData,\n      gi.colInfo.dimImageInfo.imageData,\n    ];\n    for (const data of datas) {\n      const tex = this.textures.get(data);\n      if (tex) {\n        tex.remove();\n        this.textures.delete(data);\n      }\n    }\n  };\n\n  Font.prototype._getFontInfo = function(axs) {\n    // For WebGL, a cache of font data to use on the GPU.\n    this._fontInfos = this._fontInfos || {};\n\n    const key = JSON.stringify(axs);\n    if (this._fontInfos[key]) {\n      const val = this._fontInfos[key];\n      return val;\n    } else {\n      const val = new FontInfo(this, { axs });\n      this._fontInfos[key] = val;\n      return val;\n    }\n  };\n\n  // Text/Typography (see src/type/textCore.js)\n  /*\n  RendererGL.prototype.textWidth = function(s) {\n    if (this._isOpenType()) {\n      return this.states.textFont.font._textWidth(s, this.states.textSize);\n    }\n\n    return 0; // TODO: error\n  };\n  */\n\n  // rendering constants\n\n  // the number of rows/columns dividing each glyph\n  const charGridWidth = 9;\n  const charGridHeight = charGridWidth;\n\n  // size of the image holding the bezier stroke info\n  const strokeImageWidth = 64;\n  const strokeImageHeight = 64;\n\n  // size of the image holding the stroke indices for each row/col\n  const gridImageWidth = 64;\n  const gridImageHeight = 64;\n\n  // size of the image holding the offset/length of each row/col stripe\n  const cellImageWidth = 64;\n  const cellImageHeight = 64;\n\n  /**\n   * @private\n   * @class ImageInfos\n   * @param {Integer} width\n   * @param {Integer} height\n   *\n   * the ImageInfos class holds a list of ImageDatas of a given size.\n   */\n  class ImageInfos {\n    constructor(width, height) {\n      this.width = width;\n      this.height = height;\n      this.infos = []; // the list of images\n    }\n    /**\n     *\n     * @param {Integer} space\n     * @return {Object} contains the ImageData, and pixel index into that\n     *                  ImageData where the free space was allocated.\n     *\n     * finds free space of a given size in the ImageData list\n     */\n    findImage(space) {\n      const imageSize = this.width * this.height;\n      if (space > imageSize)\n        throw new Error(\"font is too complex to render in 3D\");\n\n      // search through the list of images, looking for one with\n      // anough unused space.\n      let imageInfo, imageData;\n      for (let ii = this.infos.length - 1; ii >= 0; --ii) {\n        const imageInfoTest = this.infos[ii];\n        if (imageInfoTest.index + space < imageSize) {\n          // found one\n          imageInfo = imageInfoTest;\n          imageData = imageInfoTest.imageData;\n          break;\n        }\n      }\n\n      if (!imageInfo) {\n        try {\n          // create a new image\n          imageData = new ImageData(this.width, this.height);\n        } catch (err) {\n          // for browsers that don't support ImageData constructors (ie IE11)\n          // create an ImageData using the old method\n          let canvas = document.getElementsByTagName(\"canvas\")[0];\n          const created = !canvas;\n          if (!canvas) {\n            // create a temporary canvas\n            canvas = document.createElement(\"canvas\");\n            canvas.style.display = \"none\";\n            document.body.appendChild(canvas);\n          }\n          const ctx = canvas.getContext(\"2d\");\n          if (ctx) {\n            imageData = ctx.createImageData(this.width, this.height);\n          }\n          if (created) {\n            // distroy the temporary canvas, if necessary\n            document.body.removeChild(canvas);\n          }\n        }\n        // construct & dd the new image info\n        imageInfo = { index: 0, imageData };\n        this.infos.push(imageInfo);\n      }\n\n      const index = imageInfo.index;\n      imageInfo.index += space; // move to the start of the next image\n      imageData._dirty = true;\n      return { imageData, index };\n    }\n  }\n\n  /**\n   * @function setPixel\n   * @param {Object} imageInfo\n   * @param {Number} r\n   * @param {Number} g\n   * @param {Number} b\n   * @param {Number} a\n   *\n   * writes the next pixel into an indexed ImageData\n   */\n  function setPixel(imageInfo, r, g, b, a) {\n    const imageData = imageInfo.imageData;\n    const pixels = imageData.data;\n    let index = imageInfo.index++ * 4;\n    pixels[index++] = r;\n    pixels[index++] = g;\n    pixels[index++] = b;\n    pixels[index++] = a;\n  }\n\n  const SQRT3 = Math.sqrt(3);\n\n  /**\n   * @private\n   * @class FontInfo\n   * @param {Object} font an opentype.js font object\n   *\n   * contains cached images and glyph information for an opentype font\n   */\n  class FontInfo {\n    constructor(font, { axs } = {}) {\n      this.font = font;\n      this.axs = axs;\n      // the bezier curve coordinates\n      this.strokeImageInfos = new ImageInfos(\n        strokeImageWidth,\n        strokeImageHeight,\n      );\n      // lists of curve indices for each row/column slice\n      this.colDimImageInfos = new ImageInfos(gridImageWidth, gridImageHeight);\n      this.rowDimImageInfos = new ImageInfos(gridImageWidth, gridImageHeight);\n      // the offset & length of each row/col slice in the glyph\n      this.colCellImageInfos = new ImageInfos(cellImageWidth, cellImageHeight);\n      this.rowCellImageInfos = new ImageInfos(cellImageWidth, cellImageHeight);\n\n      // the cached information for each glyph\n      this.glyphInfos = {};\n    }\n    /**\n     * @param {Glyph} glyph the x positions of points in the curve\n     * @returns {Object} the glyphInfo for that glyph\n     *\n     * calculates rendering info for a glyph, including the curve information,\n     * row & column stripes compiled into textures.\n     */\n    getGlyphInfo(glyph) {\n      // check the cache\n      let gi = this.glyphInfos[glyph.index];\n      if (gi) return gi;\n\n      const axs = this.axs;\n      const {\n        glyph: {\n          path: { commands },\n        },\n      } = this.font._singleShapeToPath(glyph.shape, { axs });\n      let xMin = Infinity;\n      let xMax = -Infinity;\n      let yMin = Infinity;\n      let yMax = -Infinity;\n\n      for (const cmd of commands) {\n        for (let i = 1; i < cmd.length; i += 2) {\n          xMin = Math.min(xMin, cmd[i]);\n          xMax = Math.max(xMax, cmd[i]);\n          yMin = Math.min(yMin, cmd[i + 1]);\n          yMax = Math.max(yMax, cmd[i + 1]);\n        }\n      }\n\n      // don't bother rendering invisible glyphs\n      if (xMin >= xMax || yMin >= yMax || !commands.length) {\n        return (this.glyphInfos[glyph.index] = {});\n      }\n\n      const gWidth = xMax - xMin;\n      const gHeight = yMax - yMin;\n\n      // Convert arrays to named objects\n      const cmds = arrayCommandsToObjects(commands);\n\n      let i;\n      const strokes = []; // the strokes in this glyph\n      const rows = []; // the indices of strokes in each row\n      const cols = []; // the indices of strokes in each column\n      for (i = charGridWidth - 1; i >= 0; --i) cols.push([]);\n      for (i = charGridHeight - 1; i >= 0; --i) rows.push([]);\n\n      /**\n       * @function push\n       * @param {Number[]} xs the x positions of points in the curve\n       * @param {Number[]} ys the y positions of points in the curve\n       * @param {Object} v    the curve information\n       *\n       * adds a curve to the rows & columns that it intersects with\n       */\n      function push(xs, ys, v) {\n        const index = strokes.length; // the index of this stroke\n        strokes.push(v); // add this stroke to the list\n\n        /**\n         * @function minMax\n         * @param {Number[]} rg the list of values to compare\n         * @param {Number} min the initial minimum value\n         * @param {Number} max the initial maximum value\n         *\n         * find the minimum & maximum value in a list of values\n         */\n        function minMax(rg, min, max) {\n          for (let i = rg.length; i-- > 0; ) {\n            const v = rg[i];\n            if (min > v) min = v;\n            if (max < v) max = v;\n          }\n          return { min, max };\n        }\n\n        // Expand the bounding box of the glyph by the number of cells below\n        // before rounding. Curves only partially through a cell won't be added\n        // to adjacent cells, but ones that are close will be. This helps fix\n        // small visual glitches that occur when curves are close to grid cell\n        // boundaries.\n        const cellOffset = 0.5;\n\n        // loop through the rows & columns that the curve intersects\n        // adding the curve to those slices\n        const mmX = minMax(xs, 1, 0);\n        const ixMin = Math.max(\n          Math.floor(mmX.min * charGridWidth - cellOffset),\n          0,\n        );\n        const ixMax = Math.min(\n          Math.ceil(mmX.max * charGridWidth + cellOffset),\n          charGridWidth,\n        );\n        for (let iCol = ixMin; iCol < ixMax; ++iCol) cols[iCol].push(index);\n\n        const mmY = minMax(ys, 1, 0);\n        const iyMin = Math.max(\n          Math.floor(mmY.min * charGridHeight - cellOffset),\n          0,\n        );\n        const iyMax = Math.min(\n          Math.ceil(mmY.max * charGridHeight + cellOffset),\n          charGridHeight,\n        );\n        for (let iRow = iyMin; iRow < iyMax; ++iRow) rows[iRow].push(index);\n      }\n\n      /**\n       * @function clamp\n       * @param {Number} v the value to clamp\n       * @param {Number} min the minimum value\n       * @param {Number} max the maxmimum value\n       *\n       * clamps a value between a minimum & maximum value\n       */\n      function clamp(v, min, max) {\n        if (v < min) return min;\n        if (v > max) return max;\n        return v;\n      }\n\n      /**\n       * @function byte\n       * @param {Number} v the value to scale\n       *\n       * converts a floating-point number in the range 0-1 to a byte 0-255\n       */\n      function byte(v) {\n        return clamp(255 * v, 0, 255);\n      }\n\n      /**\n       * @private\n       * @class Cubic\n       * @param {Number} p0 the start point of the curve\n       * @param {Number} c0 the first control point\n       * @param {Number} c1 the second control point\n       * @param {Number} p1 the end point\n       *\n       * a cubic curve\n       */\n      class Cubic {\n        constructor(p0, c0, c1, p1) {\n          this.p0 = p0;\n          this.c0 = c0;\n          this.c1 = c1;\n          this.p1 = p1;\n        }\n        /**\n         * @return {Object} the quadratic approximation\n         *\n         * converts the cubic to a quadtratic approximation by\n         * picking an appropriate quadratic control point\n         */\n        toQuadratic() {\n          return {\n            x: this.p0.x,\n            y: this.p0.y,\n            x1: this.p1.x,\n            y1: this.p1.y,\n            cx: ((this.c0.x + this.c1.x) * 3 - (this.p0.x + this.p1.x)) / 4,\n            cy: ((this.c0.y + this.c1.y) * 3 - (this.p0.y + this.p1.y)) / 4,\n          };\n        }\n\n        /**\n         * @return {Number} the error\n         *\n         * calculates the magnitude of error of this curve's\n         * quadratic approximation.\n         */\n        quadError() {\n          return (\n            Vector.sub(\n              Vector.sub(this.p1, this.p0),\n              Vector.mult(Vector.sub(this.c1, this.c0), 3),\n            ).mag() / 2\n          );\n        }\n\n        /**\n         * @param {Number} t the value (0-1) at which to split\n         * @return {Cubic} the second part of the curve\n         *\n         * splits the cubic into two parts at a point 't' along the curve.\n         * this cubic keeps its start point and its end point becomes the\n         * point at 't'. the 'end half is returned.\n         */\n        split(t) {\n          const m1 = Vector.lerp(this.p0, this.c0, t);\n          const m2 = Vector.lerp(this.c0, this.c1, t);\n          const mm1 = Vector.lerp(m1, m2, t);\n\n          this.c1 = Vector.lerp(this.c1, this.p1, t);\n          this.c0 = Vector.lerp(m2, this.c1, t);\n          const pt = Vector.lerp(mm1, this.c0, t);\n          const part1 = new Cubic(this.p0, m1, mm1, pt);\n          this.p0 = pt;\n          return part1;\n        }\n\n        /**\n         * @return {Cubic[]} the non-inflecting pieces of this cubic\n         *\n         * returns an array containing 0, 1 or 2 cubics split resulting\n         * from splitting this cubic at its inflection points.\n         * this cubic is (potentially) altered and returned in the list.\n         */\n        splitInflections() {\n          const a = Vector.sub(this.c0, this.p0);\n          const b = Vector.sub(Vector.sub(this.c1, this.c0), a);\n          const c = Vector.sub(\n            Vector.sub(Vector.sub(this.p1, this.c1), a),\n            Vector.mult(b, 2),\n          );\n\n          const cubics = [];\n\n          // find the derivative coefficients\n          let A = b.x * c.y - b.y * c.x;\n          if (A !== 0) {\n            let B = a.x * c.y - a.y * c.x;\n            let C = a.x * b.y - a.y * b.x;\n            const disc = B * B - 4 * A * C;\n            if (disc >= 0) {\n              if (A < 0) {\n                A = -A;\n                B = -B;\n                C = -C;\n              }\n\n              const Q = Math.sqrt(disc);\n              const t0 = (-B - Q) / (2 * A); // the first inflection point\n              let t1 = (-B + Q) / (2 * A); // the second inflection point\n\n              // test if the first inflection point lies on the curve\n              if (t0 > 0 && t0 < 1) {\n                // split at the first inflection point\n                cubics.push(this.split(t0));\n                // scale t2 into the second part\n                t1 = 1 - (1 - t1) / (1 - t0);\n              }\n\n              // test if the second inflection point lies on the curve\n              if (t1 > 0 && t1 < 1) {\n                // split at the second inflection point\n                cubics.push(this.split(t1));\n              }\n            }\n          }\n\n          cubics.push(this);\n          return cubics;\n        }\n      }\n\n      /**\n       * @function cubicToQuadratics\n       * @param {Number} x0\n       * @param {Number} y0\n       * @param {Number} cx0\n       * @param {Number} cy0\n       * @param {Number} cx1\n       * @param {Number} cy1\n       * @param {Number} x1\n       * @param {Number} y1\n       * @returns {Cubic[]} an array of cubics whose quadratic approximations\n       *                    closely match the civen cubic.\n       *\n       * converts a cubic curve to a list of quadratics.\n       */\n      function cubicToQuadratics(x0, y0, cx0, cy0, cx1, cy1, x1, y1) {\n        // create the Cubic object and split it at its inflections\n        const cubics = new Cubic(\n          new Vector(x0, y0),\n          new Vector(cx0, cy0),\n          new Vector(cx1, cy1),\n          new Vector(x1, y1),\n        ).splitInflections();\n\n        const qs = []; // the final list of quadratics\n        const precision = 30 / SQRT3;\n\n        // for each of the non-inflected pieces of the original cubic\n        for (let cubic of cubics) {\n          // the cubic is iteratively split in 3 pieces:\n          // the first piece is accumulated in 'qs', the result.\n          // the last piece is accumulated in 'tail', temporarily.\n          // the middle piece is repeatedly split again, while necessary.\n          const tail = [];\n\n          let t3;\n          for (;;) {\n            // calculate this cubic's precision\n            t3 = precision / cubic.quadError();\n            if (t3 >= 0.5 * 0.5 * 0.5) {\n              break; // not too bad, we're done\n            }\n\n            // find a split point based on the error\n            const t = Math.pow(t3, 1.0 / 3.0);\n            // split the cubic in 3\n            const start = cubic.split(t);\n            const middle = cubic.split(1 - t / (1 - t));\n\n            qs.push(start); // the first part\n            tail.push(cubic); // the last part\n            cubic = middle; // iterate on the middle piece\n          }\n\n          if (t3 < 1) {\n            // a little excess error, split the middle in two\n            qs.push(cubic.split(0.5));\n          }\n          // add the middle piece to the result\n          qs.push(cubic);\n\n          // finally add the tail, reversed, onto the result\n          Array.prototype.push.apply(qs, tail.reverse());\n        }\n\n        return qs;\n      }\n\n      /**\n       * @function pushLine\n       * @param {Number} x0\n       * @param {Number} y0\n       * @param {Number} x1\n       * @param {Number} y1\n       *\n       * add a straight line to the row/col grid of a glyph\n       */\n      function pushLine(x0, y0, x1, y1) {\n        const mx = (x0 + x1) / 2;\n        const my = (y0 + y1) / 2;\n        push([x0, x1], [y0, y1], { x: x0, y: y0, cx: mx, cy: my });\n      }\n\n      /**\n       * @function samePoint\n       * @param {Number} x0\n       * @param {Number} y0\n       * @param {Number} x1\n       * @param {Number} y1\n       * @return {Boolean} true if the two points are sufficiently close\n       *\n       * tests if two points are close enough to be considered the same\n       */\n      function samePoint(x0, y0, x1, y1) {\n        return Math.abs(x1 - x0) < 0.00001 && Math.abs(y1 - y0) < 0.00001;\n      }\n\n      let x0, y0, xs, ys;\n\n      for (const cmd of cmds) {\n        // scale the coordinates to the range 0-1\n        const x1 = (cmd.x - xMin) / gWidth;\n        const y1 = (cmd.y - yMin) / gHeight;\n\n        // don't bother if this point is the same as the last\n        if (samePoint(x0, y0, x1, y1)) continue;\n\n        switch (cmd.type) {\n          case \"M\": {\n            // move\n            xs = x1;\n            ys = y1;\n            break;\n          }\n          case \"L\": {\n            // line\n            pushLine(x0, y0, x1, y1);\n            break;\n          }\n          case \"Q\": {\n            // quadratic\n            const cx = (cmd.x1 - xMin) / gWidth;\n            const cy = (cmd.y1 - yMin) / gHeight;\n            push([x0, x1, cx], [y0, y1, cy], { x: x0, y: y0, cx, cy });\n            break;\n          }\n          case \"Z\": {\n            // end\n            if (!samePoint(x0, y0, xs, ys)) {\n              // add an extra line closing the loop, if necessary\n              pushLine(x0, y0, xs, ys);\n              strokes.push({ x: xs, y: ys });\n            } else {\n              strokes.push({ x: x0, y: y0 });\n            }\n            break;\n          }\n          case \"C\": {\n            // cubic\n            const cx1 = (cmd.x1 - xMin) / gWidth;\n            const cy1 = (cmd.y1 - yMin) / gHeight;\n            const cx2 = (cmd.x2 - xMin) / gWidth;\n            const cy2 = (cmd.y2 - yMin) / gHeight;\n            const qs = cubicToQuadratics(x0, y0, cx1, cy1, cx2, cy2, x1, y1);\n            for (let iq = 0; iq < qs.length; iq++) {\n              const q = qs[iq].toQuadratic();\n              push([q.x, q.x1, q.cx], [q.y, q.y1, q.cy], q);\n            }\n            break;\n          }\n          default:\n            throw new Error(`unknown command type: ${cmd.type}`);\n        }\n        x0 = x1;\n        y0 = y1;\n      }\n\n      // allocate space for the strokes\n      const strokeCount = strokes.length;\n      const strokeImageInfo = this.strokeImageInfos.findImage(strokeCount);\n      const strokeOffset = strokeImageInfo.index;\n\n      // fill the stroke image\n      for (let il = 0; il < strokeCount; ++il) {\n        const s = strokes[il];\n        setPixel(strokeImageInfo, byte(s.x), byte(s.y), byte(s.cx), byte(s.cy));\n      }\n\n      /**\n       * @function layout\n       * @param {Number[][]} dim\n       * @param {ImageInfo[]} dimImageInfos\n       * @param {ImageInfo[]} cellImageInfos\n       * @return {Object}\n       *\n       * lays out the curves in a dimension (row or col) into two\n       * images, one for the indices of the curves themselves, and\n       * one containing the offset and length of those index spans.\n       */\n      function layout(dim, dimImageInfos, cellImageInfos) {\n        const dimLength = dim.length; // the number of slices in this dimension\n        const dimImageInfo = dimImageInfos.findImage(dimLength);\n        const dimOffset = dimImageInfo.index;\n        // calculate the total number of stroke indices in this dimension\n        let totalStrokes = 0;\n        for (let id = 0; id < dimLength; ++id) {\n          totalStrokes += dim[id].length;\n        }\n\n        // allocate space for the stroke indices\n        const cellImageInfo = cellImageInfos.findImage(totalStrokes);\n\n        // for each slice in the glyph\n        for (let i = 0; i < dimLength; ++i) {\n          const strokeIndices = dim[i];\n          const strokeCount = strokeIndices.length;\n          const cellLineIndex = cellImageInfo.index;\n\n          // write the offset and count into the glyph slice image\n          setPixel(\n            dimImageInfo,\n            cellLineIndex >> 7,\n            cellLineIndex & 0x7f,\n            strokeCount >> 7,\n            strokeCount & 0x7f,\n          );\n\n          // for each stroke index in that slice\n          for (let iil = 0; iil < strokeCount; ++iil) {\n            // write the stroke index into the slice's image\n            const strokeIndex = strokeIndices[iil] + strokeOffset;\n            setPixel(cellImageInfo, strokeIndex >> 7, strokeIndex & 0x7f, 0, 0);\n          }\n        }\n\n        return {\n          cellImageInfo,\n          dimOffset,\n          dimImageInfo,\n        };\n      }\n\n      // initialize the info for this glyph\n      gi = this.glyphInfos[glyph.index] = {\n        glyph,\n        uGlyphRect: [xMin, yMin, xMax, yMax],\n        strokeImageInfo,\n        strokes,\n        colInfo: layout(cols, this.colDimImageInfos, this.colCellImageInfos),\n        rowInfo: layout(rows, this.rowDimImageInfos, this.rowCellImageInfos),\n      };\n      gi.uGridOffset = [gi.colInfo.dimOffset, gi.rowInfo.dimOffset];\n      return gi;\n    }\n  }\n\n  RendererGL.prototype._renderText = function (line, x, y, maxY, minY) {\n    if (!this.states.textFont || typeof this.states.textFont === \"string\") {\n      console.log(\n        \"WEBGL: you must load and set a font before drawing text. See `loadFont` and `textFont` for more details.\",\n      );\n      return;\n    }\n    if (y >= maxY || !this.states.fillColor) {\n      return; // don't render lines beyond our maxY position\n    }\n\n    if (!p5.Font.hasGlyphData(this.states.textFont)) {\n      console.log(\n        \"WEBGL: only Opentype (.otf) and Truetype (.ttf) fonts with glyph data are supported\",\n      );\n      return;\n    }\n\n    this.push(); // fix to #803\n\n    // remember this state, so it can be restored later\n    const doStroke = this.states.strokeColor;\n    const drawMode = this.states.drawMode;\n\n    this.states.setValue(\"strokeColor\", null);\n    this.states.setValue(\"drawMode\", TEXTURE);\n\n    // get the cached FontInfo object\n    const { font } = this.states.textFont;\n    if (!font) {\n      throw new Error(\n        \"In WebGL mode, textFont() needs to be given the result of loadFont() instead of a font family name.\",\n      );\n    }\n    const axs = font._currentAxes(this);\n    let fontInfo = font._getFontInfo(axs);\n\n    // calculate the alignment and move/scale the view accordingly\n    // TODO: check this\n    const pos = { x, y }; // this.states.textFont._handleAlignment(this, line, x, y);\n    const fontSize = this.states.textSize;\n    const scale = fontSize / (font.data?.head?.unitsPerEm || 1000);\n    this.translate(pos.x, pos.y, 0);\n    this.scale(scale, scale, 1);\n\n    // initialize the font shader\n    const gl = this.GL;\n    const initializeShader = !this._defaultFontShader;\n    const sh = this._getFontShader();\n    sh.init();\n    sh.bindShader(); // first time around, bind the shader fully\n\n    if (initializeShader) {\n      // these are constants, really. just initialize them one-time.\n      sh.setUniform(\"uGridImageSize\", [gridImageWidth, gridImageHeight]);\n      sh.setUniform(\"uCellsImageSize\", [cellImageWidth, cellImageHeight]);\n      sh.setUniform(\"uStrokeImageSize\", [strokeImageWidth, strokeImageHeight]);\n      sh.setUniform(\"uGridSize\", [charGridWidth, charGridHeight]);\n    }\n\n    const curFillColor = this.states.fillSet\n      ? this.states.curFillColor\n      : [0, 0, 0, 255];\n\n    this._setGlobalUniforms(sh);\n    this._applyColorBlend(curFillColor);\n\n    let g = this.geometryBufferCache.getGeometryByID(\"glyph\");\n    if (!g) {\n      // create the geometry for rendering a quad\n      g = this._textGeom = new Geometry(\n        1,\n        1,\n        function () {\n          for (let i = 0; i <= 1; i++) {\n            for (let j = 0; j <= 1; j++) {\n              this.vertices.push(new Vector(j, i, 0));\n              this.uvs.push(j, i);\n            }\n          }\n        },\n        this,\n      );\n      g.gid = \"glyph\";\n      g.computeFaces().computeNormals();\n      this.geometryBufferCache.ensureCached(g);\n    }\n\n    // bind the shader buffers\n    for (const buff of this.buffers.text) {\n      buff._prepareBuffer(g, sh);\n    }\n    this._bindBuffer(\n      this.geometryBufferCache.cache.glyph.indexBuffer,\n      gl.ELEMENT_ARRAY_BUFFER,\n    );\n\n    // this will have to do for now...\n    sh.setUniform(\"uMaterialColor\", curFillColor);\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n\n    this.fontCache = this.fontCache || new Map();\n\n    try {\n      // fetch the glyphs in the line of text\n      const glyphs = font._positionGlyphs(line);\n\n      for (const glyph of glyphs) {\n        const gi = fontInfo.getGlyphInfo(glyph);\n        if (gi.uGlyphRect) {\n\n          const cacheKey = JSON.stringify({ font: font.id, axs, glyph: glyph.shape.g });\n          // Bump this font to the end of the cache list by deleting and re-adding it\n          this.fontCache.delete(cacheKey);\n          this.fontCache.set(cacheKey, gi);\n          if (this.fontCache.size > this.maxCachedGlyphs()) {\n            const keyToRemove = this.fontCache.keys().next().value;\n            const val = this.fontCache.get(keyToRemove);\n            this.fontCache.delete(keyToRemove);\n            this.freeGlyphInfo(val);\n          }\n\n          const rowInfo = gi.rowInfo;\n          const colInfo = gi.colInfo;\n          sh.setUniform(\"uSamplerStrokes\", gi.strokeImageInfo.imageData);\n          sh.setUniform(\"uSamplerRowStrokes\", rowInfo.cellImageInfo.imageData);\n          sh.setUniform(\"uSamplerRows\", rowInfo.dimImageInfo.imageData);\n          sh.setUniform(\"uSamplerColStrokes\", colInfo.cellImageInfo.imageData);\n          sh.setUniform(\"uSamplerCols\", colInfo.dimImageInfo.imageData);\n          sh.setUniform(\"uGridOffset\", gi.uGridOffset);\n          sh.setUniform(\"uGlyphRect\", gi.uGlyphRect);\n          sh.setUniform(\"uGlyphOffset\", glyph.x);\n\n          sh.bindTextures(); // afterwards, only textures need updating\n\n          // draw it\n          gl.drawElements(gl.TRIANGLES, 6, this.GL.UNSIGNED_SHORT, 0);\n        }\n      }\n    } finally {\n      // clean up\n      sh.unbindShader();\n\n      this.states.setValue(\"strokeColor\", doStroke);\n      this.states.setValue(\"drawMode\", drawMode);\n      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);\n\n      this.pop();\n    }\n  };\n}\n\nexport { text as default };\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6337, "column": 0}, "map": {"version":3,"sources":["file:///home/user/cg-game-apps/node_modules/p5/dist/webgl/ShaderGenerator.js"],"sourcesContent":["import { parse } from 'acorn';\nimport { ancestor } from 'acorn-walk';\nimport escodegen from 'escodegen';\n\n/**\n* @module 3D\n* @submodule ShaderGenerator\n* @for p5\n* @requires core\n*/\n\nfunction shadergenerator(p5, fn) {\n  let GLOBAL_SHADER;\n  let BRANCH;\n\n  const oldModify = p5.Shader.prototype.modify;\n\n  p5.Shader.prototype.modify = function(shaderModifier, options = { parser: true, srcLocations: false }) {\n    if (shaderModifier instanceof Function) {\n      let generatorFunction;\n      if (options.parser) {\n        const sourceString = shaderModifier.toString();\n        const ast = parse(sourceString, {\n          ecmaVersion: 2021,\n          locations: options.srcLocations\n        });\n        ancestor(ast, ASTCallbacks, undefined, { varyings: {} });\n        const transpiledSource = escodegen.generate(ast);\n        generatorFunction = new Function(\n          transpiledSource\n          .slice(\n            transpiledSource.indexOf('{') + 1,\n            transpiledSource.lastIndexOf('}')\n          ).replaceAll(';', '')\n        );\n      } else {\n        generatorFunction = shaderModifier;\n      }\n      const generator = new ShaderGenerator(generatorFunction, this, options.srcLocations);\n      const generatedModifyArgument = generator.generate();\n      return oldModify.call(this, generatedModifyArgument);\n    }\n    else {\n      return oldModify.call(this, shaderModifier)\n    }\n  };\n\n  // AST Transpiler Callbacks and helper functions\n  function replaceBinaryOperator(codeSource) {\n    switch (codeSource) {\n      case '+': return 'add';\n      case '-': return 'sub';\n      case '*': return 'mult';\n      case '/': return 'div';\n      case '%': return 'mod';\n      case '==':\n      case '===': return 'equalTo';\n      case '>': return 'greaterThan';\n      case '>=': return 'greaterThanEqualTo';\n      case '<': return 'lessThan';\n      case '&&': return 'and';\n      case '||': return 'or';\n    }\n  }\n\n  function ancestorIsUniform(ancestor) {\n    return ancestor.type === 'CallExpression'\n      && ancestor.callee?.type === 'Identifier'\n      && ancestor.callee?.name.startsWith('uniform');\n  }\n\n  const ASTCallbacks = {\n    UnaryExpression(node, _state, _ancestors) {\n      if (_ancestors.some(ancestorIsUniform)) { return; }\n\n      const signNode = {\n        type: 'Literal',\n        value: node.operator,\n      };\n\n      const standardReplacement = (node) => {\n          node.type = 'CallExpression';\n          node.callee = {\n            type: 'Identifier',\n            name: 'unaryNode',\n          };\n          node.arguments = [node.argument, signNode];\n      };\n\n      if (node.type === 'MemberExpression') {\n        const property = node.argument.property.name;\n        const swizzleSets = [\n          ['x', 'y', 'z', 'w'],\n          ['r', 'g', 'b', 'a'],\n          ['s', 't', 'p', 'q']\n        ];\n\n        let isSwizzle = swizzleSets.some(set =>\n          [...property].every(char => set.includes(char))\n        ) && node.argument.type === 'MemberExpression';\n\n        if (isSwizzle) {\n          node.type = 'MemberExpression';\n          node.object = {\n            type: 'CallExpression',\n            callee: {\n              type: 'Identifier',\n              name: 'unaryNode'\n            },\n            arguments: [node.argument.object, signNode],\n          };\n          node.property = {\n            type: 'Identifier',\n            name: property\n          };\n        } else {\n          standardReplacement(node);\n        }\n      } else {\n        standardReplacement(node);\n      }\n      delete node.argument;\n      delete node.operator;\n    },\n    VariableDeclarator(node, _state, _ancestors) {\n      if (node.init.callee && node.init.callee.name?.startsWith('uniform')) {\n        const uniformNameLiteral = {\n          type: 'Literal',\n          value: node.id.name\n        };\n        node.init.arguments.unshift(uniformNameLiteral);\n      }\n      if (node.init.callee && node.init.callee.name?.startsWith('varying')) {\n        const varyingNameLiteral = {\n          type: 'Literal',\n          value: node.id.name\n        };\n        node.init.arguments.unshift(varyingNameLiteral);\n        _state.varyings[node.id.name] = varyingNameLiteral;\n      }\n    },\n    Identifier(node, _state, _ancestors) {\n      if (_state.varyings[node.name]\n          && !_ancestors.some(a => a.type === 'AssignmentExpression' && a.left === node)) {\n        node.type = 'ExpressionStatement';\n        node.expression = {\n          type: 'CallExpression',\n          callee: {\n            type: 'MemberExpression',\n            object: {\n              type: 'Identifier',\n              name: node.name\n            },\n            property: {\n              type: 'Identifier',\n              name: 'getValue'\n            },\n          },\n          arguments: [],\n        };\n      }\n    },\n    // The callbacks for AssignmentExpression and BinaryExpression handle\n    // operator overloading including +=, *= assignment expressions\n    ArrayExpression(node, _state, _ancestors) {\n      const original = JSON.parse(JSON.stringify(node));\n      node.type = 'CallExpression';\n      node.callee = {\n        type: 'Identifier',\n        name: 'dynamicNode',\n      };\n      node.arguments = [original];\n    },\n    AssignmentExpression(node, _state, _ancestors) {\n      if (node.operator !== '=') {\n        const methodName = replaceBinaryOperator(node.operator.replace('=',''));\n        const rightReplacementNode = {\n          type: 'CallExpression',\n          callee: {\n            type: 'MemberExpression',\n            object: node.left,\n            property: {\n              type: 'Identifier',\n              name: methodName,\n            },\n          },\n          arguments: [node.right]\n        };\n          node.operator = '=';\n          node.right = rightReplacementNode;\n        }\n        if (_state.varyings[node.left.name]) {\n          node.type = 'ExpressionStatement';\n          node.expression = {\n            type: 'CallExpression',\n            callee: {\n              type: 'MemberExpression',\n              object: {\n                type: 'Identifier',\n                name: node.left.name\n              },\n              property: {\n                type: 'Identifier',\n                name: 'bridge',\n              }\n            },\n            arguments: [node.right],\n          };\n        }\n      },\n    BinaryExpression(node, _state, _ancestors) {\n      // Don't convert uniform default values to node methods, as\n      // they should be evaluated at runtime, not compiled.\n      if (_ancestors.some(ancestorIsUniform)) { return; }\n      // If the left hand side of an expression is one of these types,\n      // we should construct a node from it.\n      const unsafeTypes = ['Literal', 'ArrayExpression', 'Identifier'];\n      if (unsafeTypes.includes(node.left.type)) {\n        const leftReplacementNode = {\n          type: 'CallExpression',\n          callee: {\n            type: 'Identifier',\n            name: 'dynamicNode',\n          },\n          arguments: [node.left]\n        };\n        node.left = leftReplacementNode;\n      }\n      // Replace the binary operator with a call expression\n      // in other words a call to BaseNode.mult(), .div() etc.\n      node.type = 'CallExpression';\n      node.callee = {\n        type: 'MemberExpression',\n        object: node.left,\n        property: {\n          type: 'Identifier',\n          name: replaceBinaryOperator(node.operator),\n        },\n      };\n      node.arguments = [node.right];\n    },\n  };\n\n  // Javascript Node API.\n  class BaseNode {\n    constructor(isInternal, type) {\n      if (new.target === BaseNode) {\n        throw new TypeError('Cannot construct BaseNode instances directly. This is an abstract class.');\n      }\n      this.type = type;\n      this.componentNames = [];\n      this.componentsChanged = false;\n      // For tracking recursion depth and creating temporary variables\n      this.isInternal = isInternal;\n      this.usedIn = [];\n      this.dependsOn = [];\n      this.srcLine = null;\n      this.usedInConditional = false;\n      // Stack Capture is used to get the original line of user code for Debug purposes\n      if (GLOBAL_SHADER.srcLocations === true && isInternal === false) {\n        try {\n          throw new Error('StackCapture');\n        } catch (e) {\n          const lines = e.stack.split('\\n');\n          let userSketchLineIndex = 5;\n          if (isBinaryExpressionNode(this)) { userSketchLineIndex--; }          this.srcLine = lines[userSketchLineIndex].trim();\n        }\n      }\n    }\n\n    addVectorComponents() {\n      if (this.type.startsWith('vec')) {\n        const vectorDimensions = parseInt(this.type.slice(3));\n        this.componentNames = ['x', 'y', 'z', 'w'].slice(0, vectorDimensions);\n        const proxy = this;\n        for (let componentName of this.componentNames) {\n          let value = new ComponentNode(proxy, componentName, 'float', true);\n          Object.defineProperty(this, componentName, {\n            get() {\n              return value;\n            },\n            set(newValue) {\n              this.componentsChanged = true;\n              if (isUnaryExpressionNode(this)) {\n                this.node.value = newValue;\n              } else {\n                value = newValue;\n              }\n            }\n          });\n        }\n      }\n    }\n\n    forceTemporaryVariable() {\n      if (!(isFloatNode(this) && isVectorNode(this.parent)) || !isVariableNode(this))\n      this.useTemp = true;\n    }\n\n    assertUsedInConditional(branch) {\n      this.usedInConditional = true;\n      this.usedIn.push(branch);\n      this.forceTemporaryVariable();\n    }\n\n    isUsedInConditional() {\n      return this.usedInConditional;\n    }\n\n    checkConditionalDependencies(context) {\n      context.ifs.forEach((statement) => {\n        const isUsedSatisfied = () => statement.usedInSatisfied.length >= 1;\n        const isDepsSatisfied = () => statement.dependsOn.length === statement.dependsOnSatisfied.length;\n        if (statement.insertionPoint > -1 || !statement.usedIn.length) return;\n        if (statement.dependsOn.some(d => d.node === this) && !statement.dependsOnSatisfied.includes(this)) {\n          statement.dependsOnSatisfied.push(this);\n        }\n        if (statement.usedIn.includes(this) && !statement.usedInSatisfied.includes(this)) {\n          statement.usedInSatisfied.push(this);\n        }\n        if (isDepsSatisfied() && isUsedSatisfied()) {\n          statement.saveState(context, isDepsSatisfied(), isUsedSatisfied());\n        }\n      });\n    }\n\n    // The base node implements a version of toGLSL which determines whether the generated code should be stored in a temporary variable.\n    toGLSLBase(context){\n      let result;\n      if (this.shouldUseTemporaryVariable()) {\n        let oldLength = context.declarations.length;\n        result = this.getTemporaryVariable(context);\n        let diff = context.declarations.length - 1 - oldLength;\n        diff = diff > 0 ? diff : undefined;\n        this.dependsOn.forEach(dependency => {\n          if (dependency.isVector) {\n            const dependencies = dependency.originalComponents.map((component, i) =>\n              component === dependency.currentComponents[i]\n            );\n            context.updateComponents(dependency.node, diff, dependencies);\n          } else {\n            context.updateComponents(dependency.node, diff);\n          }\n        });\n      } else {\n        result = this.toGLSL(context);\n      }\n      this.checkConditionalDependencies(context);\n      return result;\n    }\n\n    shouldUseTemporaryVariable() {\n      if (this.componentsChanged || hasTemporaryVariable(this) || this.useTemp) { return true; }\n      if (this.isInternal || isVariableNode(this) || isConditionalNode(this) || this.type === 'sampler2D') { return false; }\n\n      // return false;\n      // Swizzles must use temporary variables as otherwise they will not be registered\n      let score = 0;\n      score += isFunctionCallNode(this) * 2;\n      score += isBinaryExpressionNode(this) * 2;\n      score += isVectorType(this) * 3;\n      score += this.usedIn.length;\n      return score >= 4;\n    }\n\n    getTemporaryVariable(context) {\n      if (!this.temporaryVariable) {\n        this.temporaryVariable = `temp_${context.getNextID()}`;\n        let line = '';\n        if (this.srcLine) {\n          line += `\\n// From ${this.srcLine}\\n`;\n        }\n        line += '  ' + this.type + ' ' + this.temporaryVariable + ' = ' + this.toGLSL(context) + ';';\n        context.declarations.push(line);\n      }\n      return this.temporaryVariable;\n    };\n\n    // Binary Operators\n    add(other)  { return binaryExpressionNodeConstructor(this, this.enforceType(other), '+'); }\n    sub(other)  { return binaryExpressionNodeConstructor(this, this.enforceType(other), '-'); }\n    mult(other) { return binaryExpressionNodeConstructor(this, this.enforceType(other), '*'); }\n    div(other)  { return binaryExpressionNodeConstructor(this, this.enforceType(other), '/'); }\n    mod(other)  { return binaryExpressionNodeConstructor(this, this.enforceType(other), '%'); }\n\n    // Check that the types of the operands are compatible.\n    enforceType(other){\n      if (isShaderNode(other)){\n        if (!isGLSLNativeType(other.type)) {\n          throw new TypeError (`You've tried to perform an operation on a struct of type: ${other.type}. Try accessing a member on that struct with '.'`)\n        }\n        if (!isGLSLNativeType(other.type)) {\n          throw new TypeError (`You've tried to perform an operation on a struct of type: ${other.type}. Try accessing a member on that struct with '.'`)\n        }\n        if ((isFloatType(this) || isVectorType(this)) && isIntType(other)) {\n          return new FloatNode(other)\n        }\n        return other;\n      }\n      else if (typeof other === 'number') {\n        if (isIntType(this)) {\n          return new IntNode(other);\n        }\n        return new FloatNode(other);\n      }\n      else if (Array.isArray(other)) {\n        return nodeConstructors.dynamicVector(other);\n        // return nodeConstructors[`vec${other.length}`](other);\n      }\n      else {\n        return nodeConstructors[this.type](other);\n      }\n    }\n\n    toFloat() {\n      if (isFloatType(this)) {\n        return this;\n      } else if (isIntType(this)) {\n        return new FloatNode(this);\n      }\n    }\n\n    toGLSL(context){\n      throw new TypeError('Not supposed to call this function on BaseNode, which is an abstract class.');\n    }\n  }\n\n  // Primitive Types\n  class IntNode extends BaseNode {\n    constructor(x = 0, isInternal = false) {\n      super(isInternal, 'int');\n      this.x = x;\n    }\n\n    toGLSL(context) {\n      if (isShaderNode(this.x)) {\n        let code = this.x.toGLSLBase(context);\n        return isIntType(this.x.type) ? code : `int(${code})`;\n      }\n      else if (typeof this.x === 'number') {\n        return `${Math.floor(this.x)}`;\n      }\n      else {\n        return `int(${this.x})`;\n      }\n    }\n  }\n\n  class FloatNode extends BaseNode {\n    constructor(x = 0, isInternal = false, _parent = false){\n      super(isInternal, 'float');\n      if (Array.isArray(x)) {\n        x = x[0];\n      }\n      if (_parent) {\n        const { parent, name } = _parent;\n        this.name = name;\n        this.parent = parent;\n      }\n      this.x = x;\n    }\n\n    toGLSL(context) {\n      if (isShaderNode(this.x)) {\n        let code = this.x.toGLSLBase(context);\n        return isFloatType(this.x) ? code : `float(${code})`;\n      }\n      else if (typeof this.x === 'number') {\n        return `${this.x.toFixed(4)}`;\n      }\n      else {\n        return `float(${this.x})`;\n      }\n    }\n  }\n\n  class VectorNode extends BaseNode {\n    constructor(values, type, isInternal = false) {\n      super(isInternal, type);\n      this.originalValues = conformVectorParameters(values, parseInt(type.slice(3)));\n      this.componentNames = ['x', 'y', 'z', 'w'].slice(0, this.originalValues.length);\n    }\n\n    addVectorComponents() {\n      const values = this.originalValues;\n      this.componentsChanged = false;\n\n      this.componentNames.forEach((componentName, i) => {\n        const info = { name: componentName, parent: this };\n        let value = isFloatNode(values[i]) ? values[i] : new FloatNode(values[i], true, info);\n        Object.defineProperty(this, componentName, {\n          get() {\n            return value;\n          },\n          set(newValue) {\n            this.componentsChanged = true;\n            if (isUnaryExpressionNode(this)) {\n              this.node.value = newValue;\n            } else {\n              value = isFloatNode(newValue) ? newValue : new FloatNode(newValue, true, info);\n            }\n          }\n        });\n      });\n      this.originalValues = this.componentNames.map(name => this[name]);\n    }\n\n    toGLSL(context) {\n      if ((!this.componentsChanged || !this.defined) && !this.oldName) {\n        let glslArgs = this.componentNames.map((_name, i) => this.originalValues[i].toGLSLBase(context)).join(', ');\n        this.defined = true;\n        return `${this.type}(${glslArgs})`;\n      } else {\n        return this.temporaryVariable;\n      }\n    }\n  }\n\n  // Function Call Nodes\n  class FunctionCallNode extends BaseNode {\n    constructor(name, userArgs, properties, isInternal = false) {\n      let functionSignature;\n      const determineFunctionSignature = (props) => {\n        let genType;\n        let similarity = 0;\n\n        const valid = userArgs.every((userArg, i) => {\n          const userType = getType(userArg);\n          let expectedArgType = props.args[i];\n\n          if (expectedArgType === 'genType') {\n            // We allow conversions from float -> vec if one argument is a vector.\n            if (genType === undefined || (genType === 'float' && userType.startsWith('vec'))) {\n              genType = userType;\n            }            expectedArgType = genType;\n          }\n          similarity += (userType === expectedArgType);\n          return userType === expectedArgType || (userType === 'float' && expectedArgType.startsWith('vec'));\n        });\n\n        return { ...props, valid, similarity, genType }\n      };\n\n      if (Array.isArray(properties)) {\n        // Check if the right number of parameters were provided\n        let possibleOverloads = properties.filter(o => o.args.length === userArgs.length);\n        if (possibleOverloads.length === 0) {\n          const argsLengthSet = new Set();\n          const argsLengthArr = [];\n          properties.forEach((p) => argsLengthSet.add(p.args.length));\n          argsLengthSet.forEach((len) => argsLengthArr.push(`${len}`));\n          const argsLengthStr = argsLengthArr.join(' or ');\n          throw new Error(`Function '${name}' has ${properties.length} variants which expect ${argsLengthStr} arguments, but ${userArgs.length} arguments were provided.`);\n        }\n        const findBestOverload = function (best, current) {\n          current = determineFunctionSignature(current);\n          if (!current.valid) { return best; }\n          if (!best || current.similarity > best.similarity) {\n            best = current;\n          }\n          return best;\n        };\n        functionSignature = possibleOverloads.reduce(findBestOverload, null);\n      } else {\n        functionSignature = determineFunctionSignature(properties);\n      }\n\n      if (!functionSignature || !functionSignature.valid) {\n        const argsStrJoin = (args) => `(${args.map((arg) => arg).join(', ')})`;\n        const expectedArgsString = Array.isArray(properties) ?\n          properties.map(prop => argsStrJoin(prop.args)).join(' or ')\n          : argsStrJoin(properties.args);\n        const providedArgsString = argsStrJoin(userArgs.map((a)=>getType(a)));\n          throw new Error(`Function '${name}' was called with wrong arguments. Most likely, you provided mixed lengths vectors as arguments.\\nExpected argument types: ${expectedArgsString}\\nProvided argument types: ${providedArgsString}\\nAll of the arguments with expected type 'genType' should have a matching type. If one of those is different, try to find where it was created.\n        `);\n      }\n\n      if (userArgs.length !== functionSignature.args.length) {\n        throw new Error(`Function '${name}' expects ${functionSignature.args.length} arguments, but ${userArgs.length} were provided.`);\n      }\n\n      userArgs = userArgs.map((arg, i) => {\n        if (!isShaderNode(arg)) {\n          const typeName = functionSignature.args[i] === 'genType' ? functionSignature.genType : functionSignature.args[i];\n          arg = nodeConstructors[typeName](arg);\n        } else if (isFloatType(arg) && functionSignature.args[i] === 'genType' && functionSignature.genType !== 'float') {\n          arg = nodeConstructors[functionSignature.genType](arg);\n        }\n        return arg;\n      });\n\n      if (functionSignature.returnType === 'genType') {\n        functionSignature.returnType = functionSignature.genType;\n      }\n\n      super(isInternal, functionSignature.returnType);\n\n      this.name = name;\n      this.args = userArgs;\n      this.argumentTypes = functionSignature.args;\n    }\n\n    deconstructArgs(context) {\n      let argsString = this.args.map((argNode, i) => {\n        if (isIntType(argNode) && this.argumentTypes[i] != 'float') {\n          argNode = argNode.toFloat();\n        }\n        argNode.toGLSLBase(context);\n        return argNode.toGLSLBase(context);\n      }).join(', ');\n      return argsString;\n    }\n\n    toGLSL(context) {\n      return `${this.name}(${this.deconstructArgs(context)})`;\n    }\n  }\n\n  // Variables and member variable nodes\n  class VariableNode extends BaseNode {\n    constructor(name, type, isInternal = false) {\n      super(isInternal, type);\n      this.name = name;\n    }\n\n    toGLSL(context) {\n      return `${this.name}`;\n    }\n  }\n\n  class ComponentNode extends BaseNode {\n    constructor(parent, componentName, type, isInternal = false) {\n      super(isInternal, type);\n      this.parent = parent;\n      this.componentName = componentName;\n      this.type = type;\n    }\n    toGLSL(context) {\n      let parentName = this.parent.toGLSLBase(context);\n      if (!isVariableNode(this.parent) && !hasTemporaryVariable(this.parent)) {\n        parentName = `(${parentName})`;\n      }\n      return `${parentName}.${this.componentName}`;\n    }\n  }\n\n  //\n  class VaryingNode extends VariableNode {\n    constructor(name, type, isInternal = false) {\n      super(name, type, isInternal);\n      this.timesChanged = 0;\n      this.tempVars = 0;\n    }\n\n    getValue() {\n      const context = GLOBAL_SHADER.context;\n      if (!context.varyings[this.name] || !this.timesChanged) {\n        return this;\n      }\n\n      let values = context.varyings[this.name].splice(0, this.timesChanged);\n      let snapshot;\n      values.forEach((val, i) => {\n        let { value } = val;\n        context.declarations.push(`  ${this.name} = ${value.toGLSLBase(context)};`);\n        if (i === values.length - 1) {\n          const tempName = `${this.name}_${this.tempVars++}`;\n          snapshot = dynamicAddSwizzleTrap(new VariableNode(tempName, this.type, true));\n          context.declarations.push(`  ${this.type} ${tempName} = ${this.name};`);\n        }\n      });\n\n      this.timesChanged = 0;\n      return snapshot;\n    }\n\n    bridge(value) {\n      if (!isShaderNode(value) || this.type.startsWith('vec') && getType(value) === 'float') {\n        value = nodeConstructors[this.type](value);\n      }\n      GLOBAL_SHADER.registerVarying(this, value);\n      this.timesChanged += 1;\n    }\n  }\n\n  // Binary Operator Nodes\n  class BinaryExpressionNode extends BaseNode {\n    constructor(left, right, operator, isInternal = false) {\n      super(isInternal, null);\n      this.operator = operator;\n      this.left = left;\n      this.right = right;\n      for (const operand of [left, right]) {\n        operand.usedIn.push(this);\n      }\n      this.type = this.determineType();\n    }\n\n    // We know that both this.left and this.right are nodes because of BaseNode.enforceType\n    determineType() {\n      if (['==', '>', '>=', '<', '<=', '||', '!', '&&'].includes(this.operator)) {\n        return 'bool';\n      }\n      else if (this.left.type === this.right.type) {\n        return this.left.type;\n      }\n      else if (isVectorType(this.left) && isFloatType(this.right)) {\n        return this.left.type;\n      }\n      else if (isVectorType(this.right) && isFloatType(this.left)) {\n        return this.right.type;\n      }\n      else if (isFloatType(this.left) && isIntType(this.right)\n        || isIntType(this.left) && isFloatType(this.right)\n      ) {\n        return 'float';\n      }\n      else {\n        throw new Error('Incompatible types for binary operator');\n      }\n    }\n\n    processOperand(operand, context) {\n      if (operand.temporaryVariable) { return operand.temporaryVariable; }\n      let code = operand.toGLSLBase(context);\n      if (isBinaryExpressionNode(operand) && !operand.temporaryVariable) {\n        code = `(${code})`;\n      }\n      if (this.type === 'float' && isIntType(operand)) {\n        code = `float(${code})`;\n      }\n      return code;\n    }\n\n    toGLSL(context) {\n      const a = this.processOperand(this.left, context);\n      const b = this.processOperand(this.right, context);\n      return `${a} ${this.operator} ${b}`;\n    }\n  }\n\n  class ModulusNode extends BinaryExpressionNode {\n    constructor(a, b, isInternal) {\n      super(a, b, isInternal);\n    }\n    toGLSL(context) {\n      // Switch on type between % or mod()\n      if (isVectorType(this) || isFloatType(this)) {\n        return `mod(${this.left.toGLSLBase(context)}, ${this.right.toGLSLBase(context)})`;\n      }\n      return `${this.processOperand(context, this.left)} % ${this.processOperand(context, this.right)}`;\n    }\n  }\n\n  class UnaryExpressionNode extends BaseNode {\n    constructor(node, operator, isInternal = false) {\n      super(isInternal, node.type);\n      this.node = node;\n      this.operator = operator;\n    }\n\n    toGLSL(context) {\n      let mainStr = this.node.toGLSLBase(context);\n      if (!isVariableNode(this.node) && !hasTemporaryVariable(this.node) && !isPrimitiveNode(this.node)) {\n        mainStr = `(${mainStr})`;\n      }\n      return `${this.operator}${mainStr}`\n    }\n  }\n\n  // Conditions and logical modifiers\n  BaseNode.prototype.equalTo = function(other) {\n    return binaryExpressionNodeConstructor(this, this.enforceType(other), '==');\n  };\n\n  BaseNode.prototype.greaterThan = function(other) {\n    return binaryExpressionNodeConstructor(this, this.enforceType(other), '>');\n  };\n\n  BaseNode.prototype.greaterThanEqualTo = function(other) {\n    return binaryExpressionNodeConstructor(this, this.enforceType(other), '>=');\n  };\n\n  BaseNode.prototype.lessThan = function(other) {\n    return binaryExpressionNodeConstructor(this, this.enforceType(other), '<');\n  };\n\n  BaseNode.prototype.lessThanEqualTo = function(other) {\n    return binaryExpressionNodeConstructor(this, this.enforceType(other), '<='); };\n\n  BaseNode.prototype.not = function() {\n     return new UnaryExpressionNode(this.condition, '!', true);\n  };\n\n  BaseNode.prototype.or = function(other) {\n    return new binaryExpressionNodeConstructor(this, this.enforceType(other), '||', true);\n  };\n\n  BaseNode.prototype.and = function(other) {\n    return new binaryExpressionNodeConstructor(this, this.enforceType(other), '&&', true);\n  };\n\n  function branch(callback) {\n    const branch = new BranchNode();\n    callback();\n    BRANCH = null;\n    return branch;\n  }\n\n  class ConditionalNode {\n    constructor(condition, branchCallback) {\n      this.dependsOn = [];\n      this.usedIn = [];\n      this.dependsOnSatisfied = [];\n      this.usedInSatisfied = [];\n      this.states = [];\n      this.if(condition, branchCallback);\n      this.insertionPoint = -1;\n      this.elseIfs = [];\n      this.elseBranch = null;\n      GLOBAL_SHADER.context.ifs.push(this);\n    }\n\n    if(condition, branchCallback) {\n      this.condition = condition;\n      this.conditionString = condition.toGLSL(GLOBAL_SHADER.context);\n      this.ifBranch = branch(branchCallback);\n      this.ifBranch.parent = this;\n    }\n\n    elseIf(condition, branchCallback) {\n      let elseBranch = branch(branchCallback);\n      branchCallback.parent = this;\n      this.elseIfs.push({ condition, elseBranch });\n      return this;\n    }\n\n    else(branchCallback) {\n      this.elseBranch = branch(branchCallback);\n      this.elseBranch.parent = this;\n      return this;\n    }\n\n    thenDiscard() {\n      return new ConditionalDiscard(this.condition);\n    };\n\n    saveState(context, usedInSatisfied, dependsOnSatisfied) {\n      this.states.push({\n        line: context.declarations.length,\n        usedInSatisfied,\n        dependsOnSatisfied\n      });\n      this.insertionPoint = context.declarations.length - 1;\n    }\n\n    toGLSL(context) {\n      const oldLength = context.declarations.length;\n      this.dependsOn.forEach(dep => context.updateComponents(dep.node));\n      const newLength = context.declarations.length;\n      const diff = newLength - oldLength;\n      this.insertionPoint += diff;\n\n      let codelines = [\n        `\\n  if (${this.conditionString}) {`,\n        `\\n    ${this.ifBranch.toGLSL(context)}`,\n        `\\n  }`\n      ];\n\n      if (this.elseIfs.length) {\n        this.elseIfs.forEach((elif) => {\n          let { condition, elseBranch } = elif;\n          codelines.push(` else if (${condition.toGLSL(context)}) {`);\n          codelines.push(`\\n    ${elseBranch.toGLSL(context)}`);\n          codelines.push(`\\n  }`);\n        });\n      }\n\n      if (this.elseBranch) {\n        codelines.push(` else {`);\n        codelines.push(`\\n    ${this.elseBranch.toGLSL(context)}`);\n        codelines.push(`\\n  }\\n`);\n      }\n      codelines.push('\\n');\n      return codelines.flat().join('');\n    }\n  }\n  fn.assign = function(node, value) {\n    if (!BRANCH) {\n       throw new error('assign() is supposed to be used inside of conditional branchs. Use the \"=\" operator as normal otherwise.');\n    }\n    BRANCH.assign(node, value);\n  };\n\n  class BranchNode {\n    constructor() {\n      BRANCH = this;\n      this.statements = [];\n      this.assignments = [];\n      this.dependsOn = [];\n      this.declarations = [];\n      let parent = null;\n      Object.defineProperty(this, 'parent', {\n        get() {\n          return parent;\n        },\n        set(newParent) {\n          newParent.dependsOn.push(...this.dependsOn);\n          parent = newParent;\n        }\n      });\n    }\n\n    assign(node, value) {\n      if (!isShaderNode(value) || value.type !== node.type) {\n        value = nodeConstructors[node.type](value);\n        this.declarations.push(value);\n        this.assignments.push({ node });\n      } else {\n        this.assignments.push({ node, value });\n      }\n      node = node.parent ? node.parent : node;\n      value = value.parent ? value.parent : value;\n      if ([node, value].some(n => this.dependsOn.some(d=>d.node===n))) {\n        return;\n      }\n      node.assertUsedInConditional(this);\n      this.dependsOn.push(makeDependencyObject(node));\n      if (value.shouldUseTemporaryVariable()) {\n        value.assertUsedInConditional(this);\n        this.dependsOn.push(makeDependencyObject(value));\n      }\n    }\n\n    toGLSL(context) {\n      let declarationsIndex = 0;\n      this.assignments.forEach(({ node, value }) => {\n        let statement;\n        let result;\n\n        if (!value) {\n          let decl = this.declarations[declarationsIndex];\n          declarationsIndex++;\n          decl.temporaryVariable = `temp_${context.getNextID()}`;\n          this.statements.push(\n            `${decl.type} ${decl.temporaryVariable} = ${decl.toGLSL(context)};`\n          );\n          result = decl.toGLSLBase(context);\n        } else {\n          result = value.toGLSLBase(context);\n        }\n\n        if (isVariableNode(node) || hasTemporaryVariable(node)) {\n          statement = `${node.toGLSLBase(context)} = ${result};`;\n        }\n        else if (isFloatNode(node) && node.name) {\n            statement = `${node.parent.toGLSLBase(context)}.${node.name} = ${result};`;\n        }\n        else {\n          node.temporaryVariable = `temp_${context.getNextID()}`;\n          statement = `${node.type} ${node.toGLSLBase(context)} = ${result};`;\n        }\n\n        this.statements.push(statement);\n      });\n\n      return this.statements.join(`\\n    `);\n    }\n  }\n\n  class ConditionalDiscard {\n    constructor(condition){\n      this.condition = condition;\n    }\n    toGLSL(context) {\n      context.discardConditions.push(`if (${this.condition}{discard;})`);\n    }\n  }\n\n  // Node Helper functions\n  function getType(node) {\n    if (isShaderNode(node)) { return node.type; }\n    else if (Array.isArray(node) && node.length > 1) { return `vec${node.length}`; }\n    else if (typeof node === 'number' || (Array.isArray(node) && node.length === 1)) {\n      return 'float';\n    }\n    return undefined;\n  }\n\n  function computeVectorLength(values) {\n    let length = 0;\n    if (Array.isArray(values)) {\n      for(let val of values) {\n        if (isVectorType(val)) {\n          length += parseInt(val.type.slice(3));\n        }\n        else length += 1;\n      }\n    }\n    else if (isVectorType(values)) {\n      length += parseInt(val.type.slice(3));\n    }\n    if (![2, 3, 4].includes(length)) {\n      throw new Error(`You have attempted to construct a vector with ${length} values. Only vec2, vec3, and vec4 types are supported.`)\n    }\n    return length\n  }\n\n  fn.dynamicNode = function (input) {\n    if (isShaderNode(input)) {\n      return input;\n    }\n    else if (typeof input === 'number') {\n      return new FloatNode(input);\n    }\n    else if (Array.isArray(input)) {\n      return nodeConstructors.dynamicVector(input);\n    }\n  };\n\n  // For replacing unary expressions\n  fn.unaryNode = function(input, sign) {\n    input = dynamicNode(input);\n    return dynamicAddSwizzleTrap(new UnaryExpressionNode(input, sign));\n  };\n\n  function isShaderNode(node) {\n    return (node instanceof BaseNode);\n  }\n\n  function isIntType(node) {\n    return (isShaderNode(node) && (node.type === 'int'));\n  }\n\n  function isFloatType(node) {\n    return (isShaderNode(node) && (node.type === 'float'));\n  }\n\n  function isFloatNode(node) {\n    return (node instanceof FloatNode);\n  }\n\n  function isVectorType(node) {\n    return (isShaderNode(node) && (node.type === 'vec2'|| node.type === 'vec3' || node.type === 'vec4'));\n  }\n\n  function isBinaryExpressionNode(node) {\n    return (node instanceof BinaryExpressionNode);\n  }\n\n  function isVariableNode(node) {\n    return (node instanceof VariableNode || node instanceof ComponentNode);\n  }\n\n  function isConditionalNode(node) {\n    return (node instanceof ConditionalNode || node instanceof BranchNode)\n  }\n\n  function hasTemporaryVariable(node) {\n    return (node.temporaryVariable);\n  }\n\n  function isPrimitiveNode(node) {\n    return (node instanceof FloatNode || node instanceof IntNode || node instanceof VectorNode);\n  }\n\n  function isFunctionCallNode(node) {\n    return (node instanceof FunctionCallNode);\n  }\n\n  function isVectorNode(node) {\n    return (node instanceof VectorNode)\n  }\n\n  function isUnaryExpressionNode(node) {\n    return (node instanceof UnaryExpressionNode)\n  }\n\n  // Helper function to check if a type is a user defined struct or native type\n  function isGLSLNativeType(typeName) {\n    // Supported types for now\n    const glslNativeTypes = ['int', 'float', 'vec2', 'vec3', 'vec4', 'sampler2D'];\n    return glslNativeTypes.includes(typeName);\n  }\n\n  // Shader Generator\n  // This class is responsible for converting the nodes into an object containing GLSL code, to be used by p5.Shader.modify\n\n  class ShaderGenerator {\n    constructor(userCallback, originalShader, srcLocations) {\n      GLOBAL_SHADER = this;\n      this.userCallback = userCallback;\n      this.srcLocations = srcLocations;\n      this.cleanup = () => {};\n      this.generateHookOverrides(originalShader);\n      this.output = {\n        vertexDeclarations: new Set(),\n        fragmentDeclarations: new Set(),\n        uniforms: {},\n      };\n      this.uniformNodes = [];\n      this.resetGLSLContext();\n      this.isGenerating = false;\n    }\n\n    generate() {\n      const prevFESDisabled = p5.disableFriendlyErrors;\n      // We need a custom error handling system within shader generation\n      p5.disableFriendlyErrors = true;\n\n      this.isGenerating = true;\n      this.userCallback();\n      this.output.vertexDeclarations = [...this.output.vertexDeclarations].join('\\n');\n      this.output.fragmentDeclarations = [...this.output.fragmentDeclarations].join('\\n');\n      this.isGenerating = false;\n\n      this.cleanup();\n      p5.disableFriendlyErrors = prevFESDisabled;\n      return this.output;\n    }\n\n    // This method generates the hook overrides which the user calls in their modify function.\n    generateHookOverrides(originalShader) {\n      const availableHooks = {\n        ...originalShader.hooks.vertex,\n        ...originalShader.hooks.fragment,\n      };\n\n      const windowOverrides = {};\n\n      Object.keys(availableHooks).forEach((hookName) => {\n        const hookTypes = originalShader.hookTypes(hookName);\n\n        // These functions are where the user code is executed\n        this[hookTypes.name] = function(userCallback) {\n          // Create the initial nodes which are passed to the user callback\n          // Also generate a string of the arguments for the code generation\n          const argNodes = [];\n          const argsArray = [];\n\n          hookTypes.parameters.forEach((parameter) => {\n            // For hooks with structs as input we should pass an object populated with variable nodes\n            if (!isGLSLNativeType(parameter.type.typeName)) {\n              const structArg = {};\n              parameter.type.properties.forEach((property) => {\n                structArg[property.name] = variableConstructor(`${parameter.name}.${property.name}`, property.type.typeName, true);\n              });\n              argNodes.push(structArg);\n            } else {\n              argNodes.push(\n                variableConstructor(parameter.name, parameter.type.typeName, true)\n              );\n            }\n            const qualifiers = parameter.type.qualifiers.length > 0 ? parameter.type.qualifiers.join(' ') : '';\n            argsArray.push(`${qualifiers} ${parameter.type.typeName} ${parameter.name}`.trim());\n          });\n\n          let returnedValue = userCallback(...argNodes);\n          const expectedReturnType = hookTypes.returnType;\n          const toGLSLResults = {};\n\n          // If the expected return type is a struct we need to evaluate each of its properties\n          if (!isGLSLNativeType(expectedReturnType.typeName)) {\n            Object.entries(returnedValue).forEach(([propertyName, propertyNode]) => {\n              propertyNode = dynamicNode(propertyNode);\n              toGLSLResults[propertyName] = propertyNode.toGLSLBase(this.context);\n              this.context.updateComponents(propertyNode);\n            });\n          } else {\n            if (!isShaderNode(returnedValue)) {\n              returnedValue = nodeConstructors[expectedReturnType.typeName](returnedValue);\n            } else if (isFloatType(returnedValue) && expectedReturnType.typeName.startsWith('vec')) {\n              returnedValue = nodeConstructors[expectedReturnType.typeName](returnedValue);\n            }\n            toGLSLResults['notAProperty'] = returnedValue.toGLSLBase(this.context);\n            this.context.updateComponents(returnedValue);\n          }\n\n          this.context.ifs.forEach((statement) => {\n            if (statement.usedIn.length === 0) { return; }\n            const lines = statement.toGLSL(this.context);\n            this.context.declarations.splice(statement.insertionPoint, 0, lines);\n          });\n          // Build the final GLSL string.\n          // The order of this code is a bit confusing, we need to call toGLSLBase\n          let codeLines = [\n            `(${argsArray.join(', ')}) {`,\n            ...this.context.declarations,\n            `\\n  ${hookTypes.returnType.typeName} finalReturnValue;`\n          ];\n\n          Object.entries(toGLSLResults).forEach(([propertyName, result]) => {\n            const propString = expectedReturnType.properties ? `.${propertyName}` : '';\n            codeLines.push(`  finalReturnValue${propString} = ${result};`);\n          });\n\n          this.context.declarations = [];\n          for (let key in this.context.varyings) {\n            const declArray = this.context.varyings[key];\n            const finalVaryingAssignments = [];\n            declArray.forEach(obj => {\n              const { node, value } = obj;\n              finalVaryingAssignments.push(`  ${node.name} = ${value.toGLSLBase(this.context)};`);\n              finalVaryingAssignments.unshift(...this.context.declarations);\n              node.timesChanged = 0;\n            });\n            codeLines.push(...finalVaryingAssignments);\n          }\n\n          codeLines.push('  return finalReturnValue;', '}');\n          this.output[hookName] = codeLines.join('\\n');\n          this.resetGLSLContext();\n        };\n        windowOverrides[hookTypes.name] = window[hookTypes.name];\n\n        // Expose the Functions to global scope for users to use\n        window[hookTypes.name] = function(userOverride) {\n          GLOBAL_SHADER[hookTypes.name](userOverride);\n        };\n      });\n\n\n      this.cleanup = () => {\n        for (const key in windowOverrides) {\n          window[key] = windowOverrides[key];\n        }\n      };\n    }\n\n    registerVarying(node, value) {\n      if (!Array.isArray(this.context.varyings[node.name])) {\n        this.context.varyings[node.name] = [];\n      }\n      this.context.varyings[node.name].push({ node, value });\n      this.output.vertexDeclarations.add(`OUT ${node.type} ${node.name};`);\n      this.output.fragmentDeclarations.add(`IN ${node.type} ${node.name};`);\n    }\n\n    resetGLSLContext() {\n      this.uniformNodes.forEach((node) => {\n        node.usedIn = [];\n        node.temporaryVariable = undefined;\n      });\n      this.context = {\n        id: 0,\n        getNextID() { return this.id++ },\n        declarations: [],\n        varyings: [],\n        ifs: [],\n        updateComponents: function(node, _emplaceAt, _changedComponents) {\n          if (node.componentsChanged) {\n            if (!_changedComponents) {\n              _changedComponents = node.componentNames.map(() => true);\n            }\n            const lines = [];\n            if (isVectorNode(node)) {\n              node.componentNames.forEach((name, i) => {\n                if (!_changedComponents[i]) return;\n                if (node[name] !== node.originalValues[i]) {\n                  const replacement = nodeConstructors['float'](node[name]);\n                  const line = `  ${node.temporaryVariable}.${name} = ${replacement.toGLSLBase(this)};`;\n                  lines.push(line);\n                }\n              });\n            } else {\n              const components = node.componentNames.map((name) => {\n                return node[name]\n              });\n              const replacement = nodeConstructors[node.type](components);\n              const line = `  ${node.temporaryVariable} = ${replacement.toGLSLBase(this)};`;\n              lines.push(line);\n            }\n            if (_emplaceAt) {\n              this.declarations.splice(_emplaceAt, 0, ...lines);\n            } else {\n              this.declarations.push(...lines);\n            }\n            node.componentsChanged = false;\n          }\n        }\n      };\n      this.uniformNodes = [];\n    }\n  }\n\n  // User function helpers\n  function makeDependencyObject(dep) {\n    if (isVectorType(dep)) {\n      return {\n        node: dep,\n        isVector: true,\n        originalComponents: [...dep.componentNames.map(name => dep[name])],\n        get currentComponents() {\n          return dep.componentNames.map(name => dep[name]);\n        }\n      };\n    } else {\n      return {\n        node: dep,\n        isVector: false\n      };\n    }\n  }\n\n  function makeDependencyArray(dependencies) {\n    return dependencies.map(dep => makeDependencyObject(dep));\n  }\n\n  function conformVectorParameters(value, vectorDimensions) {\n    // Allow arguments as arrays or otherwise. The following are all equivalent:\n    // ([0,0,0,0]) (0,0,0,0) (0) ([0])\n    if (!Array.isArray(value)) {\n      value = [value];\n    }\n    value = value.flat();\n    value = value.map(val => {\n      if (isVectorType(val)) {\n        const componentArray = val.componentNames.map(comp => val[comp]);\n        return componentArray;\n      } else {\n        return val;\n      }\n    }).flat();\n    // Populate arguments so uniformVector3(0) becomes [0,0,0]\n    if (value.length === 1 && !isVectorNode(value[0])) {\n      value = Array(vectorDimensions).fill(value[0]);\n    }\n    return value;\n  }\n\n  function swizzleTrap(size) {\n    const swizzleSets = [\n      ['x', 'y', 'z', 'w'],\n      ['r', 'g', 'b', 'a'],\n      ['s', 't', 'p', 'q']\n    ].map(s => s.slice(0, size));\n    return {\n      get(target, property, receiver) {\n        if (property in target) {\n          return Reflect.get(...arguments);\n        } else {\n          for (const set of swizzleSets) {\n            if ([...property].every(char => set.includes(char))) {\n              if (property.length === 1) {\n                return target[swizzleSets[0][set.indexOf(property[0])]]\n              }\n              const components = [...property].map(char => {\n                const index = set.indexOf(char);\n                const mappedChar = swizzleSets[0][index];\n                return target[mappedChar];\n              });\n\n              const type = `vec${property.length}`;\n              return nodeConstructors[type](components);\n            }\n          }\n        }\n      },\n      set(target, property, value, receiver) {\n        for (const set of swizzleSets) {\n          const propertyCharArray = [...property];\n          if (propertyCharArray.every(char => set.includes(char))) {\n            const newValues = Array.isArray(value) ? value : Array(property.length).fill(value);\n            propertyCharArray.forEach((char, i) => {\n              const index = set.indexOf(char);\n              const realProperty = swizzleSets[0][index];\n              Reflect.set(target, realProperty, newValues[i], receiver);\n            });\n            return true;\n          }\n        }\n        return Reflect.set(...arguments);\n      }\n    }\n  }\n\n  // User functions\n  fn.If = function (condition, branch) {\n    return new ConditionalNode(condition, branch);\n  };\n\n  fn.instanceID = function() {\n    return variableConstructor('gl_InstanceID', 'int');\n  };\n\n  fn.getTexture = function(...userArgs) {\n    const props = { args: ['sampler2D', 'vec2'], returnType: 'vec4', isp5Function: true };\n    return fnNodeConstructor('getTexture', userArgs,  props);\n  };\n\n  // Generating uniformFloat, uniformVec, createFloat, etc functions\n  // Maps a GLSL type to the name suffix for method names\n  const GLSLTypesToIdentifiers = {\n    int:    'Int',\n    float:  'Float',\n    vec2:   'Vector2',\n    vec3:   'Vector3',\n    vec4:   'Vector4',\n    sampler2D: 'Texture',\n  };\n\n  function dynamicAddSwizzleTrap(node, _size) {\n    if (node.type.startsWith('vec') || _size) {\n      const size = parseInt(node.type.slice(3));\n      node =  new Proxy(node, swizzleTrap(size));\n      node.addVectorComponents();\n    }\n    return node;\n  }\n\n  function binaryExpressionNodeConstructor(a, b, operator, isInternal) {\n    let node;\n    if (operator === '%') {\n      node = new ModulusNode(a, b);\n    } else {\n      node = new BinaryExpressionNode(a, b, operator, isInternal);\n    }\n    return dynamicAddSwizzleTrap(node);\n  }\n\n  function variableConstructor(name, type, isInternal) {\n    const node = new VariableNode(name, type, isInternal);\n    return dynamicAddSwizzleTrap(node);\n  }\n\n  function fnNodeConstructor(name, userArgs, properties, isInternal) {\n    let node = new FunctionCallNode(name, userArgs, properties, isInternal);\n    node = dynamicAddSwizzleTrap(node);\n    node.dependsOn = makeDependencyArray(node.args);\n    const dependsOnConditionals = node.args.map(arg => {\n      const conditionals = arg.usedIn.filter(n => isConditionalNode(n)).map(c => {\n        if (c instanceof BranchNode) {\n          return c.parent;\n        } else {\n          return c;\n        }\n      });\n      return conditionals;\n    }).flat();\n    dependsOnConditionals.forEach(conditional => conditional.usedIn.push(node));\n\n    return node;\n  }\n\n  const nodeConstructors = {\n    int:   (value) => new IntNode(value),\n    float: (value) => new FloatNode(value),\n    vec2:  (value) => dynamicAddSwizzleTrap(new VectorNode(value, 'vec2')),\n    vec3:  (value) => dynamicAddSwizzleTrap(new VectorNode(value, 'vec3')),\n    vec4:  (value) => dynamicAddSwizzleTrap(new VectorNode(value, 'vec4')),\n    dynamicVector: function(value) {\n      const size = computeVectorLength(value);\n      return this[`vec${size}`](value);\n    },\n  };\n\n  for (const glslType in GLSLTypesToIdentifiers) {\n    // Generate uniform*() Methods for creating uniforms\n    const typeIdentifier = GLSLTypesToIdentifiers[glslType];\n    const uniformMethodName = `uniform${typeIdentifier}`;\n\n    ShaderGenerator.prototype[uniformMethodName] = function(...args) {\n      let [name, ...defaultValue] = args;\n      if (glslType.startsWith('vec') && !(defaultValue[0] instanceof Function)) {\n        defaultValue = conformVectorParameters(defaultValue, parseInt(glslType.slice(3)));\n        this.output.uniforms[`${glslType} ${name}`] = defaultValue;\n      }\n      else {\n        this.output.uniforms[`${glslType} ${name}`] = defaultValue[0];\n      }\n      const uniform = variableConstructor(name, glslType, false);\n      this.uniformNodes.push(uniform);\n      return uniform;\n    };\n\n    fn[uniformMethodName] = function (...args) {\n      return GLOBAL_SHADER[uniformMethodName](...args);\n    };\n\n\n    // We don't need a texture creation method.\n    if (glslType === 'sampler2D') { continue; }\n\n    const varyingMethodName = `varying${typeIdentifier}`;\n    ShaderGenerator.prototype[varyingMethodName] = function(name) {\n      return dynamicAddSwizzleTrap(new VaryingNode(name, glslType, false));\n    };\n\n    fn[varyingMethodName] = function (name) {\n      return GLOBAL_SHADER[varyingMethodName](name);\n    };\n\n    // Generate the creation methods for creating variables in shaders\n    const originalFn = fn[glslType];\n    fn[glslType] = function (...value) {\n      if (GLOBAL_SHADER?.isGenerating) {\n        if (glslType.startsWith('vec')) {\n          value = conformVectorParameters(value, parseInt(glslType.slice(3)));\n        } else {\n          value = value[0];\n        }\n        return nodeConstructors[glslType](value);\n      } else if (originalFn) {\n        return originalFn.apply(this, value);\n      } else {\n        p5._friendlyError(\n          `It looks like you've called ${glslType} outside of a shader's modify() function.`\n        );\n      }\n    };\n  }\n\n  // GLSL Built in functions\n  // Add a whole lot of these functions.\n  // https://docs.gl/el3/abs\n  const builtInGLSLFunctions = {\n    //////////// Trigonometry //////////\n    'acos': { args: ['genType'], returnType: 'genType', isp5Function: true},\n    'acosh': { args: ['genType'], returnType: 'genType', isp5Function: false},\n    'asin': { args: ['genType'], returnType: 'genType', isp5Function: true},\n    'asinh': { args: ['genType'], returnType: 'genType', isp5Function: false},\n    'atan': [\n      { args: ['genType'], returnType: 'genType', isp5Function: false},\n      { args: ['genType', 'genType'], returnType: 'genType', isp5Function: false},\n    ],\n    'atanh': { args: ['genType'], returnType: 'genType', isp5Function: false},\n    'cos': { args: ['genType'], returnType: 'genType', isp5Function: true},\n    'cosh': { args: ['genType'], returnType: 'genType', isp5Function: false},\n    'degrees': { args: ['genType'], returnType: 'genType', isp5Function: true},\n    'radians': { args: ['genType'], returnType: 'genType', isp5Function: true},\n    'sin': { args: ['genType'], returnType: 'genType' , isp5Function: true},\n    'sinh': { args: ['genType'], returnType: 'genType', isp5Function: false},\n    'tan': { args: ['genType'], returnType: 'genType', isp5Function: true},\n    'tanh': { args: ['genType'], returnType: 'genType', isp5Function: false},\n\n    ////////// Mathematics //////////\n    'abs': { args: ['genType'], returnType: 'genType', isp5Function: true},\n    'ceil': { args: ['genType'], returnType: 'genType', isp5Function: true},\n    'clamp': { args: ['genType', 'genType', 'genType'], returnType: 'genType', isp5Function: false},\n    'dFdx': { args: ['genType'], returnType: 'genType', isp5Function: false},\n    'dFdy': { args: ['genType'], returnType: 'genType', isp5Function: false},\n    'exp': { args: ['genType'], returnType: 'genType', isp5Function: true},\n    'exp2': { args: ['genType'], returnType: 'genType', isp5Function: false},\n    'floor': { args: ['genType'], returnType: 'genType', isp5Function: true},\n    'fma': { args: ['genType', 'genType', 'genType'], returnType: 'genType', isp5Function: false},\n    'fract': { args: ['genType'], returnType: 'genType', isp5Function: true},\n    'fwidth': { args: ['genType'], returnType: 'genType', isp5Function: false},\n    'inversesqrt': { args: ['genType'], returnType: 'genType', isp5Function: true},\n    // 'isinf': {},\n    // 'isnan': {},\n    'log': { args: ['genType'], returnType: 'genType', isp5Function: true},\n    'log2': { args: ['genType'], returnType: 'genType', isp5Function: false},\n    'max': [\n      { args: ['genType', 'genType'], returnType: 'genType', isp5Function: true},\n      { args: ['genType', 'float'], returnType: 'genType', isp5Function: true},\n    ],\n    'min': [\n      { args: ['genType', 'genType'], returnType: 'genType', isp5Function: true},\n      { args: ['genType', 'float'], returnType: 'genType', isp5Function: true},\n    ],\n    'mix': [\n      { args: ['genType', 'genType', 'genType'], returnType: 'genType', isp5Function: false},\n      { args: ['genType', 'genType', 'float'], returnType: 'genType', isp5Function: false},\n    ],\n    // 'mod': {},\n    // 'modf': {},\n    'pow': { args: ['genType', 'genType'], returnType: 'genType', isp5Function: true},\n    'round': { args: ['genType'], returnType: 'genType', isp5Function: true},\n    'roundEven': { args: ['genType'], returnType: 'genType', isp5Function: false},\n    // 'sign': {},\n    'smoothstep': [\n      { args: ['genType', 'genType', 'genType'], returnType: 'genType', isp5Function: false},\n      { args: ['float', 'float', 'genType'], returnType: 'genType', isp5Function: false},\n    ],\n    'sqrt': { args: ['genType'], returnType: 'genType', isp5Function: true},\n    'step': { args: ['genType', 'genType'], returnType: 'genType', isp5Function: false},\n    'trunc': { args: ['genType'], returnType: 'genType', isp5Function: false},\n\n    ////////// Vector //////////\n    'cross': { args: ['vec3', 'vec3'], returnType: 'vec3', isp5Function: true},\n    'distance': { args: ['genType', 'genType'], returnType: 'float', isp5Function: true},\n    'dot': { args: ['genType', 'genType'], returnType: 'float', isp5Function: true},\n    // 'equal': {},\n    'faceforward': { args: ['genType', 'genType', 'genType'], returnType: 'genType', isp5Function: false},\n    'length': { args: ['genType'], returnType: 'float', isp5Function: false},\n    'normalize': { args: ['genType'], returnType: 'genType', isp5Function: true},\n    // 'notEqual': {},\n    'reflect': { args: ['genType', 'genType'], returnType: 'genType', isp5Function: false},\n    'refract': { args: ['genType', 'genType', 'float'], returnType: 'genType', isp5Function: false},\n\n    ////////// Texture sampling //////////\n    'texture': {args: ['sampler2D', 'vec2'], returnType: 'vec4', isp5Function: true},\n  };\n\n  Object.entries(builtInGLSLFunctions).forEach(([functionName, properties]) => {\n    const isp5Function = Array.isArray(properties) ? properties[0].isp5Function : properties.isp5Function;\n    if (isp5Function) {\n      const originalFn = fn[functionName];\n      fn[functionName] = function (...args) {\n        if (GLOBAL_SHADER?.isGenerating) {\n          return fnNodeConstructor(functionName, args, properties)\n        } else {\n          return originalFn.apply(this, args);\n        }\n      };\n    } else {\n      fn[functionName] = function (...args) {\n        if (GLOBAL_SHADER?.isGenerating) {\n          return new fnNodeConstructor(functionName, args, properties);\n        } else {\n          p5._friendlyError(\n            `It looks like you've called ${functionName} outside of a shader's modify() function.`\n          );\n        }\n      };\n    }\n  });\n}\n\nif (typeof p5 !== 'undefined') {\n  p5.registerAddon(shadergenerator);\n}\n\nexport { shadergenerator as default };\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8287, "column": 0}, "map": {"version":3,"sources":["file:///home/user/cg-game-apps/node_modules/p5/dist/webgl/index.js"],"sourcesContent":["import { r as rendererGL, p as primitives3D, l as light, m as material, c as camera, f as framebuffer, s as shader, t as texture } from '../rendering--aAe5aq3.js';\nimport interaction from './interaction.js';\nimport loading from './loading.js';\nimport text from './text.js';\nimport renderBuffer from './p5.RenderBuffer.js';\nimport quat from './p5.Quat.js';\nimport matrix from '../math/p5.Matrix.js';\nimport geometry from './p5.Geometry.js';\nimport dataArray from './p5.DataArray.js';\nimport shadergenerator from './ShaderGenerator.js';\nimport '../constants-C-g_eAdC.js';\nimport '../creating_reading-D4AAKRbx.js';\nimport 'colorjs.io/fn';\nimport '../color/color_spaces/hsb.js';\nimport '../dom/p5.Element.js';\nimport '../dom/p5.File.js';\nimport '../io/p5.XML.js';\nimport '../p5.Renderer-CwAYZOC2.js';\nimport '../image/filters.js';\nimport '../math/p5.Vector.js';\nimport '../shape/custom_shapes.js';\nimport '../core/States.js';\nimport '../io/utilities.js';\nimport 'file-saver';\nimport '../dom/p5.MediaElement.js';\nimport '../shape/2d_primitives.js';\nimport '../core/helpers.js';\nimport '../shape/attributes.js';\nimport '../shape/curves.js';\nimport '../shape/vertex.js';\nimport '../color/setting.js';\nimport 'omggif';\nimport '../io/csv.js';\nimport 'gifenc';\nimport '../image/pixels.js';\nimport '../core/transform.js';\nimport './GeometryBuilder.js';\nimport '../math/Matrices/Matrix.js';\nimport '../math/Matrices/MatrixInterface.js';\nimport './ShapeBuilder.js';\nimport 'libtess';\nimport './GeometryBufferCache.js';\nimport '../image/const.js';\nimport '../math/trigonometry.js';\nimport '../type/p5.Font.js';\nimport '../type/textCore.js';\nimport '@japont/unicode-range';\nimport '../type/unicodeRanges.js';\nimport '../type/lib/Typr.js';\nimport 'pako';\nimport '@davepagurek/bezier-path';\nimport 'acorn';\nimport 'acorn-walk';\nimport 'escodegen';\n\nfunction webgl(p5){\n  rendererGL(p5, p5.prototype);\n  primitives3D(p5, p5.prototype);\n  interaction(p5, p5.prototype);\n  light(p5, p5.prototype);\n  loading(p5, p5.prototype);\n  material(p5, p5.prototype);\n  text(p5, p5.prototype);\n  renderBuffer(p5, p5.prototype);\n  quat(p5, p5.prototype);\n  matrix(p5, p5.prototype);\n  geometry(p5, p5.prototype);\n  camera(p5, p5.prototype);\n  framebuffer(p5, p5.prototype);\n  dataArray(p5, p5.prototype);\n  shader(p5, p5.prototype);\n  texture(p5, p5.prototype);\n  shadergenerator(p5, p5.prototype);\n}\n\nexport { webgl as default };\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,SAAS,MAAM,EAAE;IACf,CAAA,GAAA,uJAAA,CAAA,IAAU,AAAD,EAAE,IAAI,GAAG,SAAS;IAC3B,CAAA,GAAA,uJAAA,CAAA,IAAY,AAAD,EAAE,IAAI,GAAG,SAAS;IAC7B,CAAA,GAAA,qJAAA,CAAA,UAAW,AAAD,EAAE,IAAI,GAAG,SAAS;IAC5B,CAAA,GAAA,uJAAA,CAAA,IAAK,AAAD,EAAE,IAAI,GAAG,SAAS;IACtB,CAAA,GAAA,iJAAA,CAAA,UAAO,AAAD,EAAE,IAAI,GAAG,SAAS;IACxB,CAAA,GAAA,uJAAA,CAAA,IAAQ,AAAD,EAAE,IAAI,GAAG,SAAS;IACzB,CAAA,GAAA,8IAAA,CAAA,UAAI,AAAD,EAAE,IAAI,GAAG,SAAS;IACrB,CAAA,GAAA,4JAAA,CAAA,UAAY,AAAD,EAAE,IAAI,GAAG,SAAS;IAC7B,CAAA,GAAA,oJAAA,CAAA,UAAI,AAAD,EAAE,IAAI,GAAG,SAAS;IACrB,CAAA,GAAA,qKAAA,CAAA,UAAM,AAAD,EAAE,IAAI,GAAG,SAAS;IACvB,CAAA,GAAA,wJAAA,CAAA,UAAQ,AAAD,EAAE,IAAI,GAAG,SAAS;IACzB,CAAA,GAAA,uJAAA,CAAA,IAAM,AAAD,EAAE,IAAI,GAAG,SAAS;IACvB,CAAA,GAAA,uJAAA,CAAA,IAAW,AAAD,EAAE,IAAI,GAAG,SAAS;IAC5B,CAAA,GAAA,yJAAA,CAAA,UAAS,AAAD,EAAE,IAAI,GAAG,SAAS;IAC1B,CAAA,GAAA,uJAAA,CAAA,IAAM,AAAD,EAAE,IAAI,GAAG,SAAS;IACvB,CAAA,GAAA,uJAAA,CAAA,IAAO,AAAD,EAAE,IAAI,GAAG,SAAS;IACxB,CAAA,GAAA,yJAAA,CAAA,UAAe,AAAD,EAAE,IAAI,GAAG,SAAS;AAClC","ignoreList":[0],"debugId":null}}]
}