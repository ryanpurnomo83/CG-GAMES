(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push([typeof document === "object" ? document.currentScript : undefined, {

"[project]/node_modules/p5/dist/webgl/p5.DataArray.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "DataArray": (()=>DataArray),
    "default": (()=>dataArray)
});
class DataArray {
    constructor(initialLength = 128){
        this.length = 0;
        this.data = new Float32Array(initialLength);
        this.initialLength = initialLength;
    }
    /**
   * Returns a Float32Array window sized to the exact length of the data
   */ dataArray() {
        return this.subArray(0, this.length);
    }
    /**
   * A "soft" clear, which keeps the underlying storage size the same, but
   * empties the contents of its dataArray()
   */ clear() {
        this.length = 0;
    }
    /**
   * Can be used to scale a DataArray back down to fit its contents.
   */ rescale() {
        if (this.length < this.data.length / 2) {
            // Find the power of 2 size that fits the data
            const targetLength = 1 << Math.ceil(Math.log2(this.length));
            const newData = new Float32Array(targetLength);
            newData.set(this.data.subarray(0, this.length), 0);
            this.data = newData;
        }
    }
    /**
   * A full reset, which allocates a new underlying Float32Array at its initial
   * length
   */ reset() {
        this.clear();
        this.data = new Float32Array(this.initialLength);
    }
    /**
   * Adds values to the DataArray, expanding its internal storage to
   * accommodate the new items.
   */ push(...values) {
        this.ensureLength(this.length + values.length);
        this.data.set(values, this.length);
        this.length += values.length;
    }
    /**
   * Returns a copy of the data from the index `from`, inclusive, to the index
   * `to`, exclusive
   */ slice(from, to) {
        return this.data.slice(from, Math.min(to, this.length));
    }
    /**
   * Returns a mutable Float32Array window from the index `from`, inclusive, to
   * the index `to`, exclusive
   */ subArray(from, to) {
        return this.data.subarray(from, Math.min(to, this.length));
    }
    /**
   * Expand capacity of the internal storage until it can fit a target size
   */ ensureLength(target) {
        while(this.data.length < target){
            const newData = new Float32Array(this.data.length * 2);
            newData.set(this.data, 0);
            this.data = newData;
        }
    }
}
function dataArray(p51, fn) {
    /**
   * An internal class to store data that will be sent to a p5.RenderBuffer.
   * Those need to eventually go into a Float32Array, so this class provides a
   * variable-length array container backed by a Float32Array so that it can be
   * sent to the GPU without allocating a new array each frame.
   *
   * Like a C++ vector, its fixed-length Float32Array backing its contents will
   * double in size when it goes over its capacity.
   *
   * @example
   * <div>
   * <code>
   * // Initialize storage with a capacity of 4
   * const storage = new DataArray(4);
   * console.log(storage.data.length); // 4
   * console.log(storage.length); // 0
   * console.log(storage.dataArray()); // Empty Float32Array
   *
   * storage.push(1, 2, 3, 4, 5, 6);
   * console.log(storage.data.length); // 8
   * console.log(storage.length); // 6
   * console.log(storage.dataArray()); // Float32Array{1, 2, 3, 4, 5, 6}
   * </code>
   * </div>
   */ p51.DataArray = DataArray;
}
if (typeof p5 !== 'undefined') {
    dataArray(p5, p5.prototype);
}
;
}}),
"[project]/node_modules/p5/dist/webgl/p5.Geometry.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "Geometry": (()=>Geometry),
    "default": (()=>geometry)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$C$2d$g_eAdC$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/constants-C-g_eAdC.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$DataArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.DataArray.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Vector.js [app-client] (ecmascript)");
;
;
;
/**
 * @module Shape
 * @submodule 3D Primitives
 * @for p5
 * @requires core
 * @requires p5.Geometry
 */ class Geometry {
    constructor(detailX, detailY, callback, renderer){
        this.renderer = renderer;
        this.vertices = [];
        this.boundingBoxCache = null;
        //an array containing every vertex for stroke drawing
        this.lineVertices = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$DataArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataArray"]();
        // The tangents going into or out of a vertex on a line. Along a straight
        // line segment, both should be equal. At an endpoint, one or the other
        // will not exist and will be all 0. In joins between line segments, they
        // may be different, as they will be the tangents on either side of the join.
        this.lineTangentsIn = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$DataArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataArray"]();
        this.lineTangentsOut = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$DataArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataArray"]();
        // When drawing lines with thickness, entries in this buffer represent which
        // side of the centerline the vertex will be placed. The sign of the number
        // will represent the side of the centerline, and the absolute value will be
        // used as an enum to determine which part of the cap or join each vertex
        // represents. See the doc comments for _addCap and _addJoin for diagrams.
        this.lineSides = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$DataArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataArray"]();
        this.vertexNormals = [];
        this.faces = [];
        this.uvs = [];
        // a 2D array containing edge connectivity pattern for create line vertices
        //based on faces for most objects;
        this.edges = [];
        this.vertexColors = [];
        // One color per vertex representing the stroke color at that vertex
        this.vertexStrokeColors = [];
        this.userVertexProperties = {};
        // One color per line vertex, generated automatically based on
        // vertexStrokeColors in _edgesToVertices()
        this.lineVertexColors = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$DataArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataArray"]();
        this.detailX = detailX !== undefined ? detailX : 1;
        this.detailY = detailY !== undefined ? detailY : 1;
        this.dirtyFlags = {};
        this._hasFillTransparency = undefined;
        this._hasStrokeTransparency = undefined;
        this.gid = `_p5_Geometry_${Geometry.nextId}`;
        Geometry.nextId++;
        if (callback instanceof Function) {
            callback.call(this);
        }
    }
    /**
 * Calculates the position and size of the smallest box that contains the geometry.
 *
 * A bounding box is the smallest rectangular prism that contains the entire
 * geometry. It's defined by the box's minimum and maximum coordinates along
 * each axis, as well as the size (length) and offset (center).
 *
 * Calling `myGeometry.calculateBoundingBox()` returns an object with four
 * properties that describe the bounding box:
 *
 * ```js
 * // Get myGeometry's bounding box.
 * let bbox = myGeometry.calculateBoundingBox();
 *
 * // Print the bounding box to the console.
 * console.log(bbox);
 *
 * // {
 * //  // The minimum coordinate along each axis.
 * //  min: { x: -1, y: -2, z: -3 },
 * //
 * //  // The maximum coordinate along each axis.
 * //  max: { x: 1, y: 2, z: 3},
 * //
 * //  // The size (length) along each axis.
 * //  size: { x: 2, y: 4, z: 6},
 * //
 * //  // The offset (center) along each axis.
 * //  offset: { x: 0, y: 0, z: 0}
 * // }
 * ```
 *
 * @returns {Object} bounding box of the geometry.
 *
 * @example
 * <div>
 * <code>
 * // Click and drag the mouse to view the scene from different angles.
 *
 * let particles;
 *
 * function setup() {
 *   createCanvas(100, 100, WEBGL);
 *
 *   // Create a new p5.Geometry object with random spheres.
 *   particles = buildGeometry(createParticles);
 *
 *   describe('Ten white spheres placed randomly against a gray background. A box encloses the spheres.');
 * }
 *
 * function draw() {
 *   background(50);
 *
 *   // Enable orbiting with the mouse.
 *   orbitControl();
 *
 *   // Turn on the lights.
 *   lights();
 *
 *   // Style the particles.
 *   noStroke();
 *   fill(255);
 *
 *   // Draw the particles.
 *   model(particles);
 *
 *   // Calculate the bounding box.
 *   let bbox = particles.calculateBoundingBox();
 *
 *   // Translate to the bounding box's center.
 *   translate(bbox.offset.x, bbox.offset.y, bbox.offset.z);
 *
 *   // Style the bounding box.
 *   stroke(255);
 *   noFill();
 *
 *   // Draw the bounding box.
 *   box(bbox.size.x, bbox.size.y, bbox.size.z);
 * }
 *
 * function createParticles() {
 *   for (let i = 0; i < 10; i += 1) {
 *     // Calculate random coordinates.
 *     let x = randomGaussian(0, 15);
 *     let y = randomGaussian(0, 15);
 *     let z = randomGaussian(0, 15);
 *
 *     push();
 *     // Translate to the particle's coordinates.
 *     translate(x, y, z);
 *     // Draw the particle.
 *     sphere(3);
 *     pop();
 *   }
 * }
 * </code>
 * </div>
 */ calculateBoundingBox() {
        if (this.boundingBoxCache) {
            return this.boundingBoxCache; // Return cached result if available
        }
        let minVertex = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"](Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        let maxVertex = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"](Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE);
        for(let i = 0; i < this.vertices.length; i++){
            let vertex = this.vertices[i];
            minVertex.x = Math.min(minVertex.x, vertex.x);
            minVertex.y = Math.min(minVertex.y, vertex.y);
            minVertex.z = Math.min(minVertex.z, vertex.z);
            maxVertex.x = Math.max(maxVertex.x, vertex.x);
            maxVertex.y = Math.max(maxVertex.y, vertex.y);
            maxVertex.z = Math.max(maxVertex.z, vertex.z);
        }
        // Calculate size and offset properties
        let size = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"](maxVertex.x - minVertex.x, maxVertex.y - minVertex.y, maxVertex.z - minVertex.z);
        let offset = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"]((minVertex.x + maxVertex.x) / 2, (minVertex.y + maxVertex.y) / 2, (minVertex.z + maxVertex.z) / 2);
        // Cache the result for future access
        this.boundingBoxCache = {
            min: minVertex,
            max: maxVertex,
            size: size,
            offset: offset
        };
        return this.boundingBoxCache;
    }
    reset() {
        this._hasFillTransparency = undefined;
        this._hasStrokeTransparency = undefined;
        this.lineVertices.clear();
        this.lineTangentsIn.clear();
        this.lineTangentsOut.clear();
        this.lineSides.clear();
        this.vertices.length = 0;
        this.edges.length = 0;
        this.vertexColors.length = 0;
        this.vertexStrokeColors.length = 0;
        this.lineVertexColors.clear();
        this.vertexNormals.length = 0;
        this.uvs.length = 0;
        for(const propName in this.userVertexProperties){
            this.userVertexProperties[propName].delete();
        }
        this.userVertexProperties = {};
        this.dirtyFlags = {};
    }
    hasFillTransparency() {
        if (this._hasFillTransparency === undefined) {
            this._hasFillTransparency = false;
            for(let i = 0; i < this.vertexColors.length; i += 4){
                if (this.vertexColors[i + 3] < 1) {
                    this._hasFillTransparency = true;
                    break;
                }
            }
        }
        return this._hasFillTransparency;
    }
    hasStrokeTransparency() {
        if (this._hasStrokeTransparency === undefined) {
            this._hasStrokeTransparency = false;
            for(let i = 0; i < this.lineVertexColors.length; i += 4){
                if (this.lineVertexColors[i + 3] < 1) {
                    this._hasStrokeTransparency = true;
                    break;
                }
            }
        }
        return this._hasStrokeTransparency;
    }
    /**
   * Removes the geometry’s internal colors.
   *
   * `p5.Geometry` objects can be created with "internal colors" assigned to
   * vertices or the entire shape. When a geometry has internal colors,
   * <a href="#/p5/fill">fill()</a> has no effect. Calling
   * `myGeometry.clearColors()` allows the
   * <a href="#/p5/fill">fill()</a> function to apply color to the geometry.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   background(200);
   *
   *   // Create a p5.Geometry object.
   *   // Set its internal color to red.
   *   let myGeometry = buildGeometry(function() {
   *     fill(255, 0, 0);
   *     plane(20);
   *   });
   *
   *   // Style the shape.
   *   noStroke();
   *
   *   // Draw the p5.Geometry object (center).
   *   model(myGeometry);
   *
   *   // Translate the origin to the bottom-right.
   *   translate(25, 25, 0);
   *
   *   // Try to fill the geometry with green.
   *   fill(0, 255, 0);
   *
   *   // Draw the geometry again (bottom-right).
   *   model(myGeometry);
   *
   *   // Clear the geometry's colors.
   *   myGeometry.clearColors();
   *
   *   // Fill the geometry with blue.
   *   fill(0, 0, 255);
   *
   *   // Translate the origin up.
   *   translate(0, -50, 0);
   *
   *   // Draw the geometry again (top-right).
   *   model(myGeometry);
   *
   *   describe(
   *     'Three squares drawn against a gray background. Red squares are at the center and the bottom-right. A blue square is at the top-right.'
   *   );
   * }
   * </code>
   * </div>
   */ clearColors() {
        this.vertexColors = [];
        return this;
    }
    /**
   * The `saveObj()` function exports `p5.Geometry` objects as
   * 3D models in the Wavefront .obj file format.
   * This way, you can use the 3D shapes you create in p5.js in other software
   * for rendering, animation, 3D printing, or more.
   *
   * The exported .obj file will include the faces and vertices of the `p5.Geometry`,
   * as well as its texture coordinates and normals, if it has them.
   *
   * @method saveObj
   * @param {String} [fileName='model.obj'] The name of the file to save the model as.
   *                                        If not specified, the default file name will be 'model.obj'.
   * @example
   * <div>
   * <code>
   * let myModel;
   * let saveBtn;
   * function setup() {
   *   createCanvas(200, 200, WEBGL);
   *   myModel = buildGeometry(function()) {
   *     for (let i = 0; i < 5; i++) {
   *       push();
   *       translate(
   *         random(-75, 75),
   *         random(-75, 75),
   *         random(-75, 75)
   *       );
   *       sphere(random(5, 50));
   *       pop();
   *     }
   *   });
   *
   *   saveBtn = createButton('Save .obj');
   *   saveBtn.mousePressed(() => myModel.saveObj());
   *
   *   describe('A few spheres rotating in space');
   * }
   *
   * function draw() {
   *   background(0);
   *   noStroke();
   *   lights();
   *   rotateX(millis() * 0.001);
   *   rotateY(millis() * 0.002);
   *   model(myModel);
   * }
   * </code>
   * </div>
   */ saveObj(fileName = 'model.obj') {
        let objStr = '';
        // Vertices
        this.vertices.forEach((v)=>{
            objStr += `v ${v.x} ${v.y} ${v.z}\n`;
        });
        // Texture Coordinates (UVs)
        if (this.uvs && this.uvs.length > 0) {
            for(let i = 0; i < this.uvs.length; i += 2){
                objStr += `vt ${this.uvs[i]} ${this.uvs[i + 1]}\n`;
            }
        }
        // Vertex Normals
        if (this.vertexNormals && this.vertexNormals.length > 0) {
            this.vertexNormals.forEach((n)=>{
                objStr += `vn ${n.x} ${n.y} ${n.z}\n`;
            });
        }
        // Faces, obj vertex indices begin with 1 and not 0
        // texture coordinate (uvs) and vertexNormal indices
        // are indicated with trailing ints vertex/normal/uv
        // ex 1/1/1 or 2//2 for vertices without uvs
        this.faces.forEach((face)=>{
            let faceStr = 'f';
            face.forEach((index)=>{
                faceStr += ' ';
                faceStr += index + 1;
                if (this.vertexNormals.length > 0 || this.uvs.length > 0) {
                    faceStr += '/';
                    if (this.uvs.length > 0) {
                        faceStr += index + 1;
                    }
                    faceStr += '/';
                    if (this.vertexNormals.length > 0) {
                        faceStr += index + 1;
                    }
                }
            });
            objStr += faceStr + '\n';
        });
        const blob = new Blob([
            objStr
        ], {
            type: 'text/plain'
        });
        fn.downloadFile(blob, fileName, 'obj');
    }
    /**
   * The `saveStl()` function exports `p5.Geometry` objects as
   * 3D models in the STL stereolithography file format.
   * This way, you can use the 3D shapes you create in p5.js in other software
   * for rendering, animation, 3D printing, or more.
   *
   * The exported .stl file will include the faces, vertices, and normals of the `p5.Geometry`.
   *
   * By default, this method saves a text-based .stl file. Alternatively, you can save a more compact
   * but less human-readable binary .stl file by passing `{ binary: true }` as a second parameter.
   *
   * @method saveStl
   * @param {String} [fileName='model.stl'] The name of the file to save the model as.
   *                                        If not specified, the default file name will be 'model.stl'.
   * @param {Object} [options] Optional settings. Options can include a boolean `binary` property, which
   * controls whether or not a binary .stl file is saved. It defaults to false.
   * @example
   * <div>
   * <code>
   * let myModel;
   * let saveBtn1;
   * let saveBtn2;
   * function setup() {
   *   createCanvas(200, 200, WEBGL);
   *   myModel = buildGeometry(function() {
   *     for (let i = 0; i < 5; i++) {
   *       push();
   *       translate(
   *         random(-75, 75),
   *         random(-75, 75),
   *         random(-75, 75)
   *       );
   *       sphere(random(5, 50));
   *       pop();
   *     }
   *   });
   *
   *   saveBtn1 = createButton('Save .stl');
   *   saveBtn1.mousePressed(function() {
   *     myModel.saveStl();
   *   });
   *   saveBtn2 = createButton('Save binary .stl');
   *   saveBtn2.mousePressed(function() {
   *     myModel.saveStl('model.stl', { binary: true });
   *   });
   *
   *   describe('A few spheres rotating in space');
   * }
   *
   * function draw() {
   *   background(0);
   *   noStroke();
   *   lights();
   *   rotateX(millis() * 0.001);
   *   rotateY(millis() * 0.002);
   *   model(myModel);
   * }
   * </code>
   * </div>
   */ saveStl(fileName = 'model.stl', { binary = false } = {}) {
        let modelOutput;
        let name = fileName.substring(0, fileName.lastIndexOf('.'));
        let faceNormals = [];
        for (let f of this.faces){
            const U = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"].sub(this.vertices[f[1]], this.vertices[f[0]]);
            const V = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"].sub(this.vertices[f[2]], this.vertices[f[0]]);
            const nx = U.y * V.z - U.z * V.y;
            const ny = U.z * V.x - U.x * V.z;
            const nz = U.x * V.y - U.y * V.x;
            faceNormals.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"](nx, ny, nz).normalize());
        }
        if (binary) {
            let offset = 80;
            const bufferLength = this.faces.length * 2 + this.faces.length * 3 * 4 * 4 + 80 + 4;
            const arrayBuffer = new ArrayBuffer(bufferLength);
            modelOutput = new DataView(arrayBuffer);
            modelOutput.setUint32(offset, this.faces.length, true);
            offset += 4;
            for (const [key, f] of Object.entries(this.faces)){
                const norm = faceNormals[key];
                modelOutput.setFloat32(offset, norm.x, true);
                offset += 4;
                modelOutput.setFloat32(offset, norm.y, true);
                offset += 4;
                modelOutput.setFloat32(offset, norm.z, true);
                offset += 4;
                for (let vertexIndex of f){
                    const vert = this.vertices[vertexIndex];
                    modelOutput.setFloat32(offset, vert.x, true);
                    offset += 4;
                    modelOutput.setFloat32(offset, vert.y, true);
                    offset += 4;
                    modelOutput.setFloat32(offset, vert.z, true);
                    offset += 4;
                }
                modelOutput.setUint16(offset, 0, true);
                offset += 2;
            }
        } else {
            modelOutput = 'solid ' + name + '\n';
            for (const [key, f] of Object.entries(this.faces)){
                const norm = faceNormals[key];
                modelOutput += ' facet norm ' + norm.x + ' ' + norm.y + ' ' + norm.z + '\n';
                modelOutput += '  outer loop' + '\n';
                for (let vertexIndex of f){
                    const vert = this.vertices[vertexIndex];
                    modelOutput += '   vertex ' + vert.x + ' ' + vert.y + ' ' + vert.z + '\n';
                }
                modelOutput += '  endloop' + '\n';
                modelOutput += ' endfacet' + '\n';
            }
            modelOutput += 'endsolid ' + name + '\n';
        }
        const blob = new Blob([
            modelOutput
        ], {
            type: 'text/plain'
        });
        fn.downloadFile(blob, fileName, 'stl');
    }
    /**
   * Flips the geometry’s texture u-coordinates.
   *
   * In order for <a href="#/p5/texture">texture()</a> to work, the geometry
   * needs a way to map the points on its surface to the pixels in a rectangular
   * image that's used as a texture. The geometry's vertex at coordinates
   * `(x, y, z)` maps to the texture image's pixel at coordinates `(u, v)`.
   *
   * The <a href="#/p5.Geometry/uvs">myGeometry.uvs</a> array stores the
   * `(u, v)` coordinates for each vertex in the order it was added to the
   * geometry. Calling `myGeometry.flipU()` flips a geometry's u-coordinates
   * so that the texture appears mirrored horizontally.
   *
   * For example, a plane's four vertices are added clockwise starting from the
   * top-left corner. Here's how calling `myGeometry.flipU()` would change a
   * plane's texture coordinates:
   *
   * ```js
   * // Print the original texture coordinates.
   * // Output: [0, 0, 1, 0, 0, 1, 1, 1]
   * console.log(myGeometry.uvs);
   *
   * // Flip the u-coordinates.
   * myGeometry.flipU();
   *
   * // Print the flipped texture coordinates.
   * // Output: [1, 0, 0, 0, 1, 1, 0, 1]
   * console.log(myGeometry.uvs);
   *
   * // Notice the swaps:
   * // Top vertices: [0, 0, 1, 0] --> [1, 0, 0, 0]
   * // Bottom vertices: [0, 1, 1, 1] --> [1, 1, 0, 1]
   * ```
   *
   * @for p5.Geometry
   *
   * @example
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   img = await loadImage('assets/laDefense.jpg');
   *   createCanvas(100, 100, WEBGL);
   *
   *   background(200);
   *
   *   // Create p5.Geometry objects.
   *   let geom1 = buildGeometry(createShape);
   *   let geom2 = buildGeometry(createShape);
   *
   *   // Flip geom2's U texture coordinates.
   *   geom2.flipU();
   *
   *   // Left (original).
   *   push();
   *   translate(-25, 0, 0);
   *   texture(img);
   *   noStroke();
   *   model(geom1);
   *   pop();
   *
   *   // Right (flipped).
   *   push();
   *   translate(25, 0, 0);
   *   texture(img);
   *   noStroke();
   *   model(geom2);
   *   pop();
   *
   *   describe(
   *     'Two photos of a ceiling on a gray background. The photos are mirror images of each other.'
   *   );
   * }
   *
   * function createShape() {
   *   plane(40);
   * }
   * </code>
   * </div>
   */ flipU() {
        this.uvs = this.uvs.flat().map((val, index)=>{
            if (index % 2 === 0) {
                return 1 - val;
            } else {
                return val;
            }
        });
    }
    /**
   * Flips the geometry’s texture v-coordinates.
   *
   * In order for <a href="#/p5/texture">texture()</a> to work, the geometry
   * needs a way to map the points on its surface to the pixels in a rectangular
   * image that's used as a texture. The geometry's vertex at coordinates
   * `(x, y, z)` maps to the texture image's pixel at coordinates `(u, v)`.
   *
   * The <a href="#/p5.Geometry/uvs">myGeometry.uvs</a> array stores the
   * `(u, v)` coordinates for each vertex in the order it was added to the
   * geometry. Calling `myGeometry.flipV()` flips a geometry's v-coordinates
   * so that the texture appears mirrored vertically.
   *
   * For example, a plane's four vertices are added clockwise starting from the
   * top-left corner. Here's how calling `myGeometry.flipV()` would change a
   * plane's texture coordinates:
   *
   * ```js
   * // Print the original texture coordinates.
   * // Output: [0, 0, 1, 0, 0, 1, 1, 1]
   * console.log(myGeometry.uvs);
   *
   * // Flip the v-coordinates.
   * myGeometry.flipV();
   *
   * // Print the flipped texture coordinates.
   * // Output: [0, 1, 1, 1, 0, 0, 1, 0]
   * console.log(myGeometry.uvs);
   *
   * // Notice the swaps:
   * // Left vertices: [0, 0] <--> [1, 0]
   * // Right vertices: [1, 0] <--> [1, 1]
   * ```
   *
   * @method flipV
   * @for p5.Geometry
   *
   * @example
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   img = await loadImage('assets/laDefense.jpg');
   *   createCanvas(100, 100, WEBGL);
   *
   *   background(200);
   *
   *   // Create p5.Geometry objects.
   *   let geom1 = buildGeometry(createShape);
   *   let geom2 = buildGeometry(createShape);
   *
   *   // Flip geom2's V texture coordinates.
   *   geom2.flipV();
   *
   *   // Left (original).
   *   push();
   *   translate(-25, 0, 0);
   *   texture(img);
   *   noStroke();
   *   model(geom1);
   *   pop();
   *
   *   // Right (flipped).
   *   push();
   *   translate(25, 0, 0);
   *   texture(img);
   *   noStroke();
   *   model(geom2);
   *   pop();
   *
   *   describe(
   *     'Two photos of a ceiling on a gray background. The photos are mirror images of each other.'
   *   );
   * }
   *
   * function createShape() {
   *   plane(40);
   * }
   * </code>
   * </div>
   */ flipV() {
        this.uvs = this.uvs.flat().map((val, index)=>{
            if (index % 2 === 0) {
                return val;
            } else {
                return 1 - val;
            }
        });
    }
    /**
   * Computes the geometry's faces using its vertices.
   *
   * All 3D shapes are made by connecting sets of points called *vertices*. A
   * geometry's surface is formed by connecting vertices to form triangles that
   * are stitched together. Each triangular patch on the geometry's surface is
   * called a *face*. `myGeometry.computeFaces()` performs the math needed to
   * define each face based on the distances between vertices.
   *
   * The geometry's vertices are stored as <a href="#/p5.Vector">p5.Vector</a>
   * objects in the <a href="#/p5.Geometry/vertices">myGeometry.vertices</a>
   * array. The geometry's first vertex is the
   * <a href="#/p5.Vector">p5.Vector</a> object at `myGeometry.vertices[0]`,
   * its second vertex is `myGeometry.vertices[1]`, its third vertex is
   * `myGeometry.vertices[2]`, and so on.
   *
   * Calling `myGeometry.computeFaces()` fills the
   * <a href="#/p5.Geometry/faces">myGeometry.faces</a> array with three-element
   * arrays that list the vertices that form each face. For example, a geometry
   * made from a rectangle has two faces because a rectangle is made by joining
   * two triangles. <a href="#/p5.Geometry/faces">myGeometry.faces</a> for a
   * rectangle would be the two-dimensional array
   * `[[0, 1, 2], [2, 1, 3]]`. The first face, `myGeometry.faces[0]`, is the
   * array `[0, 1, 2]` because it's formed by connecting
   * `myGeometry.vertices[0]`, `myGeometry.vertices[1]`,and
   * `myGeometry.vertices[2]`. The second face, `myGeometry.faces[1]`, is the
   * array `[2, 1, 3]` because it's formed by connecting
   * `myGeometry.vertices[2]`, `myGeometry.vertices[1]`, and
   * `myGeometry.vertices[3]`.
   *
   * Note: `myGeometry.computeFaces()` only works when geometries have four or more vertices.
   *
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Geometry object.
   *   myGeometry = new p5.Geometry();
   *
   *   // Create p5.Vector objects to position the vertices.
   *   let v0 = createVector(-40, 0, 0);
   *   let v1 = createVector(0, -40, 0);
   *   let v2 = createVector(0, 40, 0);
   *   let v3 = createVector(40, 0, 0);
   *
   *   // Add the vertices to myGeometry's vertices array.
   *   myGeometry.vertices.push(v0, v1, v2, v3);
   *
   *   // Compute myGeometry's faces array.
   *   myGeometry.computeFaces();
   *
   *   describe('A red square drawn on a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Turn on the lights.
   *   lights();
   *
   *   // Style the shape.
   *   noStroke();
   *   fill(255, 0, 0);
   *
   *   // Draw the p5.Geometry object.
   *   model(myGeometry);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Geometry object using a callback function.
   *   myGeometry = new p5.Geometry(1, 1, createShape);
   *
   *   describe('A red square drawn on a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Turn on the lights.
   *   lights();
   *
   *   // Style the shape.
   *   noStroke();
   *   fill(255, 0, 0);
   *
   *   // Draw the p5.Geometry object.
   *   model(myGeometry);
   * }
   *
   * function createShape() {
   *   // Create p5.Vector objects to position the vertices.
   *   let v0 = createVector(-40, 0, 0);
   *   let v1 = createVector(0, -40, 0);
   *   let v2 = createVector(0, 40, 0);
   *   let v3 = createVector(40, 0, 0);
   *
   *   // Add the vertices to the p5.Geometry object's vertices array.
   *   this.vertices.push(v0, v1, v2, v3);
   *
   *   // Compute the faces array.
   *   this.computeFaces();
   * }
   * </code>
   * </div>
   */ computeFaces() {
        this.faces.length = 0;
        const sliceCount = this.detailX + 1;
        let a, b, c, d;
        for(let i = 0; i < this.detailY; i++){
            for(let j = 0; j < this.detailX; j++){
                a = i * sliceCount + j; // + offset;
                b = i * sliceCount + j + 1; // + offset;
                c = (i + 1) * sliceCount + j + 1; // + offset;
                d = (i + 1) * sliceCount + j; // + offset;
                this.faces.push([
                    a,
                    b,
                    d
                ]);
                this.faces.push([
                    d,
                    b,
                    c
                ]);
            }
        }
        return this;
    }
    _getFaceNormal(faceId) {
        //This assumes that vA->vB->vC is a counter-clockwise ordering
        const face = this.faces[faceId];
        const vA = this.vertices[face[0]];
        const vB = this.vertices[face[1]];
        const vC = this.vertices[face[2]];
        const ab = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"].sub(vB, vA);
        const ac = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"].sub(vC, vA);
        const n = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"].cross(ab, ac);
        const ln = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"].mag(n);
        let sinAlpha = ln / (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"].mag(ab) * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"].mag(ac));
        if (sinAlpha === 0 || isNaN(sinAlpha)) {
            console.warn('p5.Geometry.prototype._getFaceNormal:', 'face has colinear sides or a repeated vertex');
            return n;
        }
        if (sinAlpha > 1) sinAlpha = 1; // handle float rounding error
        return n.mult(Math.asin(sinAlpha) / ln);
    }
    /**
   * Calculates the normal vector for each vertex on the geometry.
   *
   * All 3D shapes are made by connecting sets of points called *vertices*. A
   * geometry's surface is formed by connecting vertices to create triangles
   * that are stitched together. Each triangular patch on the geometry's
   * surface is called a *face*. `myGeometry.computeNormals()` performs the
   * math needed to orient each face. Orientation is important for lighting
   * and other effects.
   *
   * A face's orientation is defined by its *normal vector* which points out
   * of the face and is normal (perpendicular) to the surface. Calling
   * `myGeometry.computeNormals()` first calculates each face's normal vector.
   * Then it calculates the normal vector for each vertex by averaging the
   * normal vectors of the faces surrounding the vertex. The vertex normals
   * are stored as <a href="#/p5.Vector">p5.Vector</a> objects in the
   * <a href="#/p5.Geometry/vertexNormals">myGeometry.vertexNormals</a> array.
   *
   * The first parameter, `shadingType`, is optional. Passing the constant
   * `FLAT`, as in `myGeometry.computeNormals(FLAT)`, provides neighboring
   * faces with their own copies of the vertices they share. Surfaces appear
   * tiled with flat shading. Passing the constant `SMOOTH`, as in
   * `myGeometry.computeNormals(SMOOTH)`, makes neighboring faces reuse their
   * shared vertices. Surfaces appear smoother with smooth shading. By
   * default, `shadingType` is `FLAT`.
   *
   * The second parameter, `options`, is also optional. If an object with a
   * `roundToPrecision` property is passed, as in
   * `myGeometry.computeNormals(SMOOTH, { roundToPrecision: 5 })`, it sets the
   * number of decimal places to use for calculations. By default,
   * `roundToPrecision` uses 3 decimal places.
   *
   * @param {(FLAT|SMOOTH)} [shadingType=FLAT] shading type. either FLAT or SMOOTH. Defaults to `FLAT`.
   * @param {Object} [options] shading options.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Geometry object.
   *   myGeometry = buildGeometry(function() {
   *     torus();
   *   });
   *
   *   // Compute the vertex normals.
   *   myGeometry.computeNormals();
   *
   *   describe(
   *     "A white torus drawn on a dark gray background. Red lines extend outward from the torus' vertices."
   *   );
   * }
   *
   * function draw() {
   *   background(50);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Turn on the lights.
   *   lights();
   *
   *   // Rotate the coordinate system.
   *   rotateX(1);
   *
   *   // Style the helix.
   *   stroke(0);
   *
   *   // Display the helix.
   *   model(myGeometry);
   *
   *   // Style the normal vectors.
   *   stroke(255, 0, 0);
   *
   *   // Iterate over the vertices and vertexNormals arrays.
   *   for (let i = 0; i < myGeometry.vertices.length; i += 1) {
   *
   *     // Get the vertex p5.Vector object.
   *     let v = myGeometry.vertices[i];
   *
   *     // Get the vertex normal p5.Vector object.
   *     let n = myGeometry.vertexNormals[i];
   *
   *     // Calculate a point along the vertex normal.
   *     let p = p5.Vector.mult(n, 5);
   *
   *     // Draw the vertex normal as a red line.
   *     push();
   *     translate(v);
   *     line(0, 0, 0, p.x, p.y, p.z);
   *     pop();
   *   }
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Geometry object using a callback function.
   *   myGeometry = new p5.Geometry();
   *
   *   // Create p5.Vector objects to position the vertices.
   *   let v0 = createVector(-40, 0, 0);
   *   let v1 = createVector(0, -40, 0);
   *   let v2 = createVector(0, 40, 0);
   *   let v3 = createVector(40, 0, 0);
   *
   *   // Add the vertices to the p5.Geometry object's vertices array.
   *   myGeometry.vertices.push(v0, v1, v2, v3);
   *
   *   // Compute the faces array.
   *   myGeometry.computeFaces();
   *
   *   // Compute the surface normals.
   *   myGeometry.computeNormals();
   *
   *   describe('A red square drawn on a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Add a white point light.
   *   pointLight(255, 255, 255, 0, 0, 10);
   *
   *   // Style the p5.Geometry object.
   *   noStroke();
   *   fill(255, 0, 0);
   *
   *   // Draw the p5.Geometry object.
   *   model(myGeometry);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Geometry object.
   *   myGeometry = buildGeometry(createShape);
   *
   *   // Compute normals using default (FLAT) shading.
   *   myGeometry.computeNormals(FLAT);
   *
   *   describe('A white, helical structure drawn on a dark gray background. Its faces appear faceted.');
   * }
   *
   * function draw() {
   *   background(50);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Turn on the lights.
   *   lights();
   *
   *   // Rotate the coordinate system.
   *   rotateX(1);
   *
   *   // Style the helix.
   *   noStroke();
   *
   *   // Display the helix.
   *   model(myGeometry);
   * }
   *
   * function createShape() {
   *   // Create a helical shape.
   *   beginShape();
   *   for (let i = 0; i < TWO_PI * 3; i += 0.5) {
   *     let x = 30 * cos(i);
   *     let y = 30 * sin(i);
   *     let z = map(i, 0, TWO_PI * 3, -40, 40);
   *     vertex(x, y, z);
   *   }
   *   endShape();
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Geometry object.
   *   myGeometry = buildGeometry(createShape);
   *
   *   // Compute normals using smooth shading.
   *   myGeometry.computeNormals(SMOOTH);
   *
   *   describe('A white, helical structure drawn on a dark gray background.');
   * }
   *
   * function draw() {
   *   background(50);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Turn on the lights.
   *   lights();
   *
   *   // Rotate the coordinate system.
   *   rotateX(1);
   *
   *   // Style the helix.
   *   noStroke();
   *
   *   // Display the helix.
   *   model(myGeometry);
   * }
   *
   * function createShape() {
   *   // Create a helical shape.
   *   beginShape();
   *   for (let i = 0; i < TWO_PI * 3; i += 0.5) {
   *     let x = 30 * cos(i);
   *     let y = 30 * sin(i);
   *     let z = map(i, 0, TWO_PI * 3, -40, 40);
   *     vertex(x, y, z);
   *   }
   *   endShape();
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Geometry object.
   *   myGeometry = buildGeometry(createShape);
   *
   *   // Create an options object.
   *   let options = { roundToPrecision: 5 };
   *
   *   // Compute normals using smooth shading.
   *   myGeometry.computeNormals(SMOOTH, options);
   *
   *   describe('A white, helical structure drawn on a dark gray background.');
   * }
   *
   * function draw() {
   *   background(50);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Turn on the lights.
   *   lights();
   *
   *   // Rotate the coordinate system.
   *   rotateX(1);
   *
   *   // Style the helix.
   *   noStroke();
   *
   *   // Display the helix.
   *   model(myGeometry);
   * }
   *
   * function createShape() {
   *   // Create a helical shape.
   *   beginShape();
   *   for (let i = 0; i < TWO_PI * 3; i += 0.5) {
   *     let x = 30 * cos(i);
   *     let y = 30 * sin(i);
   *     let z = map(i, 0, TWO_PI * 3, -40, 40);
   *     vertex(x, y, z);
   *   }
   *   endShape();
   * }
   * </code>
   * </div>
   */ computeNormals(shadingType = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$C$2d$g_eAdC$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["F"], { roundToPrecision = 3 } = {}) {
        const vertexNormals = this.vertexNormals;
        let vertices = this.vertices;
        const faces = this.faces;
        let iv;
        if (shadingType === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$C$2d$g_eAdC$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["y"]) {
            const vertexIndices = {};
            const uniqueVertices = [];
            const power = Math.pow(10, roundToPrecision);
            const rounded = (val)=>Math.round(val * power) / power;
            const getKey = (vert)=>`${rounded(vert.x)},${rounded(vert.y)},${rounded(vert.z)}`;
            // loop through each vertex and add uniqueVertices
            for(let i = 0; i < vertices.length; i++){
                const vertex = vertices[i];
                const key = getKey(vertex);
                if (vertexIndices[key] === undefined) {
                    vertexIndices[key] = uniqueVertices.length;
                    uniqueVertices.push(vertex);
                }
            }
            // update face indices to use the deduplicated vertex indices
            faces.forEach((face)=>{
                for(let fv = 0; fv < 3; ++fv){
                    const originalVertexIndex = face[fv];
                    const originalVertex = vertices[originalVertexIndex];
                    const key = getKey(originalVertex);
                    face[fv] = vertexIndices[key];
                }
            });
            // update edge indices to use the deduplicated vertex indices
            this.edges.forEach((edge)=>{
                for(let ev = 0; ev < 2; ++ev){
                    const originalVertexIndex = edge[ev];
                    const originalVertex = vertices[originalVertexIndex];
                    const key = getKey(originalVertex);
                    edge[ev] = vertexIndices[key];
                }
            });
            // update the deduplicated vertices
            this.vertices = vertices = uniqueVertices;
        }
        // initialize the vertexNormals array with empty vectors
        vertexNormals.length = 0;
        for(iv = 0; iv < vertices.length; ++iv){
            vertexNormals.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"]());
        }
        // loop through all the faces adding its normal to the normal
        // of each of its vertices
        faces.forEach((face, f)=>{
            const faceNormal = this._getFaceNormal(f);
            // all three vertices get the normal added
            for(let fv = 0; fv < 3; ++fv){
                const vertexIndex = face[fv];
                vertexNormals[vertexIndex].add(faceNormal);
            }
        });
        // normalize the normals
        for(iv = 0; iv < vertices.length; ++iv){
            vertexNormals[iv].normalize();
        }
        return this;
    }
    /**
   * Averages the vertex normals. Used in curved
   * surfaces
   * @private
   * @chainable
   */ averageNormals() {
        for(let i = 0; i <= this.detailY; i++){
            const offset = this.detailX + 1;
            let temp = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"].add(this.vertexNormals[i * offset], this.vertexNormals[i * offset + this.detailX]);
            temp = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"].div(temp, 2);
            this.vertexNormals[i * offset] = temp;
            this.vertexNormals[i * offset + this.detailX] = temp;
        }
        return this;
    }
    /**
   * Averages pole normals.  Used in spherical primitives
   * @private
   * @chainable
   */ averagePoleNormals() {
        //average the north pole
        let sum = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"](0, 0, 0);
        for(let i = 0; i < this.detailX; i++){
            sum.add(this.vertexNormals[i]);
        }
        sum = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"].div(sum, this.detailX);
        for(let i = 0; i < this.detailX; i++){
            this.vertexNormals[i] = sum;
        }
        //average the south pole
        sum = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"](0, 0, 0);
        for(let i = this.vertices.length - 1; i > this.vertices.length - 1 - this.detailX; i--){
            sum.add(this.vertexNormals[i]);
        }
        sum = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"].div(sum, this.detailX);
        for(let i = this.vertices.length - 1; i > this.vertices.length - 1 - this.detailX; i--){
            this.vertexNormals[i] = sum;
        }
        return this;
    }
    /**
   * Create a 2D array for establishing stroke connections
   * @private
   * @chainable
   */ _makeTriangleEdges() {
        this.edges.length = 0;
        for(let j = 0; j < this.faces.length; j++){
            this.edges.push([
                this.faces[j][0],
                this.faces[j][1]
            ]);
            this.edges.push([
                this.faces[j][1],
                this.faces[j][2]
            ]);
            this.edges.push([
                this.faces[j][2],
                this.faces[j][0]
            ]);
        }
        return this;
    }
    /**
   * @example
   * <div>
   * <code>
   * let tetrahedron;
   * function setup() {
   *   createCanvas(200, 200, WEBGL);
   *   describe('A rotating tetrahedron');
   *
   *   tetrahedron = new p5.Geometry();
   *
   *   // Give each geometry a unique gid
   *   tetrahedron.gid = 'tetrahedron';
   *
   *   // Add four points of the tetrahedron
   *
   *   let radius = 50;
   *   // A 2D triangle:
   *   tetrahedron.vertices.push(createVector(radius, 0, 0));
   *   tetrahedron.vertices.push(createVector(radius, 0, 0).rotate(TWO_PI / 3));
   *   tetrahedron.vertices.push(createVector(radius, 0, 0).rotate(TWO_PI * 2 / 3));
   *   // Add a tip in the z axis:
   *   tetrahedron.vertices.push(createVector(0, 0, radius));
   *
   *   // Create the four faces by connecting the sets of three points
   *   tetrahedron.faces.push([0, 1, 2]);
   *   tetrahedron.faces.push([0, 1, 3]);
   *   tetrahedron.faces.push([0, 2, 3]);
   *   tetrahedron.faces.push([1, 2, 3]);
   *   tetrahedron.makeEdgesFromFaces();
   * }
   * function draw() {
   *   background(200);
   *   strokeWeight(2);
   *   orbitControl();
   *   rotateY(millis() * 0.001);
   *   model(tetrahedron);
   * }
   * </code>
   * </div>
   */ makeEdgesFromFaces() {
        this._makeTriangleEdges();
    }
    /**
   * Converts each line segment into the vertices and vertex attributes needed
   * to turn the line into a polygon on screen. This will include:
   * - Two triangles line segment to create a rectangle
   * - Two triangles per endpoint to create a stroke cap rectangle. A fragment
   *   shader is responsible for displaying the appropriate cap style within
   *   that rectangle.
   * - Four triangles per join between adjacent line segments, creating a quad on
   *   either side of the join, perpendicular to the lines. A vertex shader will
   *   discard the quad in the "elbow" of the join, and a fragment shader will
   *   display the appropriate join style within the remaining quad.
   *
   * @private
   * @chainable
   */ _edgesToVertices() {
        this.lineVertices.clear();
        this.lineTangentsIn.clear();
        this.lineTangentsOut.clear();
        this.lineSides.clear();
        const potentialCaps = new Map();
        const connected = new Set();
        let lastValidDir;
        for(let i = 0; i < this.edges.length; i++){
            const prevEdge = this.edges[i - 1];
            const currEdge = this.edges[i];
            const begin = this.vertices[currEdge[0]];
            const end = this.vertices[currEdge[1]];
            const prevColor = this.vertexStrokeColors.length > 0 && prevEdge ? this.vertexStrokeColors.slice(prevEdge[1] * 4, (prevEdge[1] + 1) * 4) : [
                0,
                0,
                0,
                0
            ];
            const fromColor = this.vertexStrokeColors.length > 0 ? this.vertexStrokeColors.slice(currEdge[0] * 4, (currEdge[0] + 1) * 4) : [
                0,
                0,
                0,
                0
            ];
            const toColor = this.vertexStrokeColors.length > 0 ? this.vertexStrokeColors.slice(currEdge[1] * 4, (currEdge[1] + 1) * 4) : [
                0,
                0,
                0,
                0
            ];
            const dir = end.copy().sub(begin).normalize();
            const dirOK = dir.magSq() > 0;
            if (dirOK) {
                this._addSegment(begin, end, fromColor, toColor, dir);
            }
            if (!this.renderer?._simpleLines) {
                if (i > 0 && prevEdge[1] === currEdge[0]) {
                    if (!connected.has(currEdge[0])) {
                        connected.add(currEdge[0]);
                        potentialCaps.delete(currEdge[0]);
                        // Add a join if this segment shares a vertex with the previous. Skip
                        // actually adding join vertices if either the previous segment or this
                        // one has a length of 0.
                        //
                        // Don't add a join if the tangents point in the same direction, which
                        // would mean the edges line up exactly, and there is no need for a join.
                        if (lastValidDir && dirOK && dir.dot(lastValidDir) < 1 - 1e-8) {
                            this._addJoin(begin, lastValidDir, dir, fromColor);
                        }
                    }
                } else {
                    // Start a new line
                    if (dirOK && !connected.has(currEdge[0])) {
                        const existingCap = potentialCaps.get(currEdge[0]);
                        if (existingCap) {
                            this._addJoin(begin, existingCap.dir, dir, fromColor);
                            potentialCaps.delete(currEdge[0]);
                            connected.add(currEdge[0]);
                        } else {
                            potentialCaps.set(currEdge[0], {
                                point: begin,
                                dir: dir.copy().mult(-1),
                                color: fromColor
                            });
                        }
                    }
                    if (lastValidDir && !connected.has(prevEdge[1])) {
                        const existingCap = potentialCaps.get(prevEdge[1]);
                        if (existingCap) {
                            this._addJoin(this.vertices[prevEdge[1]], lastValidDir, existingCap.dir.copy().mult(-1), prevColor);
                            potentialCaps.delete(prevEdge[1]);
                            connected.add(prevEdge[1]);
                        } else {
                            // Close off the last segment with a cap
                            potentialCaps.set(prevEdge[1], {
                                point: this.vertices[prevEdge[1]],
                                dir: lastValidDir,
                                color: prevColor
                            });
                        }
                        lastValidDir = undefined;
                    }
                }
                if (i === this.edges.length - 1 && !connected.has(currEdge[1])) {
                    const existingCap = potentialCaps.get(currEdge[1]);
                    if (existingCap) {
                        this._addJoin(end, dir, existingCap.dir.copy().mult(-1), toColor);
                        potentialCaps.delete(currEdge[1]);
                        connected.add(currEdge[1]);
                    } else {
                        potentialCaps.set(currEdge[1], {
                            point: end,
                            dir,
                            color: toColor
                        });
                    }
                }
                if (dirOK) {
                    lastValidDir = dir;
                }
            }
        }
        for (const { point, dir, color } of potentialCaps.values()){
            this._addCap(point, dir, color);
        }
        return this;
    }
    /**
   * Adds the vertices and vertex attributes for two triangles making a rectangle
   * for a straight line segment. A vertex shader is responsible for picking
   * proper coordinates on the screen given the centerline positions, the tangent,
   * and the side of the centerline each vertex belongs to. Sides follow the
   * following scheme:
   *
   *  -1            -1
   *   o-------------o
   *   |             |
   *   o-------------o
   *   1             1
   *
   * @private
   * @chainable
   */ _addSegment(begin, end, fromColor, toColor, dir) {
        const a = begin.array();
        const b = end.array();
        const dirArr = dir.array();
        this.lineSides.push(1, 1, -1, 1, -1, -1);
        for (const tangents of [
            this.lineTangentsIn,
            this.lineTangentsOut
        ]){
            for(let i = 0; i < 6; i++){
                tangents.push(...dirArr);
            }
        }
        this.lineVertices.push(...a, ...b, ...a, ...b, ...b, ...a);
        if (!this.renderer?._simpleLines) {
            this.lineVertexColors.push(...fromColor, ...toColor, ...fromColor, ...toColor, ...toColor, ...fromColor);
        }
        return this;
    }
    /**
   * Adds the vertices and vertex attributes for two triangles representing the
   * stroke cap of a line. A fragment shader is responsible for displaying the
   * appropriate cap style within the rectangle they make.
   *
   * The lineSides buffer will include the following values for the points on
   * the cap rectangle:
   *
   *           -1  -2
   * -----------o---o
   *            |   |
   * -----------o---o
   *            1   2
   * @private
   * @chainable
   */ _addCap(point, tangent, color) {
        const ptArray = point.array();
        const tanInArray = tangent.array();
        const tanOutArray = [
            0,
            0,
            0
        ];
        for(let i = 0; i < 6; i++){
            this.lineVertices.push(...ptArray);
            this.lineTangentsIn.push(...tanInArray);
            this.lineTangentsOut.push(...tanOutArray);
            this.lineVertexColors.push(...color);
        }
        this.lineSides.push(-1, 2, -2, 1, 2, -1);
        return this;
    }
    /**
   * Adds the vertices and vertex attributes for four triangles representing a
   * join between two adjacent line segments. This creates a quad on either side
   * of the shared vertex of the two line segments, with each quad perpendicular
   * to the lines. A vertex shader will discard all but the quad in the "elbow" of
   * the join, and a fragment shader will display the appropriate join style
   * within the remaining quad.
   *
   * The lineSides buffer will include the following values for the points on
   * the join rectangles:
   *
   *            -1     -2
   * -------------o----o
   *              |    |
   *       1 o----o----o -3
   *         |    | 0  |
   * --------o----o    |
   *        2|    3    |
   *         |         |
   *         |         |
   * @private
   * @chainable
   */ _addJoin(point, fromTangent, toTangent, color) {
        const ptArray = point.array();
        const tanInArray = fromTangent.array();
        const tanOutArray = toTangent.array();
        for(let i = 0; i < 12; i++){
            this.lineVertices.push(...ptArray);
            this.lineTangentsIn.push(...tanInArray);
            this.lineTangentsOut.push(...tanOutArray);
            this.lineVertexColors.push(...color);
        }
        this.lineSides.push(-1, -3, -2, -1, 0, -3);
        this.lineSides.push(3, 1, 2, 3, 0, 1);
        return this;
    }
    /**
   * Transforms the geometry's vertices to fit snugly within a 100×100×100 box
   * centered at the origin.
   *
   * Calling `myGeometry.normalize()` translates the geometry's vertices so that
   * they're centered at the origin `(0, 0, 0)`. Then it scales the vertices so
   * that they fill a 100×100×100 box. As a result, small geometries will grow
   * and large geometries will shrink.
   *
   * Note: `myGeometry.normalize()` only works when called in the
   * <a href="#/p5/setup">setup()</a> function.
   *
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a very small torus.
   *   myGeometry = buildGeometry(function() {;
   *     torus(1, 0.25);
   *   });
   *
   *   // Normalize the torus so its vertices fill
   *   // the range [-100, 100].
   *   myGeometry.normalize();
   *
   *   describe('A white torus rotates slowly against a dark gray background.');
   * }
   *
   * function draw() {
   *   background(50);
   *
   *   // Turn on the lights.
   *   lights();
   *
   *   // Rotate around the y-axis.
   *   rotateY(frameCount * 0.01);
   *
   *   // Style the torus.
   *   noStroke();
   *
   *   // Draw the torus.
   *   model(myGeometry);
   * }
   * </code>
   * </div>
   */ normalize() {
        if (this.vertices.length > 0) {
            // Find the corners of our bounding box
            const maxPosition = this.vertices[0].copy();
            const minPosition = this.vertices[0].copy();
            for(let i = 0; i < this.vertices.length; i++){
                maxPosition.x = Math.max(maxPosition.x, this.vertices[i].x);
                minPosition.x = Math.min(minPosition.x, this.vertices[i].x);
                maxPosition.y = Math.max(maxPosition.y, this.vertices[i].y);
                minPosition.y = Math.min(minPosition.y, this.vertices[i].y);
                maxPosition.z = Math.max(maxPosition.z, this.vertices[i].z);
                minPosition.z = Math.min(minPosition.z, this.vertices[i].z);
            }
            const center = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"].lerp(maxPosition, minPosition, 0.5);
            const dist = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"].sub(maxPosition, minPosition);
            const longestDist = Math.max(Math.max(dist.x, dist.y), dist.z);
            const scale = 200 / longestDist;
            for(let i = 0; i < this.vertices.length; i++){
                this.vertices[i].sub(center);
                this.vertices[i].mult(scale);
            }
        }
        return this;
    }
    /** Sets the shader's vertex property or attribute variables.
   *
   * A vertex property, or vertex attribute, is a variable belonging to a vertex in a shader. p5.js provides some
   * default properties, such as `aPosition`, `aNormal`, `aVertexColor`, etc. These are
   * set using <a href="#/p5/vertex">vertex()</a>, <a href="#/p5/normal">normal()</a>
   * and <a href="#/p5/fill">fill()</a> respectively. Custom properties can also
   * be defined within <a href="#/p5/beginShape">beginShape()</a> and
   * <a href="#/p5/endShape">endShape()</a>.
   *
   * The first parameter, `propertyName`, is a string with the property's name.
   * This is the same variable name which should be declared in the shader, as in
   * `in vec3 aProperty`, similar to .`setUniform()`.
   *
   * The second parameter, `data`, is the value assigned to the shader variable. This value
   * will be pushed directly onto the Geometry object. There should be the same number
   * of custom property values as vertices, this method should be invoked once for each
   * vertex.
   *
   * The `data` can be a Number or an array of numbers. Tn the shader program the type
   * can be declared according to the WebGL specification. Common types include `float`,
   * `vec2`, `vec3`, `vec4` or matrices.
   *
   * See also the global <a href="#/p5/vertexProperty">vertexProperty()</a> function.
   *
   * @example
   * <div>
   * <code>
   * let geo;
   *
   * function cartesianToSpherical(x, y, z) {
   *   let r = sqrt(pow(x, 2) + pow(y, 2) + pow(z, 2));
   *   let theta = acos(z / r);
   *   let phi = atan2(y, x);
   *   return { theta, phi };
   * }
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Modify the material shader to display roughness.
   *   const myShader = baseMaterialShader().modify({
   *     vertexDeclarations:`in float aRoughness;
   *                         out float vRoughness;`,
   *     fragmentDeclarations: 'in float vRoughness;',
   *     'void afterVertex': `() {
   *         vRoughness = aRoughness;
   *     }`,
   *     'vec4 combineColors': `(ColorComponents components) {
   *             vec4 color = vec4(0.);
   *             color.rgb += components.diffuse * components.baseColor * (1.0-vRoughness);
   *             color.rgb += components.ambient * components.ambientColor;
   *             color.rgb += components.specular * components.specularColor * (1.0-vRoughness);
   *             color.a = components.opacity;
   *             return color;
   *     }`
   *   });
   *
   *   // Create the Geometry object.
   *   geo = buildGeometry(function() {
   *     fill('hotpink');
   *     sphere(45, 50, 50);
   *   });
   *
   *   // Set the roughness value for every vertex.
   *   for (let v of geo.vertices){
   *
   *     // convert coordinates to spherical coordinates
   *     let spherical = cartesianToSpherical(v.x, v.y, v.z);
   *
   *     // Set the custom roughness vertex property.
   *     let roughness = noise(spherical.theta*5, spherical.phi*5);
   *     geo.vertexProperty('aRoughness', roughness);
   *   }
   *
   *   // Use the custom shader.
   *   shader(myShader);
   *
   *   describe('A rough pink sphere rotating on a blue background.');
   * }
   *
   * function draw() {
   *   // Set some styles and lighting
   *   background('lightblue');
   *   noStroke();
   *
   *   specularMaterial(255,125,100);
   *   shininess(2);
   *
   *   directionalLight('white', -1, 1, -1);
   *   ambientLight(320);
   *
   *   rotateY(millis()*0.001);
   *
   *   // Draw the geometry
   *   model(geo);
   * }
   * </code>
   * </div>
   *
   * @param {String} propertyName the name of the vertex property.
   * @param {Number|Number[]} data the data tied to the vertex property.
   * @param {Number} [size] optional size of each unit of data.
   */ vertexProperty(propertyName, data, size) {
        let prop;
        if (!this.userVertexProperties[propertyName]) {
            prop = this.userVertexProperties[propertyName] = this._userVertexPropertyHelper(propertyName, data, size);
        }
        prop = this.userVertexProperties[propertyName];
        if (size) {
            prop.pushDirect(data);
        } else {
            prop.setCurrentData(data);
            prop.pushCurrentData();
        }
    }
    _userVertexPropertyHelper(propertyName, data, size) {
        const geometryInstance = this;
        const prop = this.userVertexProperties[propertyName] = {
            name: propertyName,
            dataSize: size ? size : data.length ? data.length : 1,
            geometry: geometryInstance,
            // Getters
            getName () {
                return this.name;
            },
            getCurrentData () {
                if (this.currentData === undefined) {
                    this.currentData = new Array(this.getDataSize()).fill(0);
                }
                return this.currentData;
            },
            getDataSize () {
                return this.dataSize;
            },
            getSrcName () {
                const src = this.name.concat('Src');
                return src;
            },
            getDstName () {
                const dst = this.name.concat('Buffer');
                return dst;
            },
            getSrcArray () {
                const srcName = this.getSrcName();
                return this.geometry[srcName];
            },
            //Setters
            setCurrentData (data) {
                data.length ? data.length : 1;
                // if (size != this.getDataSize()){
                //   p5._friendlyError(`Custom vertex property '${this.name}' has been set with various data sizes. You can change it's name, or if it was an accident, set '${this.name}' to have the same number of inputs each time!`, 'vertexProperty()');
                // }
                this.currentData = data;
            },
            // Utilities
            pushCurrentData () {
                const data = this.getCurrentData();
                this.pushDirect(data);
            },
            pushDirect (data) {
                if (data.length) {
                    this.getSrcArray().push(...data);
                } else {
                    this.getSrcArray().push(data);
                }
            },
            resetSrcArray () {
                this.geometry[this.getSrcName()] = [];
            },
            delete () {
                const srcName = this.getSrcName();
                delete this.geometry[srcName];
                delete this;
            }
        };
        this[prop.getSrcName()] = [];
        return this.userVertexProperties[propertyName];
    }
}
/**
 * Keeps track of how many custom geometry objects have been made so that each
 * can be assigned a unique ID.
 */ Geometry.nextId = 0;
function geometry(p51, fn1) {
    /**
   * A class to describe a 3D shape.
   *
   * Each `p5.Geometry` object represents a 3D shape as a set of connected
   * points called *vertices*. All 3D shapes are made by connecting vertices to
   * form triangles that are stitched together. Each triangular patch on the
   * geometry's surface is called a *face*. The geometry stores information
   * about its vertices and faces for use with effects such as lighting and
   * texture mapping.
   *
   * The first parameter, `detailX`, is optional. If a number is passed, as in
   * `new p5.Geometry(24)`, it sets the number of triangle subdivisions to use
   * along the geometry's x-axis. By default, `detailX` is 1.
   *
   * The second parameter, `detailY`, is also optional. If a number is passed,
   * as in `new p5.Geometry(24, 16)`, it sets the number of triangle
   * subdivisions to use along the geometry's y-axis. By default, `detailX` is
   * 1.
   *
   * The third parameter, `callback`, is also optional. If a function is passed,
   * as in `new p5.Geometry(24, 16, createShape)`, it will be called once to add
   * vertices to the new 3D shape.
   *
   * @class p5.Geometry
   * @param  {Integer} [detailX] number of vertices along the x-axis.
   * @param  {Integer} [detailY] number of vertices along the y-axis.
   * @param {function} [callback] function to call once the geometry is created.
   *
   * @example
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Geometry object.
   *   myGeometry = new p5.Geometry();
   *
   *   // Create p5.Vector objects to position the vertices.
   *   let v0 = createVector(-40, 0, 0);
   *   let v1 = createVector(0, -40, 0);
   *   let v2 = createVector(40, 0, 0);
   *
   *   // Add the vertices to the p5.Geometry object's vertices array.
   *   myGeometry.vertices.push(v0, v1, v2);
   *
   *   describe('A white triangle drawn on a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Draw the p5.Geometry object.
   *   model(myGeometry);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Geometry object using a callback function.
   *   myGeometry = new p5.Geometry(1, 1, createShape);
   *
   *   describe('A white triangle drawn on a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Draw the p5.Geometry object.
   *   model(myGeometry);
   * }
   *
   * function createShape() {
   *   // Create p5.Vector objects to position the vertices.
   *   let v0 = createVector(-40, 0, 0);
   *   let v1 = createVector(0, -40, 0);
   *   let v2 = createVector(40, 0, 0);
   *
   *   // "this" refers to the p5.Geometry object being created.
   *
   *   // Add the vertices to the p5.Geometry object's vertices array.
   *   this.vertices.push(v0, v1, v2);
   *
   *   // Add an array to list which vertices belong to the face.
   *   // Vertices are listed in clockwise "winding" order from
   *   // left to top to right.
   *   this.faces.push([0, 1, 2]);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Geometry object using a callback function.
   *   myGeometry = new p5.Geometry(1, 1, createShape);
   *
   *   describe('A white triangle drawn on a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Draw the p5.Geometry object.
   *   model(myGeometry);
   * }
   *
   * function createShape() {
   *   // Create p5.Vector objects to position the vertices.
   *   let v0 = createVector(-40, 0, 0);
   *   let v1 = createVector(0, -40, 0);
   *   let v2 = createVector(40, 0, 0);
   *
   *   // "this" refers to the p5.Geometry object being created.
   *
   *   // Add the vertices to the p5.Geometry object's vertices array.
   *   this.vertices.push(v0, v1, v2);
   *
   *   // Add an array to list which vertices belong to the face.
   *   // Vertices are listed in clockwise "winding" order from
   *   // left to top to right.
   *   this.faces.push([0, 1, 2]);
   *
   *   // Compute the surface normals to help with lighting.
   *   this.computeNormals();
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * // Adapted from Paul Wheeler's wonderful p5.Geometry tutorial.
   * // https://www.paulwheeler.us/articles/custom-3d-geometry-in-p5js/
   * // CC-BY-SA 4.0
   *
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create the p5.Geometry object.
   *   // Set detailX to 48 and detailY to 2.
   *   // >>> try changing them.
   *   myGeometry = new p5.Geometry(48, 2, createShape);
   * }
   *
   * function draw() {
   *   background(50);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Turn on the lights.
   *   lights();
   *
   *   // Style the p5.Geometry object.
   *   strokeWeight(0.2);
   *
   *   // Draw the p5.Geometry object.
   *   model(myGeometry);
   * }
   *
   * function createShape() {
   *   // "this" refers to the p5.Geometry object being created.
   *
   *   // Define the Möbius strip with a few parameters.
   *   let spread = 0.1;
   *   let radius = 30;
   *   let stripWidth = 15;
   *   let xInterval = 4 * PI / this.detailX;
   *   let yOffset = -stripWidth / 2;
   *   let yInterval = stripWidth / this.detailY;
   *
   *   for (let j = 0; j <= this.detailY; j += 1) {
   *     // Calculate the "vertical" point along the strip.
   *     let v = yOffset + yInterval * j;
   *
   *     for (let i = 0; i <= this.detailX; i += 1) {
   *       // Calculate the angle of rotation around the strip.
   *       let u = i * xInterval;
   *
   *       // Calculate the coordinates of the vertex.
   *       let x = (radius + v * cos(u / 2)) * cos(u) - sin(u / 2) * 2 * spread;
   *       let y = (radius + v * cos(u / 2)) * sin(u);
   *       if (u < TWO_PI) {
   *         y += sin(u) * spread;
   *       } else {
   *         y -= sin(u) * spread;
   *       }
   *       let z = v * sin(u / 2) + sin(u / 4) * 4 * spread;
   *
   *       // Create a p5.Vector object to position the vertex.
   *       let vert = createVector(x, y, z);
   *
   *       // Add the vertex to the p5.Geometry object's vertices array.
   *       this.vertices.push(vert);
   *     }
   *   }
   *
   *   // Compute the faces array.
   *   this.computeFaces();
   *
   *   // Compute the surface normals to help with lighting.
   *   this.computeNormals();
   * }
   * </code>
   * </div>
   */ p51.Geometry = Geometry;
/**
   * An array with the geometry's vertices.
   *
   * The geometry's vertices are stored as
   * <a href="#/p5.Vector">p5.Vector</a> objects in the `myGeometry.vertices`
   * array. The geometry's first vertex is the
   * <a href="#/p5.Vector">p5.Vector</a> object at `myGeometry.vertices[0]`,
   * its second vertex is `myGeometry.vertices[1]`, its third vertex is
   * `myGeometry.vertices[2]`, and so on.
   *
   * @property vertices
   * @for p5.Geometry
   * @name vertices
   *
   * @example
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Geometry object.
   *   myGeometry = new p5.Geometry();
   *
   *   // Create p5.Vector objects to position the vertices.
   *   let v0 = createVector(-40, 0, 0);
   *   let v1 = createVector(0, -40, 0);
   *   let v2 = createVector(40, 0, 0);
   *
   *   // Add the vertices to the p5.Geometry object's vertices array.
   *   myGeometry.vertices.push(v0, v1, v2);
   *
   *   describe('A white triangle drawn on a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Draw the p5.Geometry object.
   *   model(myGeometry);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Geometry object.
   *   myGeometry = buildGeometry(function() {
   *     torus(30, 15, 10, 8);
   *   });
   *
   *   describe('A white torus rotates slowly against a dark gray background. Red spheres mark its vertices.');
   * }
   *
   * function draw() {
   *   background(50);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Turn on the lights.
   *   lights();
   *
   *   // Rotate the coordinate system.
   *   rotateY(frameCount * 0.01);
   *
   *   // Style the p5.Geometry object.
   *   fill(255);
   *   stroke(0);
   *
   *   // Display the p5.Geometry object.
   *   model(myGeometry);
   *
   *   // Style the vertices.
   *   fill(255, 0, 0);
   *   noStroke();
   *
   *   // Iterate over the vertices array.
   *   for (let v of myGeometry.vertices) {
   *     // Draw a sphere to mark the vertex.
   *     push();
   *     translate(v);
   *     sphere(2.5);
   *     pop();
   *   }
   * }
   * </code>
   * </div>
   */ /**
   * An array with the vectors that are normal to the geometry's vertices.
   *
   * A face's orientation is defined by its *normal vector* which points out
   * of the face and is normal (perpendicular) to the surface. Calling
   * `myGeometry.computeNormals()` first calculates each face's normal
   * vector. Then it calculates the normal vector for each vertex by
   * averaging the normal vectors of the faces surrounding the vertex. The
   * vertex normals are stored as <a href="#/p5.Vector">p5.Vector</a>
   * objects in the `myGeometry.vertexNormals` array.
   *
   * @property vertexNormals
   * @name vertexNormals
   * @for p5.Geometry
   *
   * @example
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Geometry object.
   *   myGeometry = buildGeometry(function() {
   *     torus(30, 15, 10, 8);
   *   });
   *
   *   // Compute the vertex normals.
   *   myGeometry.computeNormals();
   *
   *   describe(
   *     'A white torus rotates against a dark gray background. Red lines extend outward from its vertices.'
   *   );
   * }
   *
   * function draw() {
   *   background(50);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Turn on the lights.
   *   lights();
   *
   *   // Rotate the coordinate system.
   *   rotateY(frameCount * 0.01);
   *
   *   // Style the p5.Geometry object.
   *   stroke(0);
   *
   *   // Display the p5.Geometry object.
   *   model(myGeometry);
   *
   *   // Style the normal vectors.
   *   stroke(255, 0, 0);
   *
   *   // Iterate over the vertices and vertexNormals arrays.
   *   for (let i = 0; i < myGeometry.vertices.length; i += 1) {
   *
   *     // Get the vertex p5.Vector object.
   *     let v = myGeometry.vertices[i];
   *
   *     // Get the vertex normal p5.Vector object.
   *     let n = myGeometry.vertexNormals[i];
   *
   *     // Calculate a point along the vertex normal.
   *     let p = p5.Vector.mult(n, 8);
   *
   *     // Draw the vertex normal as a red line.
   *     push();
   *     translate(v);
   *     line(0, 0, 0, p.x, p.y, p.z);
   *     pop();
   *   }
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Geometry object.
   *   myGeometry = new p5.Geometry();
   *
   *   // Create p5.Vector objects to position the vertices.
   *   let v0 = createVector(-40, 0, 0);
   *   let v1 = createVector(0, -40, 0);
   *   let v2 = createVector(0, 40, 0);
   *   let v3 = createVector(40, 0, 0);
   *
   *   // Add the vertices to the p5.Geometry object's vertices array.
   *   myGeometry.vertices.push(v0, v1, v2, v3);
   *
   *   // Compute the faces array.
   *   myGeometry.computeFaces();
   *
   *   // Compute the surface normals.
   *   myGeometry.computeNormals();
   *
   *   describe('A red square drawn on a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Add a white point light.
   *   pointLight(255, 255, 255, 0, 0, 10);
   *
   *   // Style the p5.Geometry object.
   *   noStroke();
   *   fill(255, 0, 0);
   *
   *   // Display the p5.Geometry object.
   *   model(myGeometry);
   * }
   * </code>
   * </div>
   */ /**
   * An array that lists which of the geometry's vertices form each of its
   * faces.
   *
   * All 3D shapes are made by connecting sets of points called *vertices*. A
   * geometry's surface is formed by connecting vertices to form triangles
   * that are stitched together. Each triangular patch on the geometry's
   * surface is called a *face*.
   *
   * The geometry's vertices are stored as
   * <a href="#/p5.Vector">p5.Vector</a> objects in the
   * <a href="#/p5.Geometry/vertices">myGeometry.vertices</a> array. The
   * geometry's first vertex is the <a href="#/p5.Vector">p5.Vector</a>
   * object at `myGeometry.vertices[0]`, its second vertex is
   * `myGeometry.vertices[1]`, its third vertex is `myGeometry.vertices[2]`,
   * and so on.
   *
   * For example, a geometry made from a rectangle has two faces because a
   * rectangle is made by joining two triangles. `myGeometry.faces` for a
   * rectangle would be the two-dimensional array `[[0, 1, 2], [2, 1, 3]]`.
   * The first face, `myGeometry.faces[0]`, is the array `[0, 1, 2]` because
   * it's formed by connecting `myGeometry.vertices[0]`,
   * `myGeometry.vertices[1]`,and `myGeometry.vertices[2]`. The second face,
   * `myGeometry.faces[1]`, is the array `[2, 1, 3]` because it's formed by
   * connecting `myGeometry.vertices[2]`, `myGeometry.vertices[1]`,and
   * `myGeometry.vertices[3]`.
   *
   * @property faces
   * @name faces
   * @for p5.Geometry
   *
   * @example
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Geometry object.
   *   myGeometry = buildGeometry(function() {
   *     sphere();
   *   });
   *
   *   describe("A sphere drawn on a gray background. The sphere's surface is a grayscale patchwork of triangles.");
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Turn on the lights.
   *   lights();
   *
   *   // Style the p5.Geometry object.
   *   noStroke();
   *
   *   // Set a random seed.
   *   randomSeed(1234);
   *
   *   // Iterate over the faces array.
   *   for (let face of myGeometry.faces) {
   *
   *     // Style the face.
   *     let g = random(0, 255);
   *     fill(g);
   *
   *     // Draw the face.
   *     beginShape();
   *     // Iterate over the vertices that form the face.
   *     for (let f of face) {
   *       // Get the vertex's p5.Vector object.
   *       let v = myGeometry.vertices[f];
   *       vertex(v.x, v.y, v.z);
   *     }
   *     endShape();
   *
   *   }
   * }
   * </code>
   * </div>
   */ /**
   * An array that lists the texture coordinates for each of the geometry's
   * vertices.
   *
   * In order for <a href="#/p5/texture">texture()</a> to work, the geometry
   * needs a way to map the points on its surface to the pixels in a
   * rectangular image that's used as a texture. The geometry's vertex at
   * coordinates `(x, y, z)` maps to the texture image's pixel at coordinates
   * `(u, v)`.
   *
   * The `myGeometry.uvs` array stores the `(u, v)` coordinates for each
   * vertex in the order it was added to the geometry. For example, the
   * first vertex, `myGeometry.vertices[0]`, has its `(u, v)` coordinates
   * stored at `myGeometry.uvs[0]` and `myGeometry.uvs[1]`.
   *
   * @property uvs
   * @name uvs
   * @for p5.Geometry
   *
   * @example
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   img = await loadImage('assets/laDefense.jpg');
   *   createCanvas(100, 100, WEBGL);
   *
   *   background(200);
   *
   *   // Create p5.Geometry objects.
   *   let geom1 = buildGeometry(createShape);
   *   let geom2 = buildGeometry(createShape);
   *
   *   // Left (original).
   *   push();
   *   translate(-25, 0, 0);
   *   texture(img);
   *   noStroke();
   *   model(geom1);
   *   pop();
   *
   *   // Set geom2's texture coordinates.
   *   geom2.uvs = [0.25, 0.25, 0.75, 0.25, 0.25, 0.75, 0.75, 0.75];
   *
   *   // Right (zoomed in).
   *   push();
   *   translate(25, 0, 0);
   *   texture(img);
   *   noStroke();
   *   model(geom2);
   *   pop();
   *
   *   describe(
   *     'Two photos of a ceiling on a gray background. The photo on the right zooms in to the center of the photo.'
   *   );
   * }
   *
   * function createShape() {
   *   plane(40);
   * }
   * </code>
   * </div>
   */ }
if (typeof p5 !== 'undefined') {
    geometry(p5, p5.prototype);
}
;
}}),
"[project]/node_modules/p5/dist/webgl/GeometryBuilder.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>GeometryBuilder)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$C$2d$g_eAdC$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/constants-C-g_eAdC.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Matrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Matrix.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.Geometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$Matrices$2f$Matrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/Matrices/Matrix.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Vector.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$Matrices$2f$MatrixInterface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/Matrices/MatrixInterface.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$DataArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.DataArray.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
/**
 * @private
 * A class responsible for converting successive WebGL draw calls into a single
 * `p5.Geometry` that can be reused and drawn with `model()`.
 */ class GeometryBuilder {
    constructor(renderer){
        this.renderer = renderer;
        renderer._pInst.push();
        this.identityMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$Matrices$2f$Matrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"](4);
        renderer.states.setValue('uModelMatrix', new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$Matrices$2f$Matrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"](4));
        this.geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Geometry"](undefined, undefined, undefined, this.renderer);
        this.geometry.gid = `_p5_GeometryBuilder_${GeometryBuilder.nextGeometryId}`;
        GeometryBuilder.nextGeometryId++;
        this.hasTransform = false;
    }
    /**
   * @private
   * Applies the current transformation matrix to each vertex.
   */ transformVertices(vertices) {
        if (!this.hasTransform) return vertices;
        return vertices.map((v)=>this.renderer.states.uModelMatrix.multiplyPoint(v));
    }
    /**
   * @private
   * Applies the current normal matrix to each normal.
   */ transformNormals(normals) {
        if (!this.hasTransform) return normals;
        return normals.map((v)=>this.renderer.scratchMat3.multiplyVec(v) // this is a vec3
        );
    }
    /**
   * @private
   * Adds a p5.Geometry to the builder's combined geometry, flattening
   * transformations.
   */ addGeometry(input) {
        this.hasTransform = !this.renderer.states.uModelMatrix.mat4.every((v, i)=>v === this.identityMatrix.mat4[i]);
        if (this.hasTransform) {
            this.renderer.scratchMat3.inverseTranspose4x4(this.renderer.states.uModelMatrix);
        }
        let startIdx = this.geometry.vertices.length;
        this.geometry.vertices.push(...this.transformVertices(input.vertices));
        this.geometry.vertexNormals.push(...this.transformNormals(input.vertexNormals));
        this.geometry.uvs.push(...input.uvs);
        const inputUserVertexProps = input.userVertexProperties;
        const builtUserVertexProps = this.geometry.userVertexProperties;
        const numPreviousVertices = this.geometry.vertices.length - input.vertices.length;
        for(const propName in builtUserVertexProps){
            if (propName in inputUserVertexProps) {
                continue;
            }
            const prop = builtUserVertexProps[propName];
            const size = prop.getDataSize();
            const numMissingValues = size * input.vertices.length;
            const missingValues = Array(numMissingValues).fill(0);
            prop.pushDirect(missingValues);
        }
        for(const propName in inputUserVertexProps){
            const prop = inputUserVertexProps[propName];
            const data = prop.getSrcArray();
            const size = prop.getDataSize();
            if (numPreviousVertices > 0 && !(propName in builtUserVertexProps)) {
                const numMissingValues = size * numPreviousVertices;
                const missingValues = Array(numMissingValues).fill(0);
                this.geometry.vertexProperty(propName, missingValues, size);
            }
            this.geometry.vertexProperty(propName, data, size);
        }
        if (this.renderer.states.fillColor) {
            this.geometry.faces.push(...input.faces.map((f)=>f.map((idx)=>idx + startIdx)));
        }
        if (this.renderer.states.strokeColor) {
            this.geometry.edges.push(...input.edges.map((edge)=>edge.map((idx)=>idx + startIdx)));
        }
        const vertexColors = [
            ...input.vertexColors
        ];
        while(vertexColors.length < input.vertices.length * 4){
            vertexColors.push(...this.renderer.states.curFillColor);
        }
        this.geometry.vertexColors.push(...vertexColors);
    }
    /**
   * Adds geometry from the renderer's immediate mode into the builder's
   * combined geometry.
   */ addImmediate(geometry, shapeMode) {
        const faces = [];
        if (this.renderer.states.fillColor) {
            if (shapeMode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$C$2d$g_eAdC$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["r"] || shapeMode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$C$2d$g_eAdC$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["s"]) {
                for(let i = 2; i < geometry.vertices.length; i++){
                    if (i % 2 === 0) {
                        faces.push([
                            i,
                            i - 1,
                            i - 2
                        ]);
                    } else {
                        faces.push([
                            i,
                            i - 2,
                            i - 1
                        ]);
                    }
                }
            } else if (shapeMode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$C$2d$g_eAdC$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["q"]) {
                for(let i = 2; i < geometry.vertices.length; i++){
                    faces.push([
                        0,
                        i - 1,
                        i
                    ]);
                }
            } else {
                for(let i = 0; i < geometry.vertices.length; i += 3){
                    faces.push([
                        i,
                        i + 1,
                        i + 2
                    ]);
                }
            }
        }
        this.addGeometry(Object.assign({}, geometry, {
            faces
        }));
    }
    /**
   * Adds geometry from the renderer's retained mode into the builder's
   * combined geometry.
   */ addRetained(geometry) {
        this.addGeometry(geometry);
    }
    /**
   * Cleans up the state of the renderer and returns the combined geometry that
   * was built.
   * @returns p5.Geometry The flattened, combined geometry
   */ finish() {
        this.renderer._pInst.pop();
        return this.geometry;
    }
}
/**
 * Keeps track of how many custom geometry objects have been made so that each
 * can be assigned a unique ID.
 */ GeometryBuilder.nextGeometryId = 0;
;
}}),
"[project]/node_modules/p5/dist/webgl/p5.Quat.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "Quat": (()=>Quat),
    "default": (()=>quat)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Vector.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$C$2d$g_eAdC$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/constants-C-g_eAdC.js [app-client] (ecmascript)");
;
;
/**
 * @module Math
 * @submodule Quaternion
 */ class Quat {
    constructor(w, x, y, z){
        this.w = w;
        this.vec = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"](x, y, z);
    }
    /**
     * Returns a Quaternion for the
     * axis angle representation of the rotation
     *
     * @method fromAxisAngle
     * @param {Number} [angle] Angle with which the points needs to be rotated
     * @param {Number} [x] x component of the axis vector
     * @param {Number} [y] y component of the axis vector
     * @param {Number} [z] z component of the axis vector
     * @chainable
    */ static fromAxisAngle(angle, x, y, z) {
        const w = Math.cos(angle / 2);
        const vec = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"](x, y, z).normalize().mult(Math.sin(angle / 2));
        return new Quat(w, vec.x, vec.y, vec.z);
    }
    conjugate() {
        return new Quat(this.w, -this.vec.x, -this.vec.y, -this.vec.z);
    }
    /**
     * Multiplies a quaternion with other quaternion.
     * @method mult
     * @param  {p5.Quat} [quat] quaternion to multiply with the quaternion calling the method.
     * @chainable
     */ multiply(quat) {
        /* eslint-disable max-len */ return new Quat(this.w * quat.w - this.vec.x * quat.vec.x - this.vec.y * quat.vec.y - this.vec.z - quat.vec.z, this.w * quat.vec.x + this.vec.x * quat.w + this.vec.y * quat.vec.z - this.vec.z * quat.vec.y, this.w * quat.vec.y - this.vec.x * quat.vec.z + this.vec.y * quat.w + this.vec.z * quat.vec.x, this.w * quat.vec.z + this.vec.x * quat.vec.y - this.vec.y * quat.vec.x + this.vec.z * quat.w);
    /* eslint-enable max-len */ }
    /**
   * This is similar to quaternion multiplication
   * but when multipying vector with quaternion
   * the multiplication can be simplified to the below formula.
   * This was taken from the below stackexchange link
   * https://gamedev.stackexchange.com/questions/28395/rotating-vector3-by-a-quaternion/50545#50545
   * @param {p5.Vector} [p] vector to rotate on the axis quaternion
   */ rotateVector(p) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"].mult(p, this.w * this.w - this.vec.dot(this.vec)).add(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"].mult(this.vec, 2 * p.dot(this.vec))).add(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"].mult(this.vec, 2 * this.w).cross(p)).clampToZero();
    }
    /**
     * Rotates the Quaternion by the quaternion passed
     * which contains the axis of roation and angle of rotation
     *
     * @method rotateBy
     * @param {p5.Quat} [axesQuat] axis quaternion which contains
     *  the axis of rotation and angle of rotation
     * @chainable
     */ rotateBy(axesQuat) {
        return axesQuat.multiply(this).multiply(axesQuat.conjugate()).vec.clampToZero();
    }
}
function quat(p51, fn) {
    /**
   * A class to describe a Quaternion
   * for vector rotations in the p5js webgl renderer.
   * Please refer the following link for details on the implementation
   * https://danceswithcode.net/engineeringnotes/quaternions/quaternions.html
   * @class p5.Quat
   * @constructor
   * @param {Number} [w] Scalar part of the quaternion
   * @param {Number} [x] x component of imaginary part of quaternion
   * @param {Number} [y] y component of imaginary part of quaternion
   * @param {Number} [z] z component of imaginary part of quaternion
   * @private
   */ p51.Quat = Quat;
}
if (typeof p5 !== 'undefined') {
    quat(p5, p5.prototype);
}
;
}}),
"[project]/node_modules/p5/dist/webgl/p5.RenderBuffer.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "RenderBuffer": (()=>RenderBuffer),
    "default": (()=>renderBuffer)
});
class RenderBuffer {
    constructor(size, src, dst, attr, renderer, map){
        this.size = size; // the number of FLOATs in each vertex
        this.src = src; // the name of the model's source array
        this.dst = dst; // the name of the geometry's buffer
        this.attr = attr; // the name of the vertex attribute
        this._renderer = renderer;
        this.map = map; // optional, a transformation function to apply to src
    }
    /**
   * Enables and binds the buffers used by shader when the appropriate data exists in geometry.
   * Must always be done prior to drawing geometry in WebGL.
   * @param {p5.Geometry} geometry Geometry that is going to be drawn
   * @param {p5.Shader} shader Active shader
   * @private
   */ _prepareBuffer(geometry, shader) {
        const attributes = shader.attributes;
        const gl = this._renderer.GL;
        const glBuffers = this._renderer._getOrMakeCachedBuffers(geometry);
        // loop through each of the buffer definitions
        const attr = attributes[this.attr];
        if (!attr) {
            return;
        }
        // check if the geometry has the appropriate source array
        let buffer = glBuffers[this.dst];
        const src = geometry[this.src];
        if (src && src.length > 0) {
            // check if we need to create the GL buffer
            const createBuffer = !buffer;
            if (createBuffer) {
                // create and remember the buffer
                glBuffers[this.dst] = buffer = gl.createBuffer();
            }
            // bind the buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            // check if we need to fill the buffer with data
            if (createBuffer || geometry.dirtyFlags[this.src] !== false) {
                const map = this.map;
                // get the values from the geometry, possibly transformed
                const values = map ? map(src) : src;
                // fill the buffer with the values
                this._renderer._bindBuffer(buffer, gl.ARRAY_BUFFER, values);
                // mark the geometry's source array as clean
                geometry.dirtyFlags[this.src] = false;
            }
            // enable the attribute
            shader.enableAttrib(attr, this.size);
        } else {
            const loc = attr.location;
            if (loc === -1 || !this._renderer.registerEnabled.has(loc)) {
                return;
            }
            // Disable register corresponding to unused attribute
            gl.disableVertexAttribArray(loc);
            // Record register availability
            this._renderer.registerEnabled.delete(loc);
        }
    }
}
function renderBuffer(p51, fn) {
    p51.RenderBuffer = RenderBuffer;
}
if (typeof p5 !== "undefined") {
    renderBuffer(p5, p5.prototype);
}
;
}}),
"[project]/node_modules/p5/dist/webgl/ShapeBuilder.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "ShapeBuilder": (()=>ShapeBuilder)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$C$2d$g_eAdC$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/constants-C-g_eAdC.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.Geometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libtess$2f$libtess$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libtess/libtess.min.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Vector.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$RenderBuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.RenderBuffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$DataArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.DataArray.js [app-client] (ecmascript)");
;
;
;
;
;
;
const INITIAL_BUFFER_STRIDES = {
    vertices: 1,
    vertexNormals: 1,
    vertexColors: 4,
    vertexStrokeColors: 4,
    uvs: 2
};
// The total number of properties per vertex, before additional
// user attributes are added.
const INITIAL_VERTEX_SIZE = Object.values(INITIAL_BUFFER_STRIDES).reduce((acc, next)=>acc + next);
class ShapeBuilder {
    constructor(renderer){
        this.renderer = renderer;
        this.shapeMode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$C$2d$g_eAdC$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["m"];
        this.geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Geometry"](undefined, undefined, undefined, this.renderer);
        this.geometry.gid = '__IMMEDIATE_MODE_GEOMETRY__';
        this.contourIndices = [];
        this._useUserVertexProperties = undefined;
        this._bezierVertex = [];
        this._quadraticVertex = [];
        this._curveVertex = [];
        // Used to distinguish between user calls to vertex() and internal calls
        this.isProcessingVertices = false;
        // Used for converting shape outlines into triangles for rendering
        this._tessy = this._initTessy();
        this.tessyVertexSize = INITIAL_VERTEX_SIZE;
        this.bufferStrides = {
            ...INITIAL_BUFFER_STRIDES
        };
    }
    constructFromContours(shape, contours) {
        if (this._useUserVertexProperties) {
            this._resetUserVertexProperties();
        }
        this.geometry.reset();
        this.contourIndices = [];
        // TODO: handle just some contours having non-PATH mode
        this.shapeMode = shape.contours[0].kind;
        const shouldProcessEdges = !!this.renderer.states.strokeColor;
        const userVertexPropertyHelpers = {};
        if (shape.userVertexProperties) {
            this._useUserVertexProperties = true;
            for(const key in shape.userVertexProperties){
                const name = shape.vertexPropertyName(key);
                const prop = this.geometry._userVertexPropertyHelper(name, [], shape.userVertexProperties[key]);
                userVertexPropertyHelpers[key] = prop;
                this.tessyVertexSize += prop.getDataSize();
                this.bufferStrides[prop.getSrcName()] = prop.getDataSize();
                this.renderer.buffers.user.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$RenderBuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RenderBuffer"](prop.getDataSize(), prop.getSrcName(), prop.getDstName(), name, this.renderer));
            }
        } else {
            this._useUserVertexProperties = false;
        }
        for (const contour of contours){
            this.contourIndices.push(this.geometry.vertices.length);
            for (const vertex of contour){
                // WebGL doesn't support QUADS or QUAD_STRIP, so we duplicate data to turn
                // QUADS into TRIANGLES and QUAD_STRIP into TRIANGLE_STRIP. (There is no extra
                // work to convert QUAD_STRIP here, since the only difference is in how edges
                // are rendered.)
                if (this.shapeMode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$C$2d$g_eAdC$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Q"]) {
                    // A finished quad turned into triangles should leave 6 vertices in the
                    // buffer:
                    // 0--3     0   3--5
                    // |  | --> | \  \ |
                    // 1--2     1--2   4
                    // When vertex index 3 is being added, add the necessary duplicates.
                    if (this.geometry.vertices.length % 6 === 3) {
                        for(const key in this.bufferStrides){
                            const stride = this.bufferStrides[key];
                            const buffer = this.geometry[key];
                            buffer.push(...buffer.slice(buffer.length - 3 * stride, buffer.length - 2 * stride), ...buffer.slice(buffer.length - stride, buffer.length));
                        }
                    }
                }
                this.geometry.vertices.push(vertex.position);
                this.geometry.vertexNormals.push(vertex.normal || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"](0, 0, 0));
                this.geometry.uvs.push(vertex.textureCoordinates.x, vertex.textureCoordinates.y);
                if (this.renderer.states.fillColor) {
                    this.geometry.vertexColors.push(...vertex.fill.array());
                } else {
                    this.geometry.vertexColors.push(0, 0, 0, 0);
                }
                if (this.renderer.states.strokeColor) {
                    this.geometry.vertexStrokeColors.push(...vertex.stroke.array());
                } else {
                    this.geometry.vertexStrokeColors.push(0, 0, 0, 0);
                }
                for(const key in userVertexPropertyHelpers){
                    const prop = userVertexPropertyHelpers[key];
                    if (key in vertex) {
                        prop.setCurrentData(vertex[key]);
                    }
                    prop.pushCurrentData();
                }
            }
        }
        if (shouldProcessEdges) {
            this.geometry.edges = this._calculateEdges(this.shapeMode, this.geometry.vertices);
        }
        if (shouldProcessEdges && !this.renderer.geometryBuilder) {
            this.geometry._edgesToVertices();
        }
        if (this.shapeMode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$C$2d$g_eAdC$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["m"]) {
            this.isProcessingVertices = true;
            this._tesselateShape();
            this.isProcessingVertices = false;
        } else if (this.shapeMode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$C$2d$g_eAdC$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["s"]) {
            // The only difference between these two modes is which edges are
            // displayed, so after we've updated the edges, we switch the mode
            // to one that native WebGL knows how to render.
            this.shapeMode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$C$2d$g_eAdC$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["r"];
        } else if (this.shapeMode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$C$2d$g_eAdC$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Q"]) {
            // We translate QUADS to TRIANGLES when vertices are being added,
            // since QUADS is just a p5 mode, whereas TRIANGLES is also a mode
            // that native WebGL knows how to render. Once we've processed edges,
            // everything should be set up for TRIANGLES mode.
            this.shapeMode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$C$2d$g_eAdC$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["p"];
        }
        if (this.renderer.states.textureMode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$C$2d$g_eAdC$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a1"] && this.renderer.states._tex !== null && this.renderer.states._tex.width > 0 && this.renderer.states._tex.height > 0) {
            this.geometry.uvs = this.geometry.uvs.map((val, i)=>{
                if (i % 2 === 0) {
                    return val / this.renderer.states._tex.width;
                } else {
                    return val / this.renderer.states._tex.height;
                }
            });
        }
    }
    _resetUserVertexProperties() {
        const properties = this.geometry.userVertexProperties;
        for(const propName in properties){
            const prop = properties[propName];
            delete this.bufferStrides[propName];
            prop.delete();
        }
        this._useUserVertexProperties = false;
        this.tessyVertexSize = INITIAL_VERTEX_SIZE;
        this.geometry.userVertexProperties = {};
    }
    /**
   * Called from _processVertices(). This function calculates the stroke vertices for custom shapes and
   * tesselates shapes when applicable.
   * @private
   * @returns  {Number[]} indices for custom shape vertices indicating edges.
   */ _calculateEdges(shapeMode, verts) {
        const res = [];
        let i = 0;
        const contourIndices = this.contourIndices.slice();
        let contourStart = -1;
        switch(shapeMode){
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$C$2d$g_eAdC$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["r"]:
                for(i = 0; i < verts.length - 2; i++){
                    res.push([
                        i,
                        i + 1
                    ]);
                    res.push([
                        i,
                        i + 2
                    ]);
                }
                res.push([
                    i,
                    i + 1
                ]);
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$C$2d$g_eAdC$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["q"]:
                for(i = 1; i < verts.length - 1; i++){
                    res.push([
                        0,
                        i
                    ]);
                    res.push([
                        i,
                        i + 1
                    ]);
                }
                res.push([
                    0,
                    verts.length - 1
                ]);
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$C$2d$g_eAdC$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["p"]:
                for(i = 0; i < verts.length - 2; i = i + 3){
                    res.push([
                        i,
                        i + 1
                    ]);
                    res.push([
                        i + 1,
                        i + 2
                    ]);
                    res.push([
                        i + 2,
                        i
                    ]);
                }
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$C$2d$g_eAdC$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["L"]:
                for(i = 0; i < verts.length - 1; i = i + 2){
                    res.push([
                        i,
                        i + 1
                    ]);
                }
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$C$2d$g_eAdC$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Q"]:
                // Quads have been broken up into two triangles by `vertex()`:
                // 0   3--5
                // | \  \ |
                // 1--2   4
                for(i = 0; i < verts.length - 5; i += 6){
                    res.push([
                        i,
                        i + 1
                    ]);
                    res.push([
                        i + 1,
                        i + 2
                    ]);
                    res.push([
                        i + 2,
                        i + 5
                    ]);
                    res.push([
                        i + 5,
                        i
                    ]);
                }
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$C$2d$g_eAdC$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["s"]:
                // 0---2---4
                // |   |   |
                // 1---3---5
                for(i = 0; i < verts.length - 2; i += 2){
                    res.push([
                        i,
                        i + 1
                    ]);
                    res.push([
                        i + 1,
                        i + 3
                    ]);
                    res.push([
                        i,
                        i + 2
                    ]);
                }
                res.push([
                    i,
                    i + 1
                ]);
                break;
            default:
                // TODO: handle contours in other modes too
                for(i = 0; i < verts.length; i++){
                    if (i === contourIndices[0]) {
                        contourStart = contourIndices.shift();
                    } else if (verts[contourStart] && verts[i].equals(verts[contourStart])) {
                        res.push([
                            i - 1,
                            contourStart
                        ]);
                    } else {
                        res.push([
                            i - 1,
                            i
                        ]);
                    }
                }
                break;
        }
        return res;
    }
    /**
   * Called from _processVertices() when applicable. This function tesselates immediateMode.geometry.
   * @private
   */ _tesselateShape() {
        // TODO: handle non-PATH shape modes that have contours
        this.shapeMode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$C$2d$g_eAdC$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["p"];
        // const contours = [[]];
        const contours = [];
        for(let i = 0; i < this.geometry.vertices.length; i++){
            if (this.contourIndices.length > 0 && this.contourIndices[0] === i) {
                this.contourIndices.shift();
                contours.push([]);
            }
            contours[contours.length - 1].push(this.geometry.vertices[i].x, this.geometry.vertices[i].y, this.geometry.vertices[i].z, this.geometry.uvs[i * 2], this.geometry.uvs[i * 2 + 1], this.geometry.vertexColors[i * 4], this.geometry.vertexColors[i * 4 + 1], this.geometry.vertexColors[i * 4 + 2], this.geometry.vertexColors[i * 4 + 3], this.geometry.vertexNormals[i].x, this.geometry.vertexNormals[i].y, this.geometry.vertexNormals[i].z);
            for(const propName in this.geometry.userVertexProperties){
                const prop = this.geometry.userVertexProperties[propName];
                const start = i * prop.getDataSize();
                const end = start + prop.getDataSize();
                const vals = prop.getSrcArray().slice(start, end);
                contours[contours.length - 1].push(...vals);
            }
        }
        const polyTriangles = this._triangulate(contours);
        const originalVertices = this.geometry.vertices;
        this.geometry.vertices = [];
        this.geometry.vertexNormals = [];
        this.geometry.uvs = [];
        for(const propName in this.geometry.userVertexProperties){
            const prop = this.geometry.userVertexProperties[propName];
            prop.resetSrcArray();
        }
        const colors = [];
        for(let j = 0, polyTriLength = polyTriangles.length; j < polyTriLength; j = j + this.tessyVertexSize){
            colors.push(...polyTriangles.slice(j + 5, j + 9));
            this.geometry.vertexNormals.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"](...polyTriangles.slice(j + 9, j + 12)));
            {
                let offset = 12;
                for(const propName in this.geometry.userVertexProperties){
                    const prop = this.geometry.userVertexProperties[propName];
                    const size = prop.getDataSize();
                    const start = j + offset;
                    const end = start + size;
                    prop.setCurrentData(polyTriangles.slice(start, end));
                    prop.pushCurrentData();
                    offset += size;
                }
            }
            this.geometry.vertices.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"](...polyTriangles.slice(j, j + 3)));
            this.geometry.uvs.push(...polyTriangles.slice(j + 3, j + 5));
        }
        if (this.renderer.geometryBuilder) {
            // Tesselating the face causes the indices of edge vertices to stop being
            // correct. When rendering, this is not a problem, since _edgesToVertices
            // will have been called before this, and edge vertex indices are no longer
            // needed. However, the geometry builder still needs this information, so
            // when one is active, we need to update the indices.
            //
            // We record index mappings in a Map so that once we have found a
            // corresponding vertex, we don't need to loop to find it again.
            const newIndex = new Map();
            this.geometry.edges = this.geometry.edges.map((edge)=>edge.map((origIdx)=>{
                    if (!newIndex.has(origIdx)) {
                        const orig = originalVertices[origIdx];
                        let newVertIndex = this.geometry.vertices.findIndex((v)=>orig.x === v.x && orig.y === v.y && orig.z === v.z);
                        if (newVertIndex === -1) {
                            // The tesselation process didn't output a vertex with the exact
                            // coordinate as before, potentially due to numerical issues. This
                            // doesn't happen often, but in this case, pick the closest point
                            let closestDist = Infinity;
                            let closestIndex = 0;
                            for(let i = 0; i < this.geometry.vertices.length; i++){
                                const vert = this.geometry.vertices[i];
                                const dX = orig.x - vert.x;
                                const dY = orig.y - vert.y;
                                const dZ = orig.z - vert.z;
                                const dist = dX * dX + dY * dY + dZ * dZ;
                                if (dist < closestDist) {
                                    closestDist = dist;
                                    closestIndex = i;
                                }
                            }
                            newVertIndex = closestIndex;
                        }
                        newIndex.set(origIdx, newVertIndex);
                    }
                    return newIndex.get(origIdx);
                }));
        }
        this.geometry.vertexColors = colors;
    }
    _initTessy() {
        // function called for each vertex of tesselator output
        function vertexCallback(data, polyVertArray) {
            for (const element of data){
                polyVertArray.push(element);
            }
        }
        function begincallback(type) {
            if (type !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libtess$2f$libtess$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].primitiveType.GL_TRIANGLES) {
                console.log(`expected TRIANGLES but got type: ${type}`);
            }
        }
        function errorcallback(errno) {
            console.log('error callback');
            console.log(`error number: ${errno}`);
        }
        // callback for when segments intersect and must be split
        const combinecallback = (coords, data, weight)=>{
            const result = new Array(this.tessyVertexSize).fill(0);
            for(let i = 0; i < weight.length; i++){
                for(let j = 0; j < result.length; j++){
                    if (weight[i] === 0 || !data[i]) continue;
                    result[j] += data[i][j] * weight[i];
                }
            }
            return result;
        };
        function edgeCallback(flag) {
        // don't really care about the flag, but need no-strip/no-fan behavior
        }
        const tessy = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libtess$2f$libtess$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].GluTesselator();
        tessy.gluTessCallback(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libtess$2f$libtess$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].gluEnum.GLU_TESS_VERTEX_DATA, vertexCallback);
        tessy.gluTessCallback(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libtess$2f$libtess$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].gluEnum.GLU_TESS_BEGIN, begincallback);
        tessy.gluTessCallback(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libtess$2f$libtess$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].gluEnum.GLU_TESS_ERROR, errorcallback);
        tessy.gluTessCallback(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libtess$2f$libtess$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].gluEnum.GLU_TESS_COMBINE, combinecallback);
        tessy.gluTessCallback(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libtess$2f$libtess$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].gluEnum.GLU_TESS_EDGE_FLAG, edgeCallback);
        tessy.gluTessProperty(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libtess$2f$libtess$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].gluEnum.GLU_TESS_WINDING_RULE, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libtess$2f$libtess$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].windingRule.GLU_TESS_WINDING_NONZERO);
        return tessy;
    }
    /**
   * Runs vertices through libtess to convert them into triangles
   * @private
   */ _triangulate(contours) {
        // libtess will take 3d verts and flatten to a plane for tesselation.
        // libtess is capable of calculating a plane to tesselate on, but
        // if all of the vertices have the same z values, we'll just
        // assume the face is facing the camera, letting us skip any performance
        // issues or bugs in libtess's automatic calculation.
        const z = contours[0] ? contours[0][2] : undefined;
        let allSameZ = true;
        for (const contour of contours){
            for(let j = 0; j < contour.length; j += this.tessyVertexSize){
                if (contour[j + 2] !== z) {
                    allSameZ = false;
                    break;
                }
            }
        }
        if (allSameZ) {
            this._tessy.gluTessNormal(0, 0, 1);
        } else {
            // Let libtess pick a plane for us
            this._tessy.gluTessNormal(0, 0, 0);
        }
        const triangleVerts = [];
        this._tessy.gluTessBeginPolygon(triangleVerts);
        for (const contour of contours){
            this._tessy.gluTessBeginContour();
            for(let j = 0; j < contour.length; j += this.tessyVertexSize){
                const coords = contour.slice(j, j + this.tessyVertexSize);
                this._tessy.gluTessVertex(coords, coords);
            }
            this._tessy.gluTessEndContour();
        }
        // finish polygon
        this._tessy.gluTessEndPolygon();
        return triangleVerts;
    }
}
;
}}),
"[project]/node_modules/p5/dist/webgl/GeometryBufferCache.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "GeometryBufferCache": (()=>GeometryBufferCache)
});
class GeometryBufferCache {
    constructor(renderer){
        this.renderer = renderer;
        this.cache = {};
    }
    numCached() {
        return Object.keys(this.cache).length;
    }
    isCached(gid) {
        return this.cache[gid] !== undefined;
    }
    getGeometryByID(gid) {
        return this.cache[gid]?.geometry;
    }
    getCached(model) {
        return this.getCachedID(model.gid);
    }
    getCachedID(gid) {
        return this.cache[gid];
    }
    ensureCached(geometry) {
        const gid = geometry.gid;
        if (!gid) {
            throw new Error('The p5.Geometry you passed in has no gid property!');
        }
        if (this.isCached(geometry.gid)) return this.getCached(geometry);
        const gl = this.renderer.GL;
        //initialize the gl buffers for our geom groups
        this.freeBuffers(gid);
        if (Object.keys(this.cache).length > 1000) {
            const key = Object.keys(this.cache)[0];
            this.freeBuffers(key);
        }
        //create a new entry in our cache
        const buffers = {};
        this.cache[gid] = buffers;
        buffers.geometry = geometry;
        let indexBuffer = buffers.indexBuffer;
        if (geometry.faces.length) {
            // allocate space for faces
            if (!indexBuffer) indexBuffer = buffers.indexBuffer = gl.createBuffer();
            const vals = geometry.faces.flat();
            // If any face references a vertex with an index greater than the maximum
            // un-singed 16 bit integer, then we need to use a Uint32Array instead of a
            // Uint16Array
            const hasVertexIndicesOverMaxUInt16 = vals.some((v)=>v > 65535);
            let type = hasVertexIndicesOverMaxUInt16 ? Uint32Array : Uint16Array;
            this.renderer._bindBuffer(indexBuffer, gl.ELEMENT_ARRAY_BUFFER, vals, type);
            // If we're using a Uint32Array for our indexBuffer we will need to pass a
            // different enum value to WebGL draw triangles. This happens in
            // the _drawElements function.
            buffers.indexBufferType = hasVertexIndicesOverMaxUInt16 ? gl.UNSIGNED_INT : gl.UNSIGNED_SHORT;
        } else {
            // the index buffer is unused, remove it
            if (indexBuffer) {
                gl.deleteBuffer(indexBuffer);
                buffers.indexBuffer = null;
            }
        }
        return buffers;
    }
    freeBuffers(gid) {
        const buffers = this.cache[gid];
        if (!buffers) {
            return;
        }
        delete this.cache[gid];
        const gl = this.renderer.GL;
        if (buffers.indexBuffer) {
            gl.deleteBuffer(buffers.indexBuffer);
        }
        function freeBuffers(defs) {
            for (const def of defs){
                if (buffers[def.dst]) {
                    gl.deleteBuffer(buffers[def.dst]);
                    buffers[def.dst] = null;
                }
            }
        }
        // free all the buffers
        freeBuffers(this.renderer.buffers.stroke);
        freeBuffers(this.renderer.buffers.fill);
        freeBuffers(this.renderer.buffers.user);
    }
}
;
}}),
"[project]/node_modules/p5/dist/webgl/interaction.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>interaction)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$C$2d$g_eAdC$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/constants-C-g_eAdC.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Vector.js [app-client] (ecmascript)");
;
;
/**
 * @module 3D
 * @submodule Interaction
 * @for p5
 * @requires core
 */ function interaction(p51, fn) {
    /**
   * Allows the user to orbit around a 3D sketch using a mouse, trackpad, or
   * touchscreen.
   *
   * 3D sketches are viewed through an imaginary camera. Calling
   * `orbitControl()` within the <a href="#/p5/draw">draw()</a> function allows
   * the user to change the camera’s position:
   *
   * ```js
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Rest of sketch.
   * }
   * ```
   *
   * Left-clicking and dragging or swipe motion will rotate the camera position
   * about the center of the sketch. Right-clicking and dragging or multi-swipe
   * will pan the camera position without rotation. Using the mouse wheel
   * (scrolling) or pinch in/out will move the camera further or closer from the
   * center of the sketch.
   *
   * The first three parameters, `sensitivityX`, `sensitivityY`, and
   * `sensitivityZ`, are optional. They’re numbers that set the sketch’s
   * sensitivity to movement along each axis. For example, calling
   * `orbitControl(1, 2, -1)` keeps movement along the x-axis at its default
   * value, makes the sketch twice as sensitive to movement along the y-axis,
   * and reverses motion along the z-axis. By default, all sensitivity values
   * are 1.
   *
   * The fourth parameter, `options`, is also optional. It’s an object that
   * changes the behavior of orbiting. For example, calling
   * `orbitControl(1, 1, 1, options)` keeps the default sensitivity values while
   * changing the behaviors set with `options`. The object can have the
   * following properties:
   *
   * ```js
   * let options = {
   *   // Setting this to false makes mobile interactions smoother by
   *   // preventing accidental interactions with the page while orbiting.
   *   // By default, it's true.
   *   disableTouchActions: true,
   *
   *   // Setting this to true makes the camera always rotate in the
   *   // direction the mouse/touch is moving.
   *   // By default, it's false.
   *   freeRotation: false
   * };
   *
   * orbitControl(1, 1, 1, options);
   * ```
   *
   * @method orbitControl
   * @for p5
   * @param  {Number} [sensitivityX] sensitivity to movement along the x-axis. Defaults to 1.
   * @param  {Number} [sensitivityY] sensitivity to movement along the y-axis. Defaults to 1.
   * @param  {Number} [sensitivityZ] sensitivity to movement along the z-axis. Defaults to 1.
   * @param  {Object} [options] object with two optional properties, `disableTouchActions`
   *                            and `freeRotation`. Both are `Boolean`s. `disableTouchActions`
   *                            defaults to `true` and `freeRotation` defaults to `false`.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe('A multicolor box on a gray background. The camera angle changes when the user interacts using a mouse, trackpad, or touchscreen.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Style the box.
   *   normalMaterial();
   *
   *   // Draw the box.
   *   box(30, 50);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe('A multicolor box on a gray background. The camera angle changes when the user interacts using a mouse, trackpad, or touchscreen.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   // Make the interactions 3X sensitive.
   *   orbitControl(3, 3, 3);
   *
   *   // Style the box.
   *   normalMaterial();
   *
   *   // Draw the box.
   *   box(30, 50);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe('A multicolor box on a gray background. The camera angle changes when the user interacts using a mouse, trackpad, or touchscreen.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Create an options object.
   *   let options = {
   *     disableTouchActions: false,
   *     freeRotation: true
   *   };
   *
   *   // Enable orbiting with the mouse.
   *   // Prevent accidental touch actions on touchscreen devices
   *   // and enable free rotation.
   *   orbitControl(1, 1, 1, options);
   *
   *   // Style the box.
   *   normalMaterial();
   *
   *   // Draw the box.
   *   box(30, 50);
   * }
   * </code>
   * </div>
   */ // implementation based on three.js 'orbitControls':
    // https://github.com/mrdoob/three.js/blob/6afb8595c0bf8b2e72818e42b64e6fe22707d896/examples/jsm/controls/OrbitControls.js#L22
    fn.orbitControl = function(sensitivityX, sensitivityY, sensitivityZ, options) {
        this._assert3d('orbitControl');
        // p5._validateParameters('orbitControl', arguments);
        const cam = this._renderer.states.curCamera;
        if (typeof sensitivityX === 'undefined') {
            sensitivityX = 1;
        }
        if (typeof sensitivityY === 'undefined') {
            sensitivityY = sensitivityX;
        }
        if (typeof sensitivityZ === 'undefined') {
            sensitivityZ = 1;
        }
        if (typeof options !== 'object') {
            options = {};
        }
        // default right-mouse and mouse-wheel behaviors (context menu and scrolling,
        // respectively) are disabled here to allow use of those events for panning and
        // zooming. However, whether or not to disable touch actions is an option.
        // disable context menu for canvas element and add 'contextMenuDisabled'
        // flag to p5 instance
        if (this.contextMenuDisabled !== true) {
            this.canvas.oncontextmenu = ()=>false;
            this.contextMenuDisabled = true;
        }
        // disable default scrolling behavior on the canvas element and add
        // 'wheelDefaultDisabled' flag to p5 instance
        if (this.wheelDefaultDisabled !== true) {
            this.canvas.onwheel = ()=>false;
            this.wheelDefaultDisabled = true;
        }
        // disable default touch behavior on the canvas element and add
        // 'touchActionsDisabled' flag to p5 instance
        const { disableTouchActions = true } = options;
        if (this.touchActionsDisabled !== true && disableTouchActions) {
            this.canvas.style['touch-action'] = 'none';
            this.touchActionsDisabled = true;
        }
        // If option.freeRotation is true, the camera always rotates freely in the direction
        // the pointer moves. default value is false (normal behavior)
        const { freeRotation = false } = options;
        // get moved touches.
        const movedTouches = [];
        this.touches.forEach((curTouch)=>{
            this._renderer.prevTouches.forEach((prevTouch)=>{
                if (curTouch.id === prevTouch.id) {
                    const movedTouch = {
                        x: curTouch.x,
                        y: curTouch.y,
                        px: prevTouch.x,
                        py: prevTouch.y
                    };
                    movedTouches.push(movedTouch);
                }
            });
        });
        this._renderer.prevTouches = this.touches;
        // The idea of using damping is based on the following website. thank you.
        // https://github.com/freshfork/p5.EasyCam/blob/9782964680f6a5c4c9bee825c475d9f2021d5134/p5.easycam.js#L1124
        // variables for interaction
        let deltaRadius = 0;
        let deltaTheta = 0;
        let deltaPhi = 0;
        let moveDeltaX = 0;
        let moveDeltaY = 0;
        // constants for dampingProcess
        const damping = 0.85;
        const rotateAccelerationFactor = 0.6;
        const moveAccelerationFactor = 0.15;
        // For touches, the appropriate scale is different
        // because the distance difference is multiplied.
        const mouseZoomScaleFactor = 0.01;
        const touchZoomScaleFactor = 0.0004;
        const scaleFactor = this.height < this.width ? this.height : this.width;
        // Flag whether the mouse or touch pointer is inside the canvas
        let pointersInCanvas = false;
        // calculate and determine flags and variables.
        if (movedTouches.length > 0) {
            /* for touch */ // if length === 1, rotate
            // if length > 1, zoom and move
            // for touch, it is calculated based on one moved touch pointer position.
            pointersInCanvas = movedTouches[0].x > 0 && movedTouches[0].x < this.width && movedTouches[0].y > 0 && movedTouches[0].y < this.height;
            if (movedTouches.length === 1) {
                const t = movedTouches[0];
                deltaTheta = -sensitivityX * (t.x - t.px) / scaleFactor;
                deltaPhi = sensitivityY * (t.y - t.py) / scaleFactor;
            } else {
                const t0 = movedTouches[0];
                const t1 = movedTouches[1];
                const distWithTouches = Math.hypot(t0.x - t1.x, t0.y - t1.y);
                const prevDistWithTouches = Math.hypot(t0.px - t1.px, t0.py - t1.py);
                const changeDist = distWithTouches - prevDistWithTouches;
                // move the camera farther when the distance between the two touch points
                // decreases, move the camera closer when it increases.
                deltaRadius = -changeDist * sensitivityZ * touchZoomScaleFactor;
                // Move the center of the camera along with the movement of
                // the center of gravity of the two touch points.
                moveDeltaX = 0.5 * (t0.x + t1.x) - 0.5 * (t0.px + t1.px);
                moveDeltaY = 0.5 * (t0.y + t1.y) - 0.5 * (t0.py + t1.py);
            }
            if (this.touches.length > 0) {
                if (pointersInCanvas) {
                    // Initiate an interaction if touched in the canvas
                    this._renderer.executeRotateAndMove = true;
                    this._renderer.executeZoom = true;
                }
            } else {
                // End an interaction when the touch is released
                this._renderer.executeRotateAndMove = false;
                this._renderer.executeZoom = false;
            }
        } else {
            /* for mouse */ // if wheelDeltaY !== 0, zoom
            // if mouseLeftButton is down, rotate
            // if mouseRightButton is down, move
            // For mouse, it is calculated based on the mouse position.
            pointersInCanvas = this.mouseX > 0 && this.mouseX < this.width && this.mouseY > 0 && this.mouseY < this.height;
            if (this._mouseWheelDeltaY !== 0) {
                // zoom the camera depending on the value of _mouseWheelDeltaY.
                // move away if positive, move closer if negative
                deltaRadius = Math.sign(this._mouseWheelDeltaY) * sensitivityZ;
                deltaRadius *= mouseZoomScaleFactor;
                this._mouseWheelDeltaY = 0;
                // start zoom when the mouse is wheeled within the canvas.
                if (pointersInCanvas) this._renderer.executeZoom = true;
            } else {
                // quit zoom when you stop wheeling.
                this._renderer.executeZoom = false;
            }
            if (this.mouseIsPressed) {
                if (this.mouseButton.left) {
                    deltaTheta = -sensitivityX * this.movedX / scaleFactor;
                    deltaPhi = sensitivityY * this.movedY / scaleFactor;
                } else if (this.mouseButton.right) {
                    moveDeltaX = this.movedX;
                    moveDeltaY = this.movedY * cam.yScale;
                }
                // start rotate and move when mouse is pressed within the canvas.
                if (pointersInCanvas) this._renderer.executeRotateAndMove = true;
            } else {
                // quit rotate and move if mouse is released.
                this._renderer.executeRotateAndMove = false;
            }
        }
        // interactions
        // zoom process
        if (deltaRadius !== 0 && this._renderer.executeZoom) {
            // accelerate zoom velocity
            this._renderer.zoomVelocity += deltaRadius;
        }
        if (Math.abs(this._renderer.zoomVelocity) > 0.001) {
            // if freeRotation is true, we use _orbitFree() instead of _orbit()
            if (freeRotation) {
                cam._orbitFree(0, 0, this._renderer.zoomVelocity);
            } else {
                cam._orbit(0, 0, this._renderer.zoomVelocity);
            }
            // In orthogonal projection, the scale does not change even if
            // the distance to the gaze point is changed, so the projection matrix
            // needs to be modified.
            if (cam.projMatrix.mat4[15] !== 0) {
                cam.projMatrix.mat4[0] *= Math.pow(10, -this._renderer.zoomVelocity);
                cam.projMatrix.mat4[5] *= Math.pow(10, -this._renderer.zoomVelocity);
                // modify uPMatrix
                this._renderer.states.setValue('uPMatrix', this._renderer.states.uPMatrix.clone());
                this._renderer.states.uPMatrix.mat4[0] = cam.projMatrix.mat4[0];
                this._renderer.states.uPMatrix.mat4[5] = cam.projMatrix.mat4[5];
            }
            // damping
            this._renderer.zoomVelocity *= damping;
        } else {
            this._renderer.zoomVelocity = 0;
        }
        // rotate process
        if ((deltaTheta !== 0 || deltaPhi !== 0) && this._renderer.executeRotateAndMove) {
            // accelerate rotate velocity
            this._renderer.rotateVelocity.add(deltaTheta * rotateAccelerationFactor, deltaPhi * rotateAccelerationFactor);
        }
        if (this._renderer.rotateVelocity.magSq() > 0.000001) {
            // if freeRotation is true, the camera always rotates freely in the direction the pointer moves
            if (freeRotation) {
                cam._orbitFree(-this._renderer.rotateVelocity.x, this._renderer.rotateVelocity.y, 0);
            } else {
                cam._orbit(this._renderer.rotateVelocity.x, this._renderer.rotateVelocity.y, 0);
            }
            // damping
            this._renderer.rotateVelocity.mult(damping);
        } else {
            this._renderer.rotateVelocity.set(0, 0);
        }
        // move process
        if ((moveDeltaX !== 0 || moveDeltaY !== 0) && this._renderer.executeRotateAndMove) {
            // Normalize movement distance
            const ndcX = moveDeltaX * 2 / this.width;
            const ndcY = -moveDeltaY * 2 / this.height;
            // accelerate move velocity
            this._renderer.moveVelocity.add(ndcX * moveAccelerationFactor, ndcY * moveAccelerationFactor);
        }
        if (this._renderer.moveVelocity.magSq() > 0.000001) {
            // Translate the camera so that the entire object moves
            // perpendicular to the line of sight when the mouse is moved
            // or when the centers of gravity of the two touch pointers move.
            const local = cam._getLocalAxes();
            // Calculate the z coordinate in the view coordinates of
            // the center, that is, the distance to the view point
            const diffX = cam.eyeX - cam.centerX;
            const diffY = cam.eyeY - cam.centerY;
            const diffZ = cam.eyeZ - cam.centerZ;
            const viewZ = Math.sqrt(diffX * diffX + diffY * diffY + diffZ * diffZ);
            // position vector of the center.
            let cv = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"](cam.centerX, cam.centerY, cam.centerZ);
            // Calculate the normalized device coordinates of the center.
            cv = cam.cameraMatrix.multiplyPoint(cv);
            cv = this._renderer.states.uPMatrix.multiplyAndNormalizePoint(cv);
            // Move the center by this distance
            // in the normalized device coordinate system.
            cv.x -= this._renderer.moveVelocity.x;
            cv.y -= this._renderer.moveVelocity.y;
            // Calculate the translation vector
            // in the direction perpendicular to the line of sight of center.
            let dx, dy;
            const uP = this._renderer.states.uPMatrix.mat4;
            if (uP[15] === 0) {
                dx = (uP[8] + cv.x) / uP[0] * viewZ;
                dy = (uP[9] + cv.y) / uP[5] * viewZ;
            } else {
                dx = (cv.x - uP[12]) / uP[0];
                dy = (cv.y - uP[13]) / uP[5];
            }
            // translate the camera.
            cam.setPosition(cam.eyeX + dx * local.x[0] + dy * local.y[0], cam.eyeY + dx * local.x[1] + dy * local.y[1], cam.eyeZ + dx * local.x[2] + dy * local.y[2]);
            // damping
            this._renderer.moveVelocity.mult(damping);
        } else {
            this._renderer.moveVelocity.set(0, 0);
        }
        return this;
    };
    /**
   * Adds a grid and an axes icon to clarify orientation in 3D sketches.
   *
   * `debugMode()` adds a grid that shows where the “ground” is in a sketch. By
   * default, the grid will run through the origin `(0, 0, 0)` of the sketch
   * along the XZ plane. `debugMode()` also adds an axes icon that points along
   * the positive x-, y-, and z-axes. Calling `debugMode()` displays the grid
   * and axes icon with their default size and position.
   *
   * There are four ways to call `debugMode()` with optional parameters to
   * customize the debugging environment.
   *
   * The first way to call `debugMode()` has one parameter, `mode`. If the
   * system constant `GRID` is passed, as in `debugMode(GRID)`, then the grid
   * will be displayed and the axes icon will be hidden. If the constant `AXES`
   * is passed, as in `debugMode(AXES)`, then the axes icon will be displayed
   * and the grid will be hidden.
   *
   * The second way to call `debugMode()` has six parameters. The first
   * parameter, `mode`, selects either `GRID` or `AXES` to be displayed. The
   * next five parameters, `gridSize`, `gridDivisions`, `xOff`, `yOff`, and
   * `zOff` are optional. They’re numbers that set the appearance of the grid
   * (`gridSize` and `gridDivisions`) and the placement of the axes icon
   * (`xOff`, `yOff`, and `zOff`). For example, calling
   * `debugMode(20, 5, 10, 10, 10)` sets the `gridSize` to 20 pixels, the number
   * of `gridDivisions` to 5, and offsets the axes icon by 10 pixels along the
   * x-, y-, and z-axes.
   *
   * The third way to call `debugMode()` has five parameters. The first
   * parameter, `mode`, selects either `GRID` or `AXES` to be displayed. The
   * next four parameters, `axesSize`, `xOff`, `yOff`, and `zOff` are optional.
   * They’re numbers that set the appearance of the size of the axes icon
   * (`axesSize`) and its placement (`xOff`, `yOff`, and `zOff`).
   *
   * The fourth way to call `debugMode()` has nine optional parameters. The
   * first five parameters, `gridSize`, `gridDivisions`, `gridXOff`, `gridYOff`,
   * and `gridZOff` are numbers that set the appearance of the grid. For
   * example, calling `debugMode(100, 5, 0, 0, 0)` sets the `gridSize` to 100,
   * the number of `gridDivisions` to 5, and sets all the offsets to 0 so that
   * the grid is centered at the origin. The next four parameters, `axesSize`,
   * `xOff`, `yOff`, and `zOff` are numbers that set the appearance of the size
   * of the axes icon (`axesSize`) and its placement (`axesXOff`, `axesYOff`,
   * and `axesZOff`). For example, calling
   * `debugMode(100, 5, 0, 0, 0, 50, 10, 10, 10)` sets the `gridSize` to 100,
   * the number of `gridDivisions` to 5, and sets all the offsets to 0 so that
   * the grid is centered at the origin. It then sets the `axesSize` to 50 and
   * offsets the icon 10 pixels along each axis.
   *
   * @method debugMode
   *
   * @example
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Enable debug mode.
   *   debugMode();
   *
   *   describe('A multicolor box on a gray background. A grid and axes icon are displayed near the box.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Style the box.
   *   normalMaterial();
   *
   *   // Draw the box.
   *   box(20, 40);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Enable debug mode.
   *   // Only display the axes icon.
   *   debugMode(AXES);
   *
   *   describe('A multicolor box on a gray background. A grid and axes icon are displayed near the box.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Style the box.
   *   normalMaterial();
   *
   *   // Draw the box.
   *   box(20, 40);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Enable debug mode.
   *   // Only display the grid and customize it:
   *   // - size: 50
   *   // - divisions: 10
   *   // - offsets: 0, 20, 0
   *   debugMode(GRID, 50, 10, 0, 20, 0);
   *
   *   describe('A multicolor box on a gray background. A grid is displayed below the box.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Style the box.
   *   normalMaterial();
   *
   *   // Draw the box.
   *   box(20, 40);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Enable debug mode.
   *   // Display the grid and axes icon and customize them:
   *   // Grid
   *   // ----
   *   // - size: 50
   *   // - divisions: 10
   *   // - offsets: 0, 20, 0
   *   // Axes
   *   // ----
   *   // - size: 50
   *   // - offsets: 0, 0, 0
   *   debugMode(50, 10, 0, 20, 0, 50, 0, 0, 0);
   *
   *   describe('A multicolor box on a gray background. A grid is displayed below the box. An axes icon is displayed at the center of the box.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Style the box.
   *   normalMaterial();
   *
   *   // Draw the box.
   *   box(20, 40);
   * }
   * </code>
   * </div>
   */ /**
   * @method debugMode
   * @param {(GRID|AXES)} mode either GRID or AXES
   */ /**
   * @method debugMode
   * @param {(GRID|AXES)} mode
   * @param {Number} [gridSize] side length of the grid.
   * @param {Number} [gridDivisions] number of divisions in the grid.
   * @param {Number} [xOff] offset from origin along the x-axis.
   * @param {Number} [yOff] offset from origin along the y-axis.
   * @param {Number} [zOff] offset from origin along the z-axis.
   */ /**
   * @method debugMode
   * @param {(GRID|AXES)} mode
   * @param {Number} [axesSize] length of axes icon markers.
   * @param {Number} [xOff]
   * @param {Number} [yOff]
   * @param {Number} [zOff]
   */ /**
   * @method debugMode
   * @param {Number} [gridSize]
   * @param {Number} [gridDivisions]
   * @param {Number} [gridXOff] grid offset from the origin along the x-axis.
   * @param {Number} [gridYOff] grid offset from the origin along the y-axis.
   * @param {Number} [gridZOff] grid offset from the origin along the z-axis.
   * @param {Number} [axesSize]
   * @param {Number} [axesXOff] axes icon offset from the origin along the x-axis.
   * @param {Number} [axesYOff] axes icon offset from the origin along the y-axis.
   * @param {Number} [axesZOff] axes icon offset from the origin along the z-axis.
   */ fn.debugMode = function(...args) {
        this._assert3d('debugMode');
        // p5._validateParameters('debugMode', args);
        // start by removing existing 'post' registered debug methods
        for(let i = p51.lifecycleHooks.postdraw.length - 1; i >= 0; i--){
            // test for equality...
            if (p51.lifecycleHooks.postdraw[i].toString() === this._grid().toString() || p51.lifecycleHooks.postdraw[i].toString() === this._axesIcon().toString()) {
                p51.lifecycleHooks.postdraw.splice(i, 1);
            }
        }
        // then add new debugMode functions according to the argument list
        if (args[0] === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$C$2d$g_eAdC$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["G"]) {
            p51.lifecycleHooks.postdraw.push(this._grid(args[1], args[2], args[3], args[4], args[5]));
        } else if (args[0] === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$C$2d$g_eAdC$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["A"]) {
            p51.lifecycleHooks.postdraw.push(this._axesIcon(args[1], args[2], args[3], args[4]));
        } else {
            p51.lifecycleHooks.postdraw.push(this._grid(args[0], args[1], args[2], args[3], args[4]));
            p51.lifecycleHooks.postdraw.push(this._axesIcon(args[5], args[6], args[7], args[8]));
        }
    };
    /**
   * Turns off <a href="#/p5/debugMode">debugMode()</a> in a 3D sketch.
   *
   * @method noDebugMode
   *
   * @example
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Enable debug mode.
   *   debugMode();
   *
   *   describe('A multicolor box on a gray background. A grid and axes icon are displayed near the box. They disappear when the user double-clicks.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Style the box.
   *   normalMaterial();
   *
   *   // Draw the box.  box(20, 40);
   * }
   *
   * // Disable debug mode when the user double-clicks.
   * function doubleClicked() {
   *   noDebugMode();
   * }
   * </code>
   * </div>
   */ fn.noDebugMode = function() {
        this._assert3d('noDebugMode');
        // start by removing existing 'post' registered debug methods
        for(let i = p51.lifecycleHooks.postdraw.length - 1; i >= 0; i--){
            // test for equality...
            if (p51.lifecycleHooks.postdraw[i].toString() === this._grid().toString() || p51.lifecycleHooks.postdraw[i].toString() === this._axesIcon().toString()) {
                p51.lifecycleHooks.postdraw.splice(i, 1);
            }
        }
    };
    /**
   * For use with debugMode
   * @private
   * @method _grid
   * @param {Number} [size] size of grid sides
   * @param {Number} [div] number of grid divisions
   * @param {Number} [xOff] offset of grid center from origin in X axis
   * @param {Number} [yOff] offset of grid center from origin in Y axis
   * @param {Number} [zOff] offset of grid center from origin in Z axis
   */ fn._grid = function(size, numDivs, xOff, yOff, zOff) {
        if (typeof size === 'undefined') {
            size = this.width / 2;
        }
        if (typeof numDivs === 'undefined') {
            // ensure at least 2 divisions
            numDivs = Math.round(size / 30) < 4 ? 4 : Math.round(size / 30);
        }
        if (typeof xOff === 'undefined') {
            xOff = 0;
        }
        if (typeof yOff === 'undefined') {
            yOff = 0;
        }
        if (typeof zOff === 'undefined') {
            zOff = 0;
        }
        const spacing = size / numDivs;
        const halfSize = size / 2;
        return function() {
            this.push();
            this.stroke(this._renderer.states.curStrokeColor[0] * 255, this._renderer.states.curStrokeColor[1] * 255, this._renderer.states.curStrokeColor[2] * 255);
            this._renderer.states.setValue('uModelMatrix', this._renderer.states.uModelMatrix.clone());
            this._renderer.states.uModelMatrix.reset();
            // Lines along X axis
            for(let q = 0; q <= numDivs; q++){
                this.beginShape(this.LINES);
                this.vertex(-halfSize + xOff, yOff, q * spacing - halfSize + zOff);
                this.vertex(+halfSize + xOff, yOff, q * spacing - halfSize + zOff);
                this.endShape();
            }
            // Lines along Z axis
            for(let i = 0; i <= numDivs; i++){
                this.beginShape(this.LINES);
                this.vertex(i * spacing - halfSize + xOff, yOff, -halfSize + zOff);
                this.vertex(i * spacing - halfSize + xOff, yOff, +halfSize + zOff);
                this.endShape();
            }
            this.pop();
        };
    };
    /**
   * For use with debugMode
   * @private
   * @method _axesIcon
   * @param {Number} [size] size of axes icon lines
   * @param {Number} [xOff] offset of icon from origin in X axis
   * @param {Number} [yOff] offset of icon from origin in Y axis
   * @param {Number} [zOff] offset of icon from origin in Z axis
   */ fn._axesIcon = function(size, xOff, yOff, zOff) {
        if (typeof size === 'undefined') {
            size = this.width / 20 > 40 ? this.width / 20 : 40;
        }
        if (typeof xOff === 'undefined') {
            xOff = -this.width / 4;
        }
        if (typeof yOff === 'undefined') {
            yOff = xOff;
        }
        if (typeof zOff === 'undefined') {
            zOff = xOff;
        }
        return ()=>{
            this.push();
            this._renderer.states.setValue('uModelMatrix', this._renderer.states.uModelMatrix.clone());
            this._renderer.states.uModelMatrix.reset();
            // X axis
            this.strokeWeight(2);
            this.stroke(255, 0, 0);
            this.beginShape(this.LINES);
            this.vertex(xOff, yOff, zOff);
            this.vertex(xOff + size, yOff, zOff);
            this.endShape();
            // Y axis
            this.stroke(0, 255, 0);
            this.beginShape(this.LINES);
            this.vertex(xOff, yOff, zOff);
            this.vertex(xOff, yOff + size, zOff);
            this.endShape();
            // Z axis
            this.stroke(0, 0, 255);
            this.beginShape(this.LINES);
            this.vertex(xOff, yOff, zOff);
            this.vertex(xOff, yOff, zOff + size);
            this.endShape();
            this.pop();
        };
    };
}
if (typeof p5 !== 'undefined') {
    interaction(p5, p5.prototype);
}
;
}}),
"[project]/node_modules/p5/dist/webgl/loading.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>loading)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.Geometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Vector.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d2d$aAe5aq3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/rendering--aAe5aq3.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$C$2d$g_eAdC$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/constants-C-g_eAdC.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$DataArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.DataArray.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$creating_reading$2d$D4AAKRbx$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/creating_reading-D4AAKRbx.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$color$2f$color_spaces$2f$hsb$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/color/color_spaces/hsb.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$dom$2f$p5$2e$Element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/dom/p5.Element.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$dom$2f$p5$2e$File$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/dom/p5.File.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$p5$2e$XML$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/p5.XML.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/p5.Renderer-CwAYZOC2.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$filters$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/filters.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$custom_shapes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/custom_shapes.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$States$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/States.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/utilities.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$file$2d$saver$2f$FileSaver$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/file-saver/FileSaver.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$dom$2f$p5$2e$MediaElement$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/dom/p5.MediaElement.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$2d_primitives$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/2d_primitives.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$helpers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/helpers.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$attributes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/attributes.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$curves$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/curves.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$vertex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/vertex.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$color$2f$setting$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/color/setting.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$omggif$2f$omggif$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/omggif/omggif.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$csv$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/csv.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$gifenc$2f$dist$2f$gifenc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/gifenc/dist/gifenc.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$pixels$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/pixels.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$transform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/transform.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$GeometryBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/GeometryBuilder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Matrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Matrix.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$Matrices$2f$Matrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/Matrices/Matrix.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$Matrices$2f$MatrixInterface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/Matrices/MatrixInterface.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$Quat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.Quat.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$RenderBuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.RenderBuffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$ShapeBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/ShapeBuilder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libtess$2f$libtess$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libtess/libtess.min.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$GeometryBufferCache$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/GeometryBufferCache.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$const$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/const.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$trigonometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/trigonometry.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
/**
 * @module Shape
 * @submodule 3D Models
 * @for p5
 * @requires core
 * @requires p5.Geometry
 */ async function fileExists(url) {
    try {
        const response = await fetch(url, {
            method: 'HEAD'
        });
        return response.ok;
    } catch (error) {
        return false;
    }
}
function loading(p51, fn) {
    /**
   * Loads a 3D model to create a
   * <a href="#/p5.Geometry">p5.Geometry</a> object.
   *
   * `loadModel()` can load 3D models from OBJ and STL files. Once the model is
   * loaded, it can be displayed with the
   * <a href="#/p5/model">model()</a> function, as in `model(shape)`.
   *
   * There are three ways to call `loadModel()` with optional parameters to help
   * process the model.
   *
   * The first parameter, `path`, is a `String` with the path to the file. Paths
   * to local files should be relative, as in `loadModel('assets/model.obj')`.
   * URLs such as `'https://example.com/model.obj'` may be blocked due to browser
   * security. The `path` parameter can also be defined as a [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request)
   * object for more advanced usage.
   * Note: When loading a `.obj` file that references materials stored in
   * `.mtl` files, p5.js will attempt to load and apply those materials.
   * To ensure that the `.obj` file reads the `.mtl` file correctly include the
   * `.mtl` file alongside it.
   *
   * The first way to call `loadModel()` has three optional parameters after the
   * file path. The first optional parameter, `successCallback`, is a function
   * to call once the model loads. For example,
   * `loadModel('assets/model.obj', handleModel)` will call the `handleModel()`
   * function once the model loads. The second optional parameter,
   * `failureCallback`, is a function to call if the model fails to load. For
   * example, `loadModel('assets/model.obj', handleModel, handleFailure)` will
   * call the `handleFailure()` function if an error occurs while loading. The
   * third optional parameter, `fileType`, is the model’s file extension as a
   * string. For example,
   * `loadModel('assets/model', handleModel, handleFailure, '.obj')` will try to
   * load the file model as a `.obj` file.
   *
   * The second way to call `loadModel()` has four optional parameters after the
   * file path. The first optional parameter is a `Boolean` value. If `true` is
   * passed, as in `loadModel('assets/model.obj', true)`, then the model will be
   * resized to ensure it fits the canvas. The next three parameters are
   * `successCallback`, `failureCallback`, and `fileType` as described above.
   *
   * The third way to call `loadModel()` has one optional parameter after the
   * file path. The optional parameter, `options`, is an `Object` with options,
   * as in `loadModel('assets/model.obj', options)`. The `options` object can
   * have the following properties:
   *
   * ```js
   * let options = {
   *   // Enables standardized size scaling during loading if set to true.
   *   normalize: true,
   *
   *   // Function to call once the model loads.
   *   successCallback: handleModel,
   *
   *   // Function to call if an error occurs while loading.
   *   failureCallback: handleError,
   *
   *   // Model's file extension.
   *   fileType: '.stl',
   *
   *   // Flips the U texture coordinates of the model.
   *   flipU: false,
   *
   *   // Flips the V texture coordinates of the model.
   *   flipV: false
   * };
   *
   * // Pass the options object to loadModel().
   * loadModel('assets/model.obj', options);
   * ```
   *
   * This function returns a `Promise` and should be used in an `async` setup with
   * `await`. See the examples for the usage syntax.
   *
   * Note: There’s no support for colored STL files. STL files with color will
   * be rendered without color.
   *
   * @method loadModel
   * @param  {String|Request} path      path of the model to be loaded.
   * @param  {String} [fileType]          model’s file extension. Either `'.obj'` or `'.stl'`.
   * @param  {Boolean} normalize        if `true`, scale the model to fit the canvas.
   * @param  {function(p5.Geometry)} [successCallback] function to call once the model is loaded. Will be passed
   *                                                   the <a href="#/p5.Geometry">p5.Geometry</a> object.
   * @param  {function(Event)} [failureCallback] function to call if the model fails to load. Will be passed an `Error` event object.
   * @return {Promise<p5.Geometry>} the <a href="#/p5.Geometry">p5.Geometry</a> object
   *
   * @example
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let shape;
   *
   * // Load the file and create a p5.Geometry object.
   * async function setup() {
   *   shape = await loadModel('assets/teapot.obj');
   *
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe('A white teapot drawn against a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Draw the shape.
   *   model(shape);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let shape;
   *
   * // Load the file and create a p5.Geometry object.
   * // Normalize the geometry's size to fit the canvas.
   * async function setup() {
   *   shape = await loadModel('assets/teapot.obj', true);
   *
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe('A white teapot drawn against a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Draw the shape.
   *   model(shape);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let shape;
   *
   * // Load the file and create a p5.Geometry object.
   * async function setup() {
   *   await loadModel('assets/teapot.obj', true, handleModel);
   *
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe('A white teapot drawn against a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Draw the shape.
   *   model(shape);
   * }
   *
   * // Set the shape variable and log the geometry's
   * // ID to the console.
   * function handleModel(data) {
   *   shape = data;
   *   console.log(shape.gid);
   * }
   * </code>
   * </div>
   *
   * <div class='notest'>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let shape;
   *
   * // Load the file and create a p5.Geometry object.
   * async function setup() {
   *   await loadModel('assets/teapot.obj', true, handleModel, handleError);
   *
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe('A white teapot drawn against a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Draw the shape.
   *   model(shape);
   * }
   *
   * // Set the shape variable and print the geometry's
   * // ID to the console.
   * function handleModel(data) {
   *   shape = data;
   *   console.log(shape.gid);
   * }
   *
   * // Print an error message if the file doesn't load.
   * function handleError(error) {
   *   console.error('Oops!', error);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let shape;
   *
   * // Load the file and create a p5.Geometry object.
   * async function setup() {
   *   await loadModel('assets/teapot.obj', '.obj', true, handleModel, handleError);
   *
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe('A white teapot drawn against a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Draw the shape.
   *   model(shape);
   * }
   *
   * // Set the shape variable and print the geometry's
   * // ID to the console.
   * function handleModel(data) {
   *   shape = data;
   *   console.log(shape.gid);
   * }
   *
   * // Print an error message if the file doesn't load.
   * function handleError(error) {
   *   console.error('Oops!', error);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let shape;
   * let options = {
   *   fileType: '.obj',
   *   normalize: true,
   *   successCallback: handleModel,
   *   failureCallback: handleError
   * };
   *
   * // Load the file and create a p5.Geometry object.
   * async function setup() {
   *   await loadModel('assets/teapot.obj', options);
   *
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe('A white teapot drawn against a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Draw the shape.
   *   model(shape);
   * }
   *
   * // Set the shape variable and print the geometry's
   * // ID to the console.
   * function handleModel(data) {
   *   shape = data;
   *   console.log(shape.gid);
   * }
   *
   * // Print an error message if the file doesn't load.
   * function handleError(error) {
   *   console.error('Oops!', error);
   * }
   * </code>
   * </div>
   */ /**
   * @method loadModel
   * @param  {String|Request} path
   * @param  {String} [fileType]
   * @param  {function(p5.Geometry)} [successCallback]
   * @param  {function(Event)} [failureCallback]
   * @return {Promise<p5.Geometry>} new <a href="#/p5.Geometry">p5.Geometry</a> object.
   */ /**
   * @method loadModel
   * @param  {String|Request} path
   * @param  {Object} [options] loading options.
   * @param  {String} [options.fileType]
   * @param  {function(p5.Geometry)} [options.successCallback]
   * @param  {function(Event)} [options.failureCallback]
   * @param  {Boolean} [options.normalize]
   * @param  {Boolean} [options.flipU]
   * @param  {Boolean} [options.flipV]
   * @return {Promise<p5.Geometry>} new <a href="#/p5.Geometry">p5.Geometry</a> object.
   */ fn.loadModel = async function(path, fileType, normalize, successCallback, failureCallback) {
        // p5._validateParameters('loadModel', arguments);
        let flipU = false;
        let flipV = false;
        if (typeof fileType === 'object') {
            // Passing in options object
            normalize = fileType.normalize || false;
            successCallback = fileType.successCallback;
            failureCallback = fileType.failureCallback;
            fileType = fileType.fileType || fileType;
            flipU = fileType.flipU || false;
            flipV = fileType.flipV || false;
        } else {
            // Passing in individual parameters
            if (typeof arguments[arguments.length - 1] === 'function') {
                if (typeof arguments[arguments.length - 2] === 'function') {
                    successCallback = arguments[arguments.length - 2];
                    failureCallback = arguments[arguments.length - 1];
                } else {
                    successCallback = arguments[arguments.length - 1];
                }
            }
            if (typeof fileType === 'string') {
                if (typeof normalize !== 'boolean') normalize = false;
            } else if (typeof fileType === 'boolean') {
                normalize = fileType;
                fileType = path.slice(-4);
            } else {
                fileType = path.slice(-4);
                normalize = false;
            }
        }
        if (fileType.toLowerCase() !== '.obj' && fileType.toLowerCase() !== '.stl') {
            fileType = '.obj';
        }
        const model = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Geometry"](undefined, undefined, undefined, this._renderer);
        model.gid = `${path}|${normalize}`;
        async function getMaterials(lines) {
            const parsedMaterialPromises = [];
            for (let line of lines){
                const mtllibMatch = line.match(/^mtllib (.+)/);
                if (mtllibMatch) {
                    // Object has material
                    let mtlPath = '';
                    const mtlFilename = mtllibMatch[1];
                    const objPathParts = path.split('/');
                    if (objPathParts.length > 1) {
                        objPathParts.pop();
                        const objFolderPath = objPathParts.join('/');
                        mtlPath = objFolderPath + '/' + mtlFilename;
                    } else {
                        mtlPath = mtlFilename;
                    }
                    parsedMaterialPromises.push(fileExists(mtlPath).then((exists)=>{
                        if (exists) {
                            return parseMtl(mtlPath);
                        } else {
                            console.warn(`MTL file not found or error in parsing; proceeding without materials: ${mtlPath}`);
                            return {};
                        }
                    }).catch((error)=>{
                        console.warn(`Error loading MTL file: ${mtlPath}`, error);
                        return {};
                    }));
                }
            }
            try {
                const parsedMaterials = await Promise.all(parsedMaterialPromises);
                const materials = Object.assign({}, ...parsedMaterials);
                return materials;
            } catch (error) {
                return {};
            }
        }
        try {
            if (fileType.match(/\.stl$/i)) {
                const { data } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d2d$aAe5aq3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(path, 'arrayBuffer');
                parseSTL(model, data);
                if (normalize) {
                    model.normalize();
                }
                if (flipU) {
                    model.flipU();
                }
                if (flipV) {
                    model.flipV();
                }
                model._makeTriangleEdges();
                if (successCallback) {
                    return successCallback(model);
                } else {
                    return model;
                }
            } else if (fileType.match(/\.obj$/i)) {
                const { data } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d2d$aAe5aq3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(path, 'text');
                const lines = data.split('\n');
                const parsedMaterials = await getMaterials(lines);
                parseObj(model, lines, parsedMaterials);
                if (normalize) {
                    model.normalize();
                }
                if (flipU) {
                    model.flipU();
                }
                if (flipV) {
                    model.flipV();
                }
                model._makeTriangleEdges();
                if (successCallback) {
                    return successCallback(model);
                } else {
                    return model;
                }
            }
        } catch (err) {
            p51._friendlyFileLoadError(3, path);
            if (failureCallback) {
                return failureCallback(err);
            } else {
                throw err;
            }
        }
    };
    /**
   * @private
   */ async function parseMtl(mtlPath) {
        let currentMaterial = null;
        let materials = {};
        const { data } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d2d$aAe5aq3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(mtlPath, "text");
        const lines = data.split('\n');
        for(let line = 0; line < lines.length; ++line){
            const tokens = lines[line].trim().split(/\s+/);
            if (tokens[0] === 'newmtl') {
                const materialName = tokens[1];
                currentMaterial = materialName;
                materials[currentMaterial] = {};
            } else if (tokens[0] === 'Kd') {
                //Diffuse color
                materials[currentMaterial].diffuseColor = [
                    parseFloat(tokens[1]),
                    parseFloat(tokens[2]),
                    parseFloat(tokens[3])
                ];
            } else if (tokens[0] === 'Ka') {
                //Ambient Color
                materials[currentMaterial].ambientColor = [
                    parseFloat(tokens[1]),
                    parseFloat(tokens[2]),
                    parseFloat(tokens[3])
                ];
            } else if (tokens[0] === 'Ks') {
                //Specular color
                materials[currentMaterial].specularColor = [
                    parseFloat(tokens[1]),
                    parseFloat(tokens[2]),
                    parseFloat(tokens[3])
                ];
            } else if (tokens[0] === 'map_Kd') {
                //Texture path
                materials[currentMaterial].texturePath = tokens[1];
            }
        }
        return materials;
    }
    /**
   * @private
   * Parse OBJ lines into model. For reference, this is what a simple model of a
   * square might look like:
   *
   * v -0.5 -0.5 0.5
   * v -0.5 -0.5 -0.5
   * v -0.5 0.5 -0.5
   * v -0.5 0.5 0.5
   *
   * f 4 3 2 1
   */ function parseObj(model, lines, materials = {}) {
        // OBJ allows a face to specify an index for a vertex (in the above example),
        // but it also allows you to specify a custom combination of vertex, UV
        // coordinate, and vertex normal. So, "3/4/3" would mean, "use vertex 3 with
        // UV coordinate 4 and vertex normal 3". In WebGL, every vertex with different
        // parameters must be a different vertex, so loadedVerts is used to
        // temporarily store the parsed vertices, normals, etc., and indexedVerts is
        // used to map a specific combination (keyed on, for example, the string
        // "3/4/3"), to the actual index of the newly created vertex in the final
        // object.
        const loadedVerts = {
            v: [],
            vt: [],
            vn: []
        };
        // Map from source index → Map of material → destination index
        const usedVerts = {}; // Track colored vertices
        let currentMaterial = null;
        let hasColoredVertices = false;
        let hasColorlessVertices = false;
        for(let line = 0; line < lines.length; ++line){
            // Each line is a separate object (vertex, face, vertex normal, etc)
            // For each line, split it into tokens on whitespace. The first token
            // describes the type.
            const tokens = lines[line].trim().split(/\b\s+/);
            if (tokens.length > 0) {
                if (tokens[0] === 'usemtl') {
                    // Switch to a new material
                    currentMaterial = tokens[1];
                } else if (tokens[0] === 'v' || tokens[0] === 'vn') {
                    // Check if this line describes a vertex or vertex normal.
                    // It will have three numeric parameters.
                    const vertex = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"](parseFloat(tokens[1]), parseFloat(tokens[2]), parseFloat(tokens[3]));
                    loadedVerts[tokens[0]].push(vertex);
                } else if (tokens[0] === 'vt') {
                    // Check if this line describes a texture coordinate.
                    // It will have two numeric parameters U and V (W is omitted).
                    // Because of WebGL texture coordinates rendering behaviour, the V
                    // coordinate is inversed.
                    const texVertex = [
                        parseFloat(tokens[1]),
                        1 - parseFloat(tokens[2])
                    ];
                    loadedVerts[tokens[0]].push(texVertex);
                } else if (tokens[0] === 'f') {
                    // Check if this line describes a face.
                    // OBJ faces can have more than three points. Triangulate points.
                    for(let tri = 3; tri < tokens.length; ++tri){
                        const face = [];
                        const vertexTokens = [
                            1,
                            tri - 1,
                            tri
                        ];
                        for(let tokenInd = 0; tokenInd < vertexTokens.length; ++tokenInd){
                            // Now, convert the given token into an index
                            const vertString = tokens[vertexTokens[tokenInd]];
                            let vertParts = vertString.split('/');
                            // TODO: Faces can technically use negative numbers to refer to the
                            // previous nth vertex. I haven't seen this used in practice, but
                            // it might be good to implement this in the future.
                            for(let i = 0; i < vertParts.length; i++){
                                vertParts[i] = parseInt(vertParts[i]) - 1;
                            }
                            if (!usedVerts[vertString]) {
                                usedVerts[vertString] = {};
                            }
                            if (usedVerts[vertString][currentMaterial] === undefined) {
                                const vertIndex = model.vertices.length;
                                model.vertices.push(loadedVerts.v[vertParts[0]].copy());
                                model.uvs.push(loadedVerts.vt[vertParts[1]] ? loadedVerts.vt[vertParts[1]].slice() : [
                                    0,
                                    0
                                ]);
                                model.vertexNormals.push(loadedVerts.vn[vertParts[2]] ? loadedVerts.vn[vertParts[2]].copy() : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"]());
                                usedVerts[vertString][currentMaterial] = vertIndex;
                                face.push(vertIndex);
                                if (currentMaterial && materials[currentMaterial] && materials[currentMaterial].diffuseColor) {
                                    hasColoredVertices = true;
                                    const materialDiffuseColor = materials[currentMaterial].diffuseColor;
                                    model.vertexColors.push(materialDiffuseColor[0]);
                                    model.vertexColors.push(materialDiffuseColor[1]);
                                    model.vertexColors.push(materialDiffuseColor[2]);
                                    model.vertexColors.push(1);
                                } else {
                                    hasColorlessVertices = true;
                                }
                            } else {
                                face.push(usedVerts[vertString][currentMaterial]);
                            }
                        }
                        if (face[0] !== face[1] && face[0] !== face[2] && face[1] !== face[2]) {
                            model.faces.push(face);
                        }
                    }
                }
            }
        }
        // If the model doesn't have normals, compute the normals
        if (model.vertexNormals.length === 0) {
            model.computeNormals();
        }
        if (hasColoredVertices === hasColorlessVertices) {
            // If both are true or both are false, throw an error because the model is inconsistent
            throw new Error('Model coloring is inconsistent. Either all vertices should have colors or none should.');
        }
        return model;
    }
    /**
   * @private
   * STL files can be of two types, ASCII and Binary,
   *
   * We need to convert the arrayBuffer to an array of strings,
   * to parse it as an ASCII file.
   */ function parseSTL(model, buffer) {
        if (isBinary(buffer)) {
            parseBinarySTL(model, buffer);
        } else {
            const reader = new DataView(buffer);
            if (!('TextDecoder' in window)) {
                console.warn('Sorry, ASCII STL loading only works in browsers that support TextDecoder (https://caniuse.com/#feat=textencoder)');
                return model;
            }
            const decoder = new TextDecoder('utf-8');
            const lines = decoder.decode(reader);
            const lineArray = lines.split('\n');
            parseASCIISTL(model, lineArray);
        }
        return model;
    }
    /**
   * @private
   * This function checks if the file is in ASCII format or in Binary format
   *
   * It is done by searching keyword `solid` at the start of the file.
   *
   * An ASCII STL data must begin with `solid` as the first six bytes.
   * However, ASCII STLs lacking the SPACE after the `d` are known to be
   * plentiful. So, check the first 5 bytes for `solid`.
   *
   * Several encodings, such as UTF-8, precede the text with up to 5 bytes:
   * https://en.wikipedia.org/wiki/Byte_order_mark#Byte_order_marks_by_encoding
   * Search for `solid` to start anywhere after those prefixes.
   */ function isBinary(data) {
        const reader = new DataView(data);
        // US-ASCII ordinal values for `s`, `o`, `l`, `i`, `d`
        const solid = [
            115,
            111,
            108,
            105,
            100
        ];
        for(let off = 0; off < 5; off++){
            // If "solid" text is matched to the current offset, declare it to be an ASCII STL.
            if (matchDataViewAt(solid, reader, off)) return false;
        }
        // Couldn't find "solid" text at the beginning; it is binary STL.
        return true;
    }
    /**
   * @private
   * This function matches the `query` at the provided `offset`
   */ function matchDataViewAt(query, reader, offset) {
        // Check if each byte in query matches the corresponding byte from the current offset
        for(let i = 0, il = query.length; i < il; i++){
            if (query[i] !== reader.getUint8(offset + i, false)) return false;
        }
        return true;
    }
    /**
   * @private
   * This function parses the Binary STL files.
   * https://en.wikipedia.org/wiki/STL_%28file_format%29#Binary_STL
   *
   * Currently there is no support for the colors provided in STL files.
   */ function parseBinarySTL(model, buffer) {
        const reader = new DataView(buffer);
        // Number of faces is present following the header
        const faces = reader.getUint32(80, true);
        let r, g, b, hasColors = false, colors;
        let defaultR, defaultG, defaultB;
        // Binary files contain 80-byte header, which is generally ignored.
        for(let index = 0; index < 80 - 10; index++){
            // Check for `COLOR=`
            if (reader.getUint32(index, false) === 0x434f4c4f /*COLO*/  && reader.getUint8(index + 4) === 0x52 /*'R'*/  && reader.getUint8(index + 5) === 0x3d /*'='*/ ) {
                hasColors = true;
                colors = [];
                defaultR = reader.getUint8(index + 6) / 255;
                defaultG = reader.getUint8(index + 7) / 255;
                defaultB = reader.getUint8(index + 8) / 255;
            // To be used when color support is added
            // alpha = reader.getUint8(index + 9) / 255;
            }
        }
        const dataOffset = 84;
        const faceLength = 12 * 4 + 2;
        // Iterate the faces
        for(let face = 0; face < faces; face++){
            const start = dataOffset + face * faceLength;
            const normalX = reader.getFloat32(start, true);
            const normalY = reader.getFloat32(start + 4, true);
            const normalZ = reader.getFloat32(start + 8, true);
            if (hasColors) {
                const packedColor = reader.getUint16(start + 48, true);
                if ((packedColor & 0x8000) === 0) {
                    // facet has its own unique color
                    r = (packedColor & 0x1f) / 31;
                    g = (packedColor >> 5 & 0x1f) / 31;
                    b = (packedColor >> 10 & 0x1f) / 31;
                } else {
                    r = defaultR;
                    g = defaultG;
                    b = defaultB;
                }
            }
            const newNormal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"](normalX, normalY, normalZ);
            for(let i = 1; i <= 3; i++){
                const vertexstart = start + i * 12;
                const newVertex = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"](reader.getFloat32(vertexstart, true), reader.getFloat32(vertexstart + 4, true), reader.getFloat32(vertexstart + 8, true));
                model.vertices.push(newVertex);
                model.vertexNormals.push(newNormal);
                if (hasColors) {
                    colors.push(r, g, b);
                }
            }
            model.faces.push([
                3 * face,
                3 * face + 1,
                3 * face + 2
            ]);
            model.uvs.push([
                0,
                0
            ], [
                0,
                0
            ], [
                0,
                0
            ]);
        }
        return model;
    }
    /**
   * @private
   * ASCII STL file starts with `solid 'nameOfFile'`
   * Then contain the normal of the face, starting with `facet normal`
   * Next contain a keyword indicating the start of face vertex, `outer loop`
   * Next comes the three vertex, starting with `vertex x y z`
   * Vertices ends with `endloop`
   * Face ends with `endfacet`
   * Next face starts with `facet normal`
   * The end of the file is indicated by `endsolid`
   */ function parseASCIISTL(model, lines) {
        let state = '';
        let curVertexIndex = [];
        let newNormal, newVertex;
        for(let iterator = 0; iterator < lines.length; ++iterator){
            const line = lines[iterator].trim();
            const parts = line.split(' ');
            for(let partsiterator = 0; partsiterator < parts.length; ++partsiterator){
                if (parts[partsiterator] === '') {
                    // Ignoring multiple whitespaces
                    parts.splice(partsiterator, 1);
                }
            }
            if (parts.length === 0) {
                continue;
            }
            switch(state){
                case '':
                    if (parts[0] !== 'solid') {
                        // Invalid state
                        console.error(line);
                        console.error(`Invalid state "${parts[0]}", should be "solid"`);
                        return;
                    } else {
                        state = 'solid';
                    }
                    break;
                case 'solid':
                    if (parts[0] !== 'facet' || parts[1] !== 'normal') {
                        // Invalid state
                        console.error(line);
                        console.error(`Invalid state "${parts[0]}", should be "facet normal"`);
                        return;
                    } else {
                        // Push normal for first face
                        newNormal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"](parseFloat(parts[2]), parseFloat(parts[3]), parseFloat(parts[4]));
                        model.vertexNormals.push(newNormal, newNormal, newNormal);
                        state = 'facet normal';
                    }
                    break;
                case 'facet normal':
                    if (parts[0] !== 'outer' || parts[1] !== 'loop') {
                        // Invalid State
                        console.error(line);
                        console.error(`Invalid state "${parts[0]}", should be "outer loop"`);
                        return;
                    } else {
                        // Next should be vertices
                        state = 'vertex';
                    }
                    break;
                case 'vertex':
                    if (parts[0] === 'vertex') {
                        //Vertex of triangle
                        newVertex = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"](parseFloat(parts[1]), parseFloat(parts[2]), parseFloat(parts[3]));
                        model.vertices.push(newVertex);
                        model.uvs.push([
                            0,
                            0
                        ]);
                        curVertexIndex.push(model.vertices.indexOf(newVertex));
                    } else if (parts[0] === 'endloop') {
                        // End of vertices
                        model.faces.push(curVertexIndex);
                        curVertexIndex = [];
                        state = 'endloop';
                    } else {
                        // Invalid State
                        console.error(line);
                        console.error(`Invalid state "${parts[0]}", should be "vertex" or "endloop"`);
                        return;
                    }
                    break;
                case 'endloop':
                    if (parts[0] !== 'endfacet') {
                        // End of face
                        console.error(line);
                        console.error(`Invalid state "${parts[0]}", should be "endfacet"`);
                        return;
                    } else {
                        state = 'endfacet';
                    }
                    break;
                case 'endfacet':
                    if (parts[0] === 'endsolid') ;
                    else if (parts[0] === 'facet' && parts[1] === 'normal') {
                        // Next face
                        newNormal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"](parseFloat(parts[2]), parseFloat(parts[3]), parseFloat(parts[4]));
                        model.vertexNormals.push(newNormal, newNormal, newNormal);
                        state = 'facet normal';
                    } else {
                        // Invalid State
                        console.error(line);
                        console.error(`Invalid state "${parts[0]}", should be "endsolid" or "facet normal"`);
                        return;
                    }
                    break;
                default:
                    console.error(`Invalid state "${state}"`);
                    break;
            }
        }
        return model;
    }
    /**
   * Draws a <a href="#/p5.Geometry">p5.Geometry</a> object to the canvas.
   *
   * The parameter, `model`, is the
   * <a href="#/p5.Geometry">p5.Geometry</a> object to draw.
   * <a href="#/p5.Geometry">p5.Geometry</a> objects can be built with
   * <a href="#/p5/buildGeometry">buildGeometry()</a>, or
   * <a href="#/p5/beginGeometry">beginGeometry()</a> and
   * <a href="#/p5/endGeometry">endGeometry()</a>. They can also be loaded from
   * a file with <a href="#/p5/loadGeometry">loadGeometry()</a>.
   *
   * Note: `model()` can only be used in WebGL mode.
   *
   * @method model
   * @param  {p5.Geometry} model 3D shape to be drawn.
   *
   * @example
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let shape;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create the p5.Geometry object.
   *   shape = buildGeometry(createShape);
   *
   *   describe('A white cone drawn on a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Draw the p5.Geometry object.
   *   model(shape);
   * }
   *
   * // Create p5.Geometry object from a single cone.
   * function createShape() {
   *   cone();
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let shape;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create the p5.Geometry object.
   *   shape = buildGeometry(createArrow);
   *
   *   describe('Two white arrows drawn on a gray background. The arrow on the right rotates slowly.');
   * }
   *
   * function draw() {
   *   background(50);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Turn on the lights.
   *   lights();
   *
   *   // Style the arrows.
   *   noStroke();
   *
   *   // Draw the p5.Geometry object.
   *   model(shape);
   *
   *   // Translate and rotate the coordinate system.
   *   translate(30, 0, 0);
   *   rotateZ(frameCount * 0.01);
   *
   *   // Draw the p5.Geometry object again.
   *   model(shape);
   * }
   *
   * function createArrow() {
   *   // Add shapes to the p5.Geometry object.
   *   push();
   *   rotateX(PI);
   *   cone(10);
   *   translate(0, -10, 0);
   *   cylinder(3, 20);
   *   pop();
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let shape;
   *
   * async function setup() {
   *   shape = await loadModel('assets/octahedron.obj');
   *
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe('A white octahedron drawn against a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Draw the shape.
   *   model(shape);
   * }
   * </code>
   * </div>
   */ fn.model = function(model, count = 1) {
        this._assert3d('model');
        // p5._validateParameters('model', arguments);
        this._renderer.model(model, count);
    };
    /**
   * Load a 3d model from an OBJ or STL string.
   *
   * OBJ and STL files lack a built-in sense of scale, causing models exported from different programs to vary in size.
   * If your model doesn't display correctly, consider using `loadModel()` with `normalize` set to `true` to standardize its size.
   * Further adjustments can be made using the `scale()` function.
   *
   * Also, the support for colored STL files is not present. STL files with color will be
   * rendered without color properties.
   *
   * * Options can include:
   * - `modelString`: Specifies the plain text string of either an stl or obj file to be loaded.
   * - `fileType`: Defines the file extension of the model.
   * - `normalize`: Enables standardized size scaling during loading if set to true.
   * - `successCallback`: Callback for post-loading actions with the 3D model object.
   * - `failureCallback`: Handles errors if model loading fails, receiving an event error.
   * - `flipU`: Flips the U texture coordinates of the model.
   * - `flipV`: Flips the V texture coordinates of the model.
   *
   *
   * @method createModel
   * @param  {String} modelString         String of the object to be loaded
   * @param  {String} [fileType]          The file extension of the model
   *                                      (<code>.stl</code>, <code>.obj</code>).
   * @param  {Boolean} normalize        If true, scale the model to a
   *                                      standardized size when loading
   * @param  {function(p5.Geometry)} [successCallback] Function to be called
   *                                     once the model is loaded. Will be passed
   *                                     the 3D model object.
   * @param  {function(Event)} [failureCallback] called with event error if
   *                                         the model fails to load.
   * @return {p5.Geometry} the <a href="#/p5.Geometry">p5.Geometry</a> object
   *
   * @example
   * <div>
   * <code>
   * const octahedron_model = `
   * v 0.000000E+00 0.000000E+00 40.0000
   * v 22.5000 22.5000 0.000000E+00
   * v 22.5000 -22.5000 0.000000E+00
   * v -22.5000 -22.5000 0.000000E+00
   * v -22.5000 22.5000 0.000000E+00
   * v 0.000000E+00 0.000000E+00 -40.0000
   * f     1 2 3
   * f     1 3 4
   * f     1 4 5
   * f     1 5 2
   * f     6 5 4
   * f     6 4 3
   * f     6 3 2
   * f     6 2 5
   * `;
   * //draw a spinning octahedron
   * let octahedron;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *   octahedron = createModel(octahedron_model, '.obj');
   *   describe('Vertically rotating 3D octahedron.');
   * }
   *
   * function draw() {
   *   background(200);
   *   rotateX(frameCount * 0.01);
   *   rotateY(frameCount * 0.01);
   *   model(octahedron);
   *}
   * </code>
   * </div>
   */ /**
   * @method createModel
   * @param  {String} modelString
   * @param  {String} [fileType]
   * @param  {function(p5.Geometry)} [successCallback]
   * @param  {function(Event)} [failureCallback]
   * @return {p5.Geometry} the <a href="#/p5.Geometry">p5.Geometry</a> object
   */ /**
   * @method createModel
   * @param  {String} modelString
   * @param  {String} [fileType]
   * @param  {Object} [options]
   * @param  {function(p5.Geometry)} [options.successCallback]
   * @param  {function(Event)} [options.failureCallback]
   * @param  {boolean} [options.normalize]
   * @param  {boolean} [options.flipU]
   * @param  {boolean} [options.flipV]
   * @return {p5.Geometry} the <a href="#/p5.Geometry">p5.Geometry</a> object
   */ let modelCounter = 0;
    fn.createModel = function(modelString, fileType = ' ', options) {
        // p5._validateParameters('createModel', arguments);
        let normalize = false;
        let successCallback;
        let failureCallback;
        let flipU = false;
        let flipV = false;
        if (options && typeof options === 'object') {
            normalize = options.normalize || false;
            successCallback = options.successCallback;
            failureCallback = options.failureCallback;
            flipU = options.flipU || false;
            flipV = options.flipV || false;
        } else if (typeof options === 'boolean') {
            normalize = options;
            successCallback = arguments[3];
            failureCallback = arguments[4];
        } else {
            successCallback = typeof arguments[2] === 'function' ? arguments[2] : undefined;
            failureCallback = arguments[3];
        }
        const model = new p51.Geometry();
        model.gid = `${fileType}|${normalize}|${modelCounter++}`;
        if (fileType.match(/\.stl$/i)) {
            try {
                let uint8array = new TextEncoder().encode(modelString);
                let arrayBuffer = uint8array.buffer;
                parseSTL(model, arrayBuffer);
            } catch (error) {
                if (failureCallback) {
                    failureCallback(error);
                } else {
                    p51._friendlyError('Error during parsing: ' + error.message);
                }
                return;
            }
        } else if (fileType.match(/\.obj$/i)) {
            try {
                const lines = modelString.split('\n');
                parseObj(model, lines);
            } catch (error) {
                if (failureCallback) {
                    failureCallback(error);
                } else {
                    p51._friendlyError('Error during parsing: ' + error.message);
                }
                return;
            }
        } else {
            p51._friendlyFileLoadError(3, modelString);
            if (failureCallback) {
                failureCallback();
            } else {
                p51._friendlyError('Sorry, the file type is invalid. Only OBJ and STL files are supported.');
            }
        }
        if (normalize) {
            model.normalize();
        }
        if (flipU) {
            model.flipU();
        }
        if (flipV) {
            model.flipV();
        }
        model._makeTriangleEdges();
        if (typeof successCallback === 'function') {
            successCallback(model);
        }
        return model;
    };
}
if (typeof p5 !== 'undefined') {
    loading(p5, p5.prototype);
}
;
}}),
"[project]/node_modules/p5/dist/webgl/text.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>text)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$C$2d$g_eAdC$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/constants-C-g_eAdC.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d2d$aAe5aq3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/rendering--aAe5aq3.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Vector.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.Geometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$p5$2e$Font$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/type/p5.Font.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$creating_reading$2d$D4AAKRbx$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/creating_reading-D4AAKRbx.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$color$2f$color_spaces$2f$hsb$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/color/color_spaces/hsb.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$dom$2f$p5$2e$Element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/dom/p5.Element.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$dom$2f$p5$2e$File$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/dom/p5.File.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$p5$2e$XML$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/p5.XML.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/p5.Renderer-CwAYZOC2.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$filters$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/filters.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$custom_shapes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/custom_shapes.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$States$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/States.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/utilities.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$file$2d$saver$2f$FileSaver$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/file-saver/FileSaver.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$dom$2f$p5$2e$MediaElement$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/dom/p5.MediaElement.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$2d_primitives$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/2d_primitives.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$helpers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/helpers.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$attributes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/attributes.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$curves$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/curves.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$vertex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/vertex.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$color$2f$setting$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/color/setting.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$omggif$2f$omggif$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/omggif/omggif.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$csv$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/csv.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$gifenc$2f$dist$2f$gifenc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/gifenc/dist/gifenc.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$pixels$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/pixels.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$transform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/transform.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$GeometryBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/GeometryBuilder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Matrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Matrix.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$Matrices$2f$Matrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/Matrices/Matrix.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$Matrices$2f$MatrixInterface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/Matrices/MatrixInterface.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$Quat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.Quat.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$RenderBuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.RenderBuffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$DataArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.DataArray.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$ShapeBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/ShapeBuilder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libtess$2f$libtess$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libtess/libtess.min.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$GeometryBufferCache$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/GeometryBufferCache.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$const$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/const.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$trigonometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/trigonometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$textCore$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/type/textCore.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$japont$2f$unicode$2d$range$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@japont/unicode-range/lib/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$unicodeRanges$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/type/unicodeRanges.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$lib$2f$Typr$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/type/lib/Typr.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pako$2f$dist$2f$pako$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pako/dist/pako.esm.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$davepagurek$2f$bezier$2d$path$2f$build$2f$bezier$2d$path$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@davepagurek/bezier-path/build/bezier-path.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
function text(p5, fn) {
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d2d$aAe5aq3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["R"].prototype.maxCachedGlyphs = function() {
        // TODO: use more than vibes to find a good value for this
        return 200;
    };
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d2d$aAe5aq3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["R"].prototype.freeGlyphInfo = function(gi) {
        const datas = [
            gi.strokeImageInfo.imageData,
            gi.rowInfo.cellImageInfo.imageData,
            gi.rowInfo.dimImageInfo.imageData,
            gi.colInfo.cellImageInfo.imageData,
            gi.colInfo.dimImageInfo.imageData
        ];
        for (const data of datas){
            const tex = this.textures.get(data);
            if (tex) {
                tex.remove();
                this.textures.delete(data);
            }
        }
    };
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$p5$2e$Font$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Font"].prototype._getFontInfo = function(axs) {
        // For WebGL, a cache of font data to use on the GPU.
        this._fontInfos = this._fontInfos || {};
        const key = JSON.stringify(axs);
        if (this._fontInfos[key]) {
            const val = this._fontInfos[key];
            return val;
        } else {
            const val = new FontInfo(this, {
                axs
            });
            this._fontInfos[key] = val;
            return val;
        }
    };
    // Text/Typography (see src/type/textCore.js)
    /*
  RendererGL.prototype.textWidth = function(s) {
    if (this._isOpenType()) {
      return this.states.textFont.font._textWidth(s, this.states.textSize);
    }

    return 0; // TODO: error
  };
  */ // rendering constants
    // the number of rows/columns dividing each glyph
    const charGridWidth = 9;
    const charGridHeight = charGridWidth;
    // size of the image holding the bezier stroke info
    const strokeImageWidth = 64;
    const strokeImageHeight = 64;
    // size of the image holding the stroke indices for each row/col
    const gridImageWidth = 64;
    const gridImageHeight = 64;
    // size of the image holding the offset/length of each row/col stripe
    const cellImageWidth = 64;
    const cellImageHeight = 64;
    /**
   * @private
   * @class ImageInfos
   * @param {Integer} width
   * @param {Integer} height
   *
   * the ImageInfos class holds a list of ImageDatas of a given size.
   */ class ImageInfos {
        constructor(width, height){
            this.width = width;
            this.height = height;
            this.infos = []; // the list of images
        }
        /**
     *
     * @param {Integer} space
     * @return {Object} contains the ImageData, and pixel index into that
     *                  ImageData where the free space was allocated.
     *
     * finds free space of a given size in the ImageData list
     */ findImage(space) {
            const imageSize = this.width * this.height;
            if (space > imageSize) throw new Error("font is too complex to render in 3D");
            // search through the list of images, looking for one with
            // anough unused space.
            let imageInfo, imageData;
            for(let ii = this.infos.length - 1; ii >= 0; --ii){
                const imageInfoTest = this.infos[ii];
                if (imageInfoTest.index + space < imageSize) {
                    // found one
                    imageInfo = imageInfoTest;
                    imageData = imageInfoTest.imageData;
                    break;
                }
            }
            if (!imageInfo) {
                try {
                    // create a new image
                    imageData = new ImageData(this.width, this.height);
                } catch (err) {
                    // for browsers that don't support ImageData constructors (ie IE11)
                    // create an ImageData using the old method
                    let canvas = document.getElementsByTagName("canvas")[0];
                    const created = !canvas;
                    if (!canvas) {
                        // create a temporary canvas
                        canvas = document.createElement("canvas");
                        canvas.style.display = "none";
                        document.body.appendChild(canvas);
                    }
                    const ctx = canvas.getContext("2d");
                    if (ctx) {
                        imageData = ctx.createImageData(this.width, this.height);
                    }
                    if (created) {
                        // distroy the temporary canvas, if necessary
                        document.body.removeChild(canvas);
                    }
                }
                // construct & dd the new image info
                imageInfo = {
                    index: 0,
                    imageData
                };
                this.infos.push(imageInfo);
            }
            const index = imageInfo.index;
            imageInfo.index += space; // move to the start of the next image
            imageData._dirty = true;
            return {
                imageData,
                index
            };
        }
    }
    /**
   * @function setPixel
   * @param {Object} imageInfo
   * @param {Number} r
   * @param {Number} g
   * @param {Number} b
   * @param {Number} a
   *
   * writes the next pixel into an indexed ImageData
   */ function setPixel(imageInfo, r, g, b, a) {
        const imageData = imageInfo.imageData;
        const pixels = imageData.data;
        let index = imageInfo.index++ * 4;
        pixels[index++] = r;
        pixels[index++] = g;
        pixels[index++] = b;
        pixels[index++] = a;
    }
    const SQRT3 = Math.sqrt(3);
    /**
   * @private
   * @class FontInfo
   * @param {Object} font an opentype.js font object
   *
   * contains cached images and glyph information for an opentype font
   */ class FontInfo {
        constructor(font, { axs } = {}){
            this.font = font;
            this.axs = axs;
            // the bezier curve coordinates
            this.strokeImageInfos = new ImageInfos(strokeImageWidth, strokeImageHeight);
            // lists of curve indices for each row/column slice
            this.colDimImageInfos = new ImageInfos(gridImageWidth, gridImageHeight);
            this.rowDimImageInfos = new ImageInfos(gridImageWidth, gridImageHeight);
            // the offset & length of each row/col slice in the glyph
            this.colCellImageInfos = new ImageInfos(cellImageWidth, cellImageHeight);
            this.rowCellImageInfos = new ImageInfos(cellImageWidth, cellImageHeight);
            // the cached information for each glyph
            this.glyphInfos = {};
        }
        /**
     * @param {Glyph} glyph the x positions of points in the curve
     * @returns {Object} the glyphInfo for that glyph
     *
     * calculates rendering info for a glyph, including the curve information,
     * row & column stripes compiled into textures.
     */ getGlyphInfo(glyph) {
            // check the cache
            let gi = this.glyphInfos[glyph.index];
            if (gi) return gi;
            const axs = this.axs;
            const { glyph: { path: { commands } } } = this.font._singleShapeToPath(glyph.shape, {
                axs
            });
            let xMin = Infinity;
            let xMax = -Infinity;
            let yMin = Infinity;
            let yMax = -Infinity;
            for (const cmd of commands){
                for(let i = 1; i < cmd.length; i += 2){
                    xMin = Math.min(xMin, cmd[i]);
                    xMax = Math.max(xMax, cmd[i]);
                    yMin = Math.min(yMin, cmd[i + 1]);
                    yMax = Math.max(yMax, cmd[i + 1]);
                }
            }
            // don't bother rendering invisible glyphs
            if (xMin >= xMax || yMin >= yMax || !commands.length) {
                return this.glyphInfos[glyph.index] = {};
            }
            const gWidth = xMax - xMin;
            const gHeight = yMax - yMin;
            // Convert arrays to named objects
            const cmds = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$p5$2e$Font$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayCommandsToObjects"])(commands);
            let i;
            const strokes = []; // the strokes in this glyph
            const rows = []; // the indices of strokes in each row
            const cols = []; // the indices of strokes in each column
            for(i = charGridWidth - 1; i >= 0; --i)cols.push([]);
            for(i = charGridHeight - 1; i >= 0; --i)rows.push([]);
            /**
       * @function push
       * @param {Number[]} xs the x positions of points in the curve
       * @param {Number[]} ys the y positions of points in the curve
       * @param {Object} v    the curve information
       *
       * adds a curve to the rows & columns that it intersects with
       */ function push(xs, ys, v) {
                const index = strokes.length; // the index of this stroke
                strokes.push(v); // add this stroke to the list
                /**
         * @function minMax
         * @param {Number[]} rg the list of values to compare
         * @param {Number} min the initial minimum value
         * @param {Number} max the initial maximum value
         *
         * find the minimum & maximum value in a list of values
         */ function minMax(rg, min, max) {
                    for(let i = rg.length; i-- > 0;){
                        const v = rg[i];
                        if (min > v) min = v;
                        if (max < v) max = v;
                    }
                    return {
                        min,
                        max
                    };
                }
                // Expand the bounding box of the glyph by the number of cells below
                // before rounding. Curves only partially through a cell won't be added
                // to adjacent cells, but ones that are close will be. This helps fix
                // small visual glitches that occur when curves are close to grid cell
                // boundaries.
                const cellOffset = 0.5;
                // loop through the rows & columns that the curve intersects
                // adding the curve to those slices
                const mmX = minMax(xs, 1, 0);
                const ixMin = Math.max(Math.floor(mmX.min * charGridWidth - cellOffset), 0);
                const ixMax = Math.min(Math.ceil(mmX.max * charGridWidth + cellOffset), charGridWidth);
                for(let iCol = ixMin; iCol < ixMax; ++iCol)cols[iCol].push(index);
                const mmY = minMax(ys, 1, 0);
                const iyMin = Math.max(Math.floor(mmY.min * charGridHeight - cellOffset), 0);
                const iyMax = Math.min(Math.ceil(mmY.max * charGridHeight + cellOffset), charGridHeight);
                for(let iRow = iyMin; iRow < iyMax; ++iRow)rows[iRow].push(index);
            }
            /**
       * @function clamp
       * @param {Number} v the value to clamp
       * @param {Number} min the minimum value
       * @param {Number} max the maxmimum value
       *
       * clamps a value between a minimum & maximum value
       */ function clamp(v, min, max) {
                if (v < min) return min;
                if (v > max) return max;
                return v;
            }
            /**
       * @function byte
       * @param {Number} v the value to scale
       *
       * converts a floating-point number in the range 0-1 to a byte 0-255
       */ function byte(v) {
                return clamp(255 * v, 0, 255);
            }
            /**
       * @private
       * @class Cubic
       * @param {Number} p0 the start point of the curve
       * @param {Number} c0 the first control point
       * @param {Number} c1 the second control point
       * @param {Number} p1 the end point
       *
       * a cubic curve
       */ class Cubic {
                constructor(p0, c0, c1, p1){
                    this.p0 = p0;
                    this.c0 = c0;
                    this.c1 = c1;
                    this.p1 = p1;
                }
                /**
         * @return {Object} the quadratic approximation
         *
         * converts the cubic to a quadtratic approximation by
         * picking an appropriate quadratic control point
         */ toQuadratic() {
                    return {
                        x: this.p0.x,
                        y: this.p0.y,
                        x1: this.p1.x,
                        y1: this.p1.y,
                        cx: ((this.c0.x + this.c1.x) * 3 - (this.p0.x + this.p1.x)) / 4,
                        cy: ((this.c0.y + this.c1.y) * 3 - (this.p0.y + this.p1.y)) / 4
                    };
                }
                /**
         * @return {Number} the error
         *
         * calculates the magnitude of error of this curve's
         * quadratic approximation.
         */ quadError() {
                    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"].sub(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"].sub(this.p1, this.p0), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"].mult(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"].sub(this.c1, this.c0), 3)).mag() / 2;
                }
                /**
         * @param {Number} t the value (0-1) at which to split
         * @return {Cubic} the second part of the curve
         *
         * splits the cubic into two parts at a point 't' along the curve.
         * this cubic keeps its start point and its end point becomes the
         * point at 't'. the 'end half is returned.
         */ split(t) {
                    const m1 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"].lerp(this.p0, this.c0, t);
                    const m2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"].lerp(this.c0, this.c1, t);
                    const mm1 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"].lerp(m1, m2, t);
                    this.c1 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"].lerp(this.c1, this.p1, t);
                    this.c0 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"].lerp(m2, this.c1, t);
                    const pt = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"].lerp(mm1, this.c0, t);
                    const part1 = new Cubic(this.p0, m1, mm1, pt);
                    this.p0 = pt;
                    return part1;
                }
                /**
         * @return {Cubic[]} the non-inflecting pieces of this cubic
         *
         * returns an array containing 0, 1 or 2 cubics split resulting
         * from splitting this cubic at its inflection points.
         * this cubic is (potentially) altered and returned in the list.
         */ splitInflections() {
                    const a = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"].sub(this.c0, this.p0);
                    const b = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"].sub(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"].sub(this.c1, this.c0), a);
                    const c = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"].sub(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"].sub(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"].sub(this.p1, this.c1), a), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"].mult(b, 2));
                    const cubics = [];
                    // find the derivative coefficients
                    let A = b.x * c.y - b.y * c.x;
                    if (A !== 0) {
                        let B = a.x * c.y - a.y * c.x;
                        let C = a.x * b.y - a.y * b.x;
                        const disc = B * B - 4 * A * C;
                        if (disc >= 0) {
                            if (A < 0) {
                                A = -A;
                                B = -B;
                                C = -C;
                            }
                            const Q = Math.sqrt(disc);
                            const t0 = (-B - Q) / (2 * A); // the first inflection point
                            let t1 = (-B + Q) / (2 * A); // the second inflection point
                            // test if the first inflection point lies on the curve
                            if (t0 > 0 && t0 < 1) {
                                // split at the first inflection point
                                cubics.push(this.split(t0));
                                // scale t2 into the second part
                                t1 = 1 - (1 - t1) / (1 - t0);
                            }
                            // test if the second inflection point lies on the curve
                            if (t1 > 0 && t1 < 1) {
                                // split at the second inflection point
                                cubics.push(this.split(t1));
                            }
                        }
                    }
                    cubics.push(this);
                    return cubics;
                }
            }
            /**
       * @function cubicToQuadratics
       * @param {Number} x0
       * @param {Number} y0
       * @param {Number} cx0
       * @param {Number} cy0
       * @param {Number} cx1
       * @param {Number} cy1
       * @param {Number} x1
       * @param {Number} y1
       * @returns {Cubic[]} an array of cubics whose quadratic approximations
       *                    closely match the civen cubic.
       *
       * converts a cubic curve to a list of quadratics.
       */ function cubicToQuadratics(x0, y0, cx0, cy0, cx1, cy1, x1, y1) {
                // create the Cubic object and split it at its inflections
                const cubics = new Cubic(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"](x0, y0), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"](cx0, cy0), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"](cx1, cy1), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"](x1, y1)).splitInflections();
                const qs = []; // the final list of quadratics
                const precision = 30 / SQRT3;
                // for each of the non-inflected pieces of the original cubic
                for (let cubic of cubics){
                    // the cubic is iteratively split in 3 pieces:
                    // the first piece is accumulated in 'qs', the result.
                    // the last piece is accumulated in 'tail', temporarily.
                    // the middle piece is repeatedly split again, while necessary.
                    const tail = [];
                    let t3;
                    for(;;){
                        // calculate this cubic's precision
                        t3 = precision / cubic.quadError();
                        if (t3 >= 0.5 * 0.5 * 0.5) {
                            break; // not too bad, we're done
                        }
                        // find a split point based on the error
                        const t = Math.pow(t3, 1.0 / 3.0);
                        // split the cubic in 3
                        const start = cubic.split(t);
                        const middle = cubic.split(1 - t / (1 - t));
                        qs.push(start); // the first part
                        tail.push(cubic); // the last part
                        cubic = middle; // iterate on the middle piece
                    }
                    if (t3 < 1) {
                        // a little excess error, split the middle in two
                        qs.push(cubic.split(0.5));
                    }
                    // add the middle piece to the result
                    qs.push(cubic);
                    // finally add the tail, reversed, onto the result
                    Array.prototype.push.apply(qs, tail.reverse());
                }
                return qs;
            }
            /**
       * @function pushLine
       * @param {Number} x0
       * @param {Number} y0
       * @param {Number} x1
       * @param {Number} y1
       *
       * add a straight line to the row/col grid of a glyph
       */ function pushLine(x0, y0, x1, y1) {
                const mx = (x0 + x1) / 2;
                const my = (y0 + y1) / 2;
                push([
                    x0,
                    x1
                ], [
                    y0,
                    y1
                ], {
                    x: x0,
                    y: y0,
                    cx: mx,
                    cy: my
                });
            }
            /**
       * @function samePoint
       * @param {Number} x0
       * @param {Number} y0
       * @param {Number} x1
       * @param {Number} y1
       * @return {Boolean} true if the two points are sufficiently close
       *
       * tests if two points are close enough to be considered the same
       */ function samePoint(x0, y0, x1, y1) {
                return Math.abs(x1 - x0) < 0.00001 && Math.abs(y1 - y0) < 0.00001;
            }
            let x0, y0, xs, ys;
            for (const cmd of cmds){
                // scale the coordinates to the range 0-1
                const x1 = (cmd.x - xMin) / gWidth;
                const y1 = (cmd.y - yMin) / gHeight;
                // don't bother if this point is the same as the last
                if (samePoint(x0, y0, x1, y1)) continue;
                switch(cmd.type){
                    case "M":
                        {
                            // move
                            xs = x1;
                            ys = y1;
                            break;
                        }
                    case "L":
                        {
                            // line
                            pushLine(x0, y0, x1, y1);
                            break;
                        }
                    case "Q":
                        {
                            // quadratic
                            const cx = (cmd.x1 - xMin) / gWidth;
                            const cy = (cmd.y1 - yMin) / gHeight;
                            push([
                                x0,
                                x1,
                                cx
                            ], [
                                y0,
                                y1,
                                cy
                            ], {
                                x: x0,
                                y: y0,
                                cx,
                                cy
                            });
                            break;
                        }
                    case "Z":
                        {
                            // end
                            if (!samePoint(x0, y0, xs, ys)) {
                                // add an extra line closing the loop, if necessary
                                pushLine(x0, y0, xs, ys);
                                strokes.push({
                                    x: xs,
                                    y: ys
                                });
                            } else {
                                strokes.push({
                                    x: x0,
                                    y: y0
                                });
                            }
                            break;
                        }
                    case "C":
                        {
                            // cubic
                            const cx1 = (cmd.x1 - xMin) / gWidth;
                            const cy1 = (cmd.y1 - yMin) / gHeight;
                            const cx2 = (cmd.x2 - xMin) / gWidth;
                            const cy2 = (cmd.y2 - yMin) / gHeight;
                            const qs = cubicToQuadratics(x0, y0, cx1, cy1, cx2, cy2, x1, y1);
                            for(let iq = 0; iq < qs.length; iq++){
                                const q = qs[iq].toQuadratic();
                                push([
                                    q.x,
                                    q.x1,
                                    q.cx
                                ], [
                                    q.y,
                                    q.y1,
                                    q.cy
                                ], q);
                            }
                            break;
                        }
                    default:
                        throw new Error(`unknown command type: ${cmd.type}`);
                }
                x0 = x1;
                y0 = y1;
            }
            // allocate space for the strokes
            const strokeCount = strokes.length;
            const strokeImageInfo = this.strokeImageInfos.findImage(strokeCount);
            const strokeOffset = strokeImageInfo.index;
            // fill the stroke image
            for(let il = 0; il < strokeCount; ++il){
                const s = strokes[il];
                setPixel(strokeImageInfo, byte(s.x), byte(s.y), byte(s.cx), byte(s.cy));
            }
            /**
       * @function layout
       * @param {Number[][]} dim
       * @param {ImageInfo[]} dimImageInfos
       * @param {ImageInfo[]} cellImageInfos
       * @return {Object}
       *
       * lays out the curves in a dimension (row or col) into two
       * images, one for the indices of the curves themselves, and
       * one containing the offset and length of those index spans.
       */ function layout(dim, dimImageInfos, cellImageInfos) {
                const dimLength = dim.length; // the number of slices in this dimension
                const dimImageInfo = dimImageInfos.findImage(dimLength);
                const dimOffset = dimImageInfo.index;
                // calculate the total number of stroke indices in this dimension
                let totalStrokes = 0;
                for(let id = 0; id < dimLength; ++id){
                    totalStrokes += dim[id].length;
                }
                // allocate space for the stroke indices
                const cellImageInfo = cellImageInfos.findImage(totalStrokes);
                // for each slice in the glyph
                for(let i = 0; i < dimLength; ++i){
                    const strokeIndices = dim[i];
                    const strokeCount = strokeIndices.length;
                    const cellLineIndex = cellImageInfo.index;
                    // write the offset and count into the glyph slice image
                    setPixel(dimImageInfo, cellLineIndex >> 7, cellLineIndex & 0x7f, strokeCount >> 7, strokeCount & 0x7f);
                    // for each stroke index in that slice
                    for(let iil = 0; iil < strokeCount; ++iil){
                        // write the stroke index into the slice's image
                        const strokeIndex = strokeIndices[iil] + strokeOffset;
                        setPixel(cellImageInfo, strokeIndex >> 7, strokeIndex & 0x7f, 0, 0);
                    }
                }
                return {
                    cellImageInfo,
                    dimOffset,
                    dimImageInfo
                };
            }
            // initialize the info for this glyph
            gi = this.glyphInfos[glyph.index] = {
                glyph,
                uGlyphRect: [
                    xMin,
                    yMin,
                    xMax,
                    yMax
                ],
                strokeImageInfo,
                strokes,
                colInfo: layout(cols, this.colDimImageInfos, this.colCellImageInfos),
                rowInfo: layout(rows, this.rowDimImageInfos, this.rowCellImageInfos)
            };
            gi.uGridOffset = [
                gi.colInfo.dimOffset,
                gi.rowInfo.dimOffset
            ];
            return gi;
        }
    }
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d2d$aAe5aq3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["R"].prototype._renderText = function(line, x, y, maxY, minY) {
        if (!this.states.textFont || typeof this.states.textFont === "string") {
            console.log("WEBGL: you must load and set a font before drawing text. See `loadFont` and `textFont` for more details.");
            return;
        }
        if (y >= maxY || !this.states.fillColor) {
            return; // don't render lines beyond our maxY position
        }
        if (!p5.Font.hasGlyphData(this.states.textFont)) {
            console.log("WEBGL: only Opentype (.otf) and Truetype (.ttf) fonts with glyph data are supported");
            return;
        }
        this.push(); // fix to #803
        // remember this state, so it can be restored later
        const doStroke = this.states.strokeColor;
        const drawMode = this.states.drawMode;
        this.states.setValue("strokeColor", null);
        this.states.setValue("drawMode", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$C$2d$g_eAdC$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"]);
        // get the cached FontInfo object
        const { font } = this.states.textFont;
        if (!font) {
            throw new Error("In WebGL mode, textFont() needs to be given the result of loadFont() instead of a font family name.");
        }
        const axs = font._currentAxes(this);
        let fontInfo = font._getFontInfo(axs);
        // calculate the alignment and move/scale the view accordingly
        // TODO: check this
        const pos = {
            x,
            y
        }; // this.states.textFont._handleAlignment(this, line, x, y);
        const fontSize = this.states.textSize;
        const scale = fontSize / (font.data?.head?.unitsPerEm || 1000);
        this.translate(pos.x, pos.y, 0);
        this.scale(scale, scale, 1);
        // initialize the font shader
        const gl = this.GL;
        const initializeShader = !this._defaultFontShader;
        const sh = this._getFontShader();
        sh.init();
        sh.bindShader(); // first time around, bind the shader fully
        if (initializeShader) {
            // these are constants, really. just initialize them one-time.
            sh.setUniform("uGridImageSize", [
                gridImageWidth,
                gridImageHeight
            ]);
            sh.setUniform("uCellsImageSize", [
                cellImageWidth,
                cellImageHeight
            ]);
            sh.setUniform("uStrokeImageSize", [
                strokeImageWidth,
                strokeImageHeight
            ]);
            sh.setUniform("uGridSize", [
                charGridWidth,
                charGridHeight
            ]);
        }
        const curFillColor = this.states.fillSet ? this.states.curFillColor : [
            0,
            0,
            0,
            255
        ];
        this._setGlobalUniforms(sh);
        this._applyColorBlend(curFillColor);
        let g = this.geometryBufferCache.getGeometryByID("glyph");
        if (!g) {
            // create the geometry for rendering a quad
            g = this._textGeom = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Geometry"](1, 1, function() {
                for(let i = 0; i <= 1; i++){
                    for(let j = 0; j <= 1; j++){
                        this.vertices.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"](j, i, 0));
                        this.uvs.push(j, i);
                    }
                }
            }, this);
            g.gid = "glyph";
            g.computeFaces().computeNormals();
            this.geometryBufferCache.ensureCached(g);
        }
        // bind the shader buffers
        for (const buff of this.buffers.text){
            buff._prepareBuffer(g, sh);
        }
        this._bindBuffer(this.geometryBufferCache.cache.glyph.indexBuffer, gl.ELEMENT_ARRAY_BUFFER);
        // this will have to do for now...
        sh.setUniform("uMaterialColor", curFillColor);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        this.fontCache = this.fontCache || new Map();
        try {
            // fetch the glyphs in the line of text
            const glyphs = font._positionGlyphs(line);
            for (const glyph of glyphs){
                const gi = fontInfo.getGlyphInfo(glyph);
                if (gi.uGlyphRect) {
                    const cacheKey = JSON.stringify({
                        font: font.id,
                        axs,
                        glyph: glyph.shape.g
                    });
                    // Bump this font to the end of the cache list by deleting and re-adding it
                    this.fontCache.delete(cacheKey);
                    this.fontCache.set(cacheKey, gi);
                    if (this.fontCache.size > this.maxCachedGlyphs()) {
                        const keyToRemove = this.fontCache.keys().next().value;
                        const val = this.fontCache.get(keyToRemove);
                        this.fontCache.delete(keyToRemove);
                        this.freeGlyphInfo(val);
                    }
                    const rowInfo = gi.rowInfo;
                    const colInfo = gi.colInfo;
                    sh.setUniform("uSamplerStrokes", gi.strokeImageInfo.imageData);
                    sh.setUniform("uSamplerRowStrokes", rowInfo.cellImageInfo.imageData);
                    sh.setUniform("uSamplerRows", rowInfo.dimImageInfo.imageData);
                    sh.setUniform("uSamplerColStrokes", colInfo.cellImageInfo.imageData);
                    sh.setUniform("uSamplerCols", colInfo.dimImageInfo.imageData);
                    sh.setUniform("uGridOffset", gi.uGridOffset);
                    sh.setUniform("uGlyphRect", gi.uGlyphRect);
                    sh.setUniform("uGlyphOffset", glyph.x);
                    sh.bindTextures(); // afterwards, only textures need updating
                    // draw it
                    gl.drawElements(gl.TRIANGLES, 6, this.GL.UNSIGNED_SHORT, 0);
                }
            }
        } finally{
            // clean up
            sh.unbindShader();
            this.states.setValue("strokeColor", doStroke);
            this.states.setValue("drawMode", drawMode);
            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
            this.pop();
        }
    };
}
;
}}),
"[project]/node_modules/p5/dist/webgl/ShaderGenerator.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>shadergenerator)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$acorn$2f$dist$2f$acorn$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/acorn/dist/acorn.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$acorn$2d$walk$2f$dist$2f$walk$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/acorn-walk/dist/walk.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$escodegen$2f$escodegen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/escodegen/escodegen.js [app-client] (ecmascript)");
;
;
;
/**
* @module 3D
* @submodule ShaderGenerator
* @for p5
* @requires core
*/ function shadergenerator(p51, fn) {
    let GLOBAL_SHADER;
    let BRANCH;
    const oldModify = p51.Shader.prototype.modify;
    p51.Shader.prototype.modify = function(shaderModifier, options = {
        parser: true,
        srcLocations: false
    }) {
        if (shaderModifier instanceof Function) {
            let generatorFunction;
            if (options.parser) {
                const sourceString = shaderModifier.toString();
                const ast = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$acorn$2f$dist$2f$acorn$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parse"])(sourceString, {
                    ecmaVersion: 2021,
                    locations: options.srcLocations
                });
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$acorn$2d$walk$2f$dist$2f$walk$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ancestor"])(ast, ASTCallbacks, undefined, {
                    varyings: {}
                });
                const transpiledSource = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$escodegen$2f$escodegen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].generate(ast);
                generatorFunction = new Function(transpiledSource.slice(transpiledSource.indexOf('{') + 1, transpiledSource.lastIndexOf('}')).replaceAll(';', ''));
            } else {
                generatorFunction = shaderModifier;
            }
            const generator = new ShaderGenerator(generatorFunction, this, options.srcLocations);
            const generatedModifyArgument = generator.generate();
            return oldModify.call(this, generatedModifyArgument);
        } else {
            return oldModify.call(this, shaderModifier);
        }
    };
    // AST Transpiler Callbacks and helper functions
    function replaceBinaryOperator(codeSource) {
        switch(codeSource){
            case '+':
                return 'add';
            case '-':
                return 'sub';
            case '*':
                return 'mult';
            case '/':
                return 'div';
            case '%':
                return 'mod';
            case '==':
            case '===':
                return 'equalTo';
            case '>':
                return 'greaterThan';
            case '>=':
                return 'greaterThanEqualTo';
            case '<':
                return 'lessThan';
            case '&&':
                return 'and';
            case '||':
                return 'or';
        }
    }
    function ancestorIsUniform(ancestor) {
        return ancestor.type === 'CallExpression' && ancestor.callee?.type === 'Identifier' && ancestor.callee?.name.startsWith('uniform');
    }
    const ASTCallbacks = {
        UnaryExpression (node, _state, _ancestors) {
            if (_ancestors.some(ancestorIsUniform)) {
                return;
            }
            const signNode = {
                type: 'Literal',
                value: node.operator
            };
            const standardReplacement = (node)=>{
                node.type = 'CallExpression';
                node.callee = {
                    type: 'Identifier',
                    name: 'unaryNode'
                };
                node.arguments = [
                    node.argument,
                    signNode
                ];
            };
            if (node.type === 'MemberExpression') {
                const property = node.argument.property.name;
                const swizzleSets = [
                    [
                        'x',
                        'y',
                        'z',
                        'w'
                    ],
                    [
                        'r',
                        'g',
                        'b',
                        'a'
                    ],
                    [
                        's',
                        't',
                        'p',
                        'q'
                    ]
                ];
                let isSwizzle = swizzleSets.some((set)=>[
                        ...property
                    ].every((char)=>set.includes(char))) && node.argument.type === 'MemberExpression';
                if (isSwizzle) {
                    node.type = 'MemberExpression';
                    node.object = {
                        type: 'CallExpression',
                        callee: {
                            type: 'Identifier',
                            name: 'unaryNode'
                        },
                        arguments: [
                            node.argument.object,
                            signNode
                        ]
                    };
                    node.property = {
                        type: 'Identifier',
                        name: property
                    };
                } else {
                    standardReplacement(node);
                }
            } else {
                standardReplacement(node);
            }
            delete node.argument;
            delete node.operator;
        },
        VariableDeclarator (node, _state, _ancestors) {
            if (node.init.callee && node.init.callee.name?.startsWith('uniform')) {
                const uniformNameLiteral = {
                    type: 'Literal',
                    value: node.id.name
                };
                node.init.arguments.unshift(uniformNameLiteral);
            }
            if (node.init.callee && node.init.callee.name?.startsWith('varying')) {
                const varyingNameLiteral = {
                    type: 'Literal',
                    value: node.id.name
                };
                node.init.arguments.unshift(varyingNameLiteral);
                _state.varyings[node.id.name] = varyingNameLiteral;
            }
        },
        Identifier (node, _state, _ancestors) {
            if (_state.varyings[node.name] && !_ancestors.some((a)=>a.type === 'AssignmentExpression' && a.left === node)) {
                node.type = 'ExpressionStatement';
                node.expression = {
                    type: 'CallExpression',
                    callee: {
                        type: 'MemberExpression',
                        object: {
                            type: 'Identifier',
                            name: node.name
                        },
                        property: {
                            type: 'Identifier',
                            name: 'getValue'
                        }
                    },
                    arguments: []
                };
            }
        },
        // The callbacks for AssignmentExpression and BinaryExpression handle
        // operator overloading including +=, *= assignment expressions
        ArrayExpression (node, _state, _ancestors) {
            const original = JSON.parse(JSON.stringify(node));
            node.type = 'CallExpression';
            node.callee = {
                type: 'Identifier',
                name: 'dynamicNode'
            };
            node.arguments = [
                original
            ];
        },
        AssignmentExpression (node, _state, _ancestors) {
            if (node.operator !== '=') {
                const methodName = replaceBinaryOperator(node.operator.replace('=', ''));
                const rightReplacementNode = {
                    type: 'CallExpression',
                    callee: {
                        type: 'MemberExpression',
                        object: node.left,
                        property: {
                            type: 'Identifier',
                            name: methodName
                        }
                    },
                    arguments: [
                        node.right
                    ]
                };
                node.operator = '=';
                node.right = rightReplacementNode;
            }
            if (_state.varyings[node.left.name]) {
                node.type = 'ExpressionStatement';
                node.expression = {
                    type: 'CallExpression',
                    callee: {
                        type: 'MemberExpression',
                        object: {
                            type: 'Identifier',
                            name: node.left.name
                        },
                        property: {
                            type: 'Identifier',
                            name: 'bridge'
                        }
                    },
                    arguments: [
                        node.right
                    ]
                };
            }
        },
        BinaryExpression (node, _state, _ancestors) {
            // Don't convert uniform default values to node methods, as
            // they should be evaluated at runtime, not compiled.
            if (_ancestors.some(ancestorIsUniform)) {
                return;
            }
            // If the left hand side of an expression is one of these types,
            // we should construct a node from it.
            const unsafeTypes = [
                'Literal',
                'ArrayExpression',
                'Identifier'
            ];
            if (unsafeTypes.includes(node.left.type)) {
                const leftReplacementNode = {
                    type: 'CallExpression',
                    callee: {
                        type: 'Identifier',
                        name: 'dynamicNode'
                    },
                    arguments: [
                        node.left
                    ]
                };
                node.left = leftReplacementNode;
            }
            // Replace the binary operator with a call expression
            // in other words a call to BaseNode.mult(), .div() etc.
            node.type = 'CallExpression';
            node.callee = {
                type: 'MemberExpression',
                object: node.left,
                property: {
                    type: 'Identifier',
                    name: replaceBinaryOperator(node.operator)
                }
            };
            node.arguments = [
                node.right
            ];
        }
    };
    // Javascript Node API.
    class BaseNode {
        constructor(isInternal, type){
            if (new.target === BaseNode) {
                throw new TypeError('Cannot construct BaseNode instances directly. This is an abstract class.');
            }
            this.type = type;
            this.componentNames = [];
            this.componentsChanged = false;
            // For tracking recursion depth and creating temporary variables
            this.isInternal = isInternal;
            this.usedIn = [];
            this.dependsOn = [];
            this.srcLine = null;
            this.usedInConditional = false;
            // Stack Capture is used to get the original line of user code for Debug purposes
            if (GLOBAL_SHADER.srcLocations === true && isInternal === false) {
                try {
                    throw new Error('StackCapture');
                } catch (e) {
                    const lines = e.stack.split('\n');
                    let userSketchLineIndex = 5;
                    if (isBinaryExpressionNode(this)) {
                        userSketchLineIndex--;
                    }
                    this.srcLine = lines[userSketchLineIndex].trim();
                }
            }
        }
        addVectorComponents() {
            if (this.type.startsWith('vec')) {
                const vectorDimensions = parseInt(this.type.slice(3));
                this.componentNames = [
                    'x',
                    'y',
                    'z',
                    'w'
                ].slice(0, vectorDimensions);
                const proxy = this;
                for (let componentName of this.componentNames){
                    let value = new ComponentNode(proxy, componentName, 'float', true);
                    Object.defineProperty(this, componentName, {
                        get () {
                            return value;
                        },
                        set (newValue) {
                            this.componentsChanged = true;
                            if (isUnaryExpressionNode(this)) {
                                this.node.value = newValue;
                            } else {
                                value = newValue;
                            }
                        }
                    });
                }
            }
        }
        forceTemporaryVariable() {
            if (!(isFloatNode(this) && isVectorNode(this.parent)) || !isVariableNode(this)) this.useTemp = true;
        }
        assertUsedInConditional(branch) {
            this.usedInConditional = true;
            this.usedIn.push(branch);
            this.forceTemporaryVariable();
        }
        isUsedInConditional() {
            return this.usedInConditional;
        }
        checkConditionalDependencies(context) {
            context.ifs.forEach((statement)=>{
                const isUsedSatisfied = ()=>statement.usedInSatisfied.length >= 1;
                const isDepsSatisfied = ()=>statement.dependsOn.length === statement.dependsOnSatisfied.length;
                if (statement.insertionPoint > -1 || !statement.usedIn.length) return;
                if (statement.dependsOn.some((d)=>d.node === this) && !statement.dependsOnSatisfied.includes(this)) {
                    statement.dependsOnSatisfied.push(this);
                }
                if (statement.usedIn.includes(this) && !statement.usedInSatisfied.includes(this)) {
                    statement.usedInSatisfied.push(this);
                }
                if (isDepsSatisfied() && isUsedSatisfied()) {
                    statement.saveState(context, isDepsSatisfied(), isUsedSatisfied());
                }
            });
        }
        // The base node implements a version of toGLSL which determines whether the generated code should be stored in a temporary variable.
        toGLSLBase(context) {
            let result;
            if (this.shouldUseTemporaryVariable()) {
                let oldLength = context.declarations.length;
                result = this.getTemporaryVariable(context);
                let diff = context.declarations.length - 1 - oldLength;
                diff = diff > 0 ? diff : undefined;
                this.dependsOn.forEach((dependency)=>{
                    if (dependency.isVector) {
                        const dependencies = dependency.originalComponents.map((component, i)=>component === dependency.currentComponents[i]);
                        context.updateComponents(dependency.node, diff, dependencies);
                    } else {
                        context.updateComponents(dependency.node, diff);
                    }
                });
            } else {
                result = this.toGLSL(context);
            }
            this.checkConditionalDependencies(context);
            return result;
        }
        shouldUseTemporaryVariable() {
            if (this.componentsChanged || hasTemporaryVariable(this) || this.useTemp) {
                return true;
            }
            if (this.isInternal || isVariableNode(this) || isConditionalNode(this) || this.type === 'sampler2D') {
                return false;
            }
            // return false;
            // Swizzles must use temporary variables as otherwise they will not be registered
            let score = 0;
            score += isFunctionCallNode(this) * 2;
            score += isBinaryExpressionNode(this) * 2;
            score += isVectorType(this) * 3;
            score += this.usedIn.length;
            return score >= 4;
        }
        getTemporaryVariable(context) {
            if (!this.temporaryVariable) {
                this.temporaryVariable = `temp_${context.getNextID()}`;
                let line = '';
                if (this.srcLine) {
                    line += `\n// From ${this.srcLine}\n`;
                }
                line += '  ' + this.type + ' ' + this.temporaryVariable + ' = ' + this.toGLSL(context) + ';';
                context.declarations.push(line);
            }
            return this.temporaryVariable;
        }
        // Binary Operators
        add(other) {
            return binaryExpressionNodeConstructor(this, this.enforceType(other), '+');
        }
        sub(other) {
            return binaryExpressionNodeConstructor(this, this.enforceType(other), '-');
        }
        mult(other) {
            return binaryExpressionNodeConstructor(this, this.enforceType(other), '*');
        }
        div(other) {
            return binaryExpressionNodeConstructor(this, this.enforceType(other), '/');
        }
        mod(other) {
            return binaryExpressionNodeConstructor(this, this.enforceType(other), '%');
        }
        // Check that the types of the operands are compatible.
        enforceType(other) {
            if (isShaderNode(other)) {
                if (!isGLSLNativeType(other.type)) {
                    throw new TypeError(`You've tried to perform an operation on a struct of type: ${other.type}. Try accessing a member on that struct with '.'`);
                }
                if (!isGLSLNativeType(other.type)) {
                    throw new TypeError(`You've tried to perform an operation on a struct of type: ${other.type}. Try accessing a member on that struct with '.'`);
                }
                if ((isFloatType(this) || isVectorType(this)) && isIntType(other)) {
                    return new FloatNode(other);
                }
                return other;
            } else if (typeof other === 'number') {
                if (isIntType(this)) {
                    return new IntNode(other);
                }
                return new FloatNode(other);
            } else if (Array.isArray(other)) {
                return nodeConstructors.dynamicVector(other);
            // return nodeConstructors[`vec${other.length}`](other);
            } else {
                return nodeConstructors[this.type](other);
            }
        }
        toFloat() {
            if (isFloatType(this)) {
                return this;
            } else if (isIntType(this)) {
                return new FloatNode(this);
            }
        }
        toGLSL(context) {
            throw new TypeError('Not supposed to call this function on BaseNode, which is an abstract class.');
        }
    }
    // Primitive Types
    class IntNode extends BaseNode {
        constructor(x = 0, isInternal = false){
            super(isInternal, 'int');
            this.x = x;
        }
        toGLSL(context) {
            if (isShaderNode(this.x)) {
                let code = this.x.toGLSLBase(context);
                return isIntType(this.x.type) ? code : `int(${code})`;
            } else if (typeof this.x === 'number') {
                return `${Math.floor(this.x)}`;
            } else {
                return `int(${this.x})`;
            }
        }
    }
    class FloatNode extends BaseNode {
        constructor(x = 0, isInternal = false, _parent = false){
            super(isInternal, 'float');
            if (Array.isArray(x)) {
                x = x[0];
            }
            if (_parent) {
                const { parent, name } = _parent;
                this.name = name;
                this.parent = parent;
            }
            this.x = x;
        }
        toGLSL(context) {
            if (isShaderNode(this.x)) {
                let code = this.x.toGLSLBase(context);
                return isFloatType(this.x) ? code : `float(${code})`;
            } else if (typeof this.x === 'number') {
                return `${this.x.toFixed(4)}`;
            } else {
                return `float(${this.x})`;
            }
        }
    }
    class VectorNode extends BaseNode {
        constructor(values, type, isInternal = false){
            super(isInternal, type);
            this.originalValues = conformVectorParameters(values, parseInt(type.slice(3)));
            this.componentNames = [
                'x',
                'y',
                'z',
                'w'
            ].slice(0, this.originalValues.length);
        }
        addVectorComponents() {
            const values = this.originalValues;
            this.componentsChanged = false;
            this.componentNames.forEach((componentName, i)=>{
                const info = {
                    name: componentName,
                    parent: this
                };
                let value = isFloatNode(values[i]) ? values[i] : new FloatNode(values[i], true, info);
                Object.defineProperty(this, componentName, {
                    get () {
                        return value;
                    },
                    set (newValue) {
                        this.componentsChanged = true;
                        if (isUnaryExpressionNode(this)) {
                            this.node.value = newValue;
                        } else {
                            value = isFloatNode(newValue) ? newValue : new FloatNode(newValue, true, info);
                        }
                    }
                });
            });
            this.originalValues = this.componentNames.map((name)=>this[name]);
        }
        toGLSL(context) {
            if ((!this.componentsChanged || !this.defined) && !this.oldName) {
                let glslArgs = this.componentNames.map((_name, i)=>this.originalValues[i].toGLSLBase(context)).join(', ');
                this.defined = true;
                return `${this.type}(${glslArgs})`;
            } else {
                return this.temporaryVariable;
            }
        }
    }
    // Function Call Nodes
    class FunctionCallNode extends BaseNode {
        constructor(name, userArgs, properties, isInternal = false){
            let functionSignature;
            const determineFunctionSignature = (props)=>{
                let genType;
                let similarity = 0;
                const valid = userArgs.every((userArg, i)=>{
                    const userType = getType(userArg);
                    let expectedArgType = props.args[i];
                    if (expectedArgType === 'genType') {
                        // We allow conversions from float -> vec if one argument is a vector.
                        if (genType === undefined || genType === 'float' && userType.startsWith('vec')) {
                            genType = userType;
                        }
                        expectedArgType = genType;
                    }
                    similarity += userType === expectedArgType;
                    return userType === expectedArgType || userType === 'float' && expectedArgType.startsWith('vec');
                });
                return {
                    ...props,
                    valid,
                    similarity,
                    genType
                };
            };
            if (Array.isArray(properties)) {
                // Check if the right number of parameters were provided
                let possibleOverloads = properties.filter((o)=>o.args.length === userArgs.length);
                if (possibleOverloads.length === 0) {
                    const argsLengthSet = new Set();
                    const argsLengthArr = [];
                    properties.forEach((p)=>argsLengthSet.add(p.args.length));
                    argsLengthSet.forEach((len)=>argsLengthArr.push(`${len}`));
                    const argsLengthStr = argsLengthArr.join(' or ');
                    throw new Error(`Function '${name}' has ${properties.length} variants which expect ${argsLengthStr} arguments, but ${userArgs.length} arguments were provided.`);
                }
                const findBestOverload = function(best, current) {
                    current = determineFunctionSignature(current);
                    if (!current.valid) {
                        return best;
                    }
                    if (!best || current.similarity > best.similarity) {
                        best = current;
                    }
                    return best;
                };
                functionSignature = possibleOverloads.reduce(findBestOverload, null);
            } else {
                functionSignature = determineFunctionSignature(properties);
            }
            if (!functionSignature || !functionSignature.valid) {
                const argsStrJoin = (args)=>`(${args.map((arg)=>arg).join(', ')})`;
                const expectedArgsString = Array.isArray(properties) ? properties.map((prop)=>argsStrJoin(prop.args)).join(' or ') : argsStrJoin(properties.args);
                const providedArgsString = argsStrJoin(userArgs.map((a)=>getType(a)));
                throw new Error(`Function '${name}' was called with wrong arguments. Most likely, you provided mixed lengths vectors as arguments.\nExpected argument types: ${expectedArgsString}\nProvided argument types: ${providedArgsString}\nAll of the arguments with expected type 'genType' should have a matching type. If one of those is different, try to find where it was created.
        `);
            }
            if (userArgs.length !== functionSignature.args.length) {
                throw new Error(`Function '${name}' expects ${functionSignature.args.length} arguments, but ${userArgs.length} were provided.`);
            }
            userArgs = userArgs.map((arg, i)=>{
                if (!isShaderNode(arg)) {
                    const typeName = functionSignature.args[i] === 'genType' ? functionSignature.genType : functionSignature.args[i];
                    arg = nodeConstructors[typeName](arg);
                } else if (isFloatType(arg) && functionSignature.args[i] === 'genType' && functionSignature.genType !== 'float') {
                    arg = nodeConstructors[functionSignature.genType](arg);
                }
                return arg;
            });
            if (functionSignature.returnType === 'genType') {
                functionSignature.returnType = functionSignature.genType;
            }
            super(isInternal, functionSignature.returnType);
            this.name = name;
            this.args = userArgs;
            this.argumentTypes = functionSignature.args;
        }
        deconstructArgs(context) {
            let argsString = this.args.map((argNode, i)=>{
                if (isIntType(argNode) && this.argumentTypes[i] != 'float') {
                    argNode = argNode.toFloat();
                }
                argNode.toGLSLBase(context);
                return argNode.toGLSLBase(context);
            }).join(', ');
            return argsString;
        }
        toGLSL(context) {
            return `${this.name}(${this.deconstructArgs(context)})`;
        }
    }
    // Variables and member variable nodes
    class VariableNode extends BaseNode {
        constructor(name, type, isInternal = false){
            super(isInternal, type);
            this.name = name;
        }
        toGLSL(context) {
            return `${this.name}`;
        }
    }
    class ComponentNode extends BaseNode {
        constructor(parent, componentName, type, isInternal = false){
            super(isInternal, type);
            this.parent = parent;
            this.componentName = componentName;
            this.type = type;
        }
        toGLSL(context) {
            let parentName = this.parent.toGLSLBase(context);
            if (!isVariableNode(this.parent) && !hasTemporaryVariable(this.parent)) {
                parentName = `(${parentName})`;
            }
            return `${parentName}.${this.componentName}`;
        }
    }
    //
    class VaryingNode extends VariableNode {
        constructor(name, type, isInternal = false){
            super(name, type, isInternal);
            this.timesChanged = 0;
            this.tempVars = 0;
        }
        getValue() {
            const context = GLOBAL_SHADER.context;
            if (!context.varyings[this.name] || !this.timesChanged) {
                return this;
            }
            let values = context.varyings[this.name].splice(0, this.timesChanged);
            let snapshot;
            values.forEach((val1, i)=>{
                let { value } = val1;
                context.declarations.push(`  ${this.name} = ${value.toGLSLBase(context)};`);
                if (i === values.length - 1) {
                    const tempName = `${this.name}_${this.tempVars++}`;
                    snapshot = dynamicAddSwizzleTrap(new VariableNode(tempName, this.type, true));
                    context.declarations.push(`  ${this.type} ${tempName} = ${this.name};`);
                }
            });
            this.timesChanged = 0;
            return snapshot;
        }
        bridge(value) {
            if (!isShaderNode(value) || this.type.startsWith('vec') && getType(value) === 'float') {
                value = nodeConstructors[this.type](value);
            }
            GLOBAL_SHADER.registerVarying(this, value);
            this.timesChanged += 1;
        }
    }
    // Binary Operator Nodes
    class BinaryExpressionNode extends BaseNode {
        constructor(left, right, operator, isInternal = false){
            super(isInternal, null);
            this.operator = operator;
            this.left = left;
            this.right = right;
            for (const operand of [
                left,
                right
            ]){
                operand.usedIn.push(this);
            }
            this.type = this.determineType();
        }
        // We know that both this.left and this.right are nodes because of BaseNode.enforceType
        determineType() {
            if ([
                '==',
                '>',
                '>=',
                '<',
                '<=',
                '||',
                '!',
                '&&'
            ].includes(this.operator)) {
                return 'bool';
            } else if (this.left.type === this.right.type) {
                return this.left.type;
            } else if (isVectorType(this.left) && isFloatType(this.right)) {
                return this.left.type;
            } else if (isVectorType(this.right) && isFloatType(this.left)) {
                return this.right.type;
            } else if (isFloatType(this.left) && isIntType(this.right) || isIntType(this.left) && isFloatType(this.right)) {
                return 'float';
            } else {
                throw new Error('Incompatible types for binary operator');
            }
        }
        processOperand(operand, context) {
            if (operand.temporaryVariable) {
                return operand.temporaryVariable;
            }
            let code = operand.toGLSLBase(context);
            if (isBinaryExpressionNode(operand) && !operand.temporaryVariable) {
                code = `(${code})`;
            }
            if (this.type === 'float' && isIntType(operand)) {
                code = `float(${code})`;
            }
            return code;
        }
        toGLSL(context) {
            const a = this.processOperand(this.left, context);
            const b = this.processOperand(this.right, context);
            return `${a} ${this.operator} ${b}`;
        }
    }
    class ModulusNode extends BinaryExpressionNode {
        constructor(a, b, isInternal){
            super(a, b, isInternal);
        }
        toGLSL(context) {
            // Switch on type between % or mod()
            if (isVectorType(this) || isFloatType(this)) {
                return `mod(${this.left.toGLSLBase(context)}, ${this.right.toGLSLBase(context)})`;
            }
            return `${this.processOperand(context, this.left)} % ${this.processOperand(context, this.right)}`;
        }
    }
    class UnaryExpressionNode extends BaseNode {
        constructor(node, operator, isInternal = false){
            super(isInternal, node.type);
            this.node = node;
            this.operator = operator;
        }
        toGLSL(context) {
            let mainStr = this.node.toGLSLBase(context);
            if (!isVariableNode(this.node) && !hasTemporaryVariable(this.node) && !isPrimitiveNode(this.node)) {
                mainStr = `(${mainStr})`;
            }
            return `${this.operator}${mainStr}`;
        }
    }
    // Conditions and logical modifiers
    BaseNode.prototype.equalTo = function(other) {
        return binaryExpressionNodeConstructor(this, this.enforceType(other), '==');
    };
    BaseNode.prototype.greaterThan = function(other) {
        return binaryExpressionNodeConstructor(this, this.enforceType(other), '>');
    };
    BaseNode.prototype.greaterThanEqualTo = function(other) {
        return binaryExpressionNodeConstructor(this, this.enforceType(other), '>=');
    };
    BaseNode.prototype.lessThan = function(other) {
        return binaryExpressionNodeConstructor(this, this.enforceType(other), '<');
    };
    BaseNode.prototype.lessThanEqualTo = function(other) {
        return binaryExpressionNodeConstructor(this, this.enforceType(other), '<=');
    };
    BaseNode.prototype.not = function() {
        return new UnaryExpressionNode(this.condition, '!', true);
    };
    BaseNode.prototype.or = function(other) {
        return new binaryExpressionNodeConstructor(this, this.enforceType(other), '||', true);
    };
    BaseNode.prototype.and = function(other) {
        return new binaryExpressionNodeConstructor(this, this.enforceType(other), '&&', true);
    };
    function branch(callback) {
        const branch = new BranchNode();
        callback();
        BRANCH = null;
        return branch;
    }
    class ConditionalNode {
        constructor(condition, branchCallback){
            this.dependsOn = [];
            this.usedIn = [];
            this.dependsOnSatisfied = [];
            this.usedInSatisfied = [];
            this.states = [];
            this.if(condition, branchCallback);
            this.insertionPoint = -1;
            this.elseIfs = [];
            this.elseBranch = null;
            GLOBAL_SHADER.context.ifs.push(this);
        }
        if(condition, branchCallback) {
            this.condition = condition;
            this.conditionString = condition.toGLSL(GLOBAL_SHADER.context);
            this.ifBranch = branch(branchCallback);
            this.ifBranch.parent = this;
        }
        elseIf(condition, branchCallback) {
            let elseBranch = branch(branchCallback);
            branchCallback.parent = this;
            this.elseIfs.push({
                condition,
                elseBranch
            });
            return this;
        }
        else(branchCallback) {
            this.elseBranch = branch(branchCallback);
            this.elseBranch.parent = this;
            return this;
        }
        thenDiscard() {
            return new ConditionalDiscard(this.condition);
        }
        saveState(context, usedInSatisfied, dependsOnSatisfied) {
            this.states.push({
                line: context.declarations.length,
                usedInSatisfied,
                dependsOnSatisfied
            });
            this.insertionPoint = context.declarations.length - 1;
        }
        toGLSL(context) {
            const oldLength = context.declarations.length;
            this.dependsOn.forEach((dep)=>context.updateComponents(dep.node));
            const newLength = context.declarations.length;
            const diff = newLength - oldLength;
            this.insertionPoint += diff;
            let codelines = [
                `\n  if (${this.conditionString}) {`,
                `\n    ${this.ifBranch.toGLSL(context)}`,
                `\n  }`
            ];
            if (this.elseIfs.length) {
                this.elseIfs.forEach((elif)=>{
                    let { condition, elseBranch } = elif;
                    codelines.push(` else if (${condition.toGLSL(context)}) {`);
                    codelines.push(`\n    ${elseBranch.toGLSL(context)}`);
                    codelines.push(`\n  }`);
                });
            }
            if (this.elseBranch) {
                codelines.push(` else {`);
                codelines.push(`\n    ${this.elseBranch.toGLSL(context)}`);
                codelines.push(`\n  }\n`);
            }
            codelines.push('\n');
            return codelines.flat().join('');
        }
    }
    fn.assign = function(node, value) {
        if (!BRANCH) {
            throw new error('assign() is supposed to be used inside of conditional branchs. Use the "=" operator as normal otherwise.');
        }
        BRANCH.assign(node, value);
    };
    class BranchNode {
        constructor(){
            BRANCH = this;
            this.statements = [];
            this.assignments = [];
            this.dependsOn = [];
            this.declarations = [];
            let parent = null;
            Object.defineProperty(this, 'parent', {
                get () {
                    return parent;
                },
                set (newParent) {
                    newParent.dependsOn.push(...this.dependsOn);
                    parent = newParent;
                }
            });
        }
        assign(node, value) {
            if (!isShaderNode(value) || value.type !== node.type) {
                value = nodeConstructors[node.type](value);
                this.declarations.push(value);
                this.assignments.push({
                    node
                });
            } else {
                this.assignments.push({
                    node,
                    value
                });
            }
            node = node.parent ? node.parent : node;
            value = value.parent ? value.parent : value;
            if ([
                node,
                value
            ].some((n)=>this.dependsOn.some((d)=>d.node === n))) {
                return;
            }
            node.assertUsedInConditional(this);
            this.dependsOn.push(makeDependencyObject(node));
            if (value.shouldUseTemporaryVariable()) {
                value.assertUsedInConditional(this);
                this.dependsOn.push(makeDependencyObject(value));
            }
        }
        toGLSL(context) {
            let declarationsIndex = 0;
            this.assignments.forEach(({ node, value })=>{
                let statement;
                let result;
                if (!value) {
                    let decl = this.declarations[declarationsIndex];
                    declarationsIndex++;
                    decl.temporaryVariable = `temp_${context.getNextID()}`;
                    this.statements.push(`${decl.type} ${decl.temporaryVariable} = ${decl.toGLSL(context)};`);
                    result = decl.toGLSLBase(context);
                } else {
                    result = value.toGLSLBase(context);
                }
                if (isVariableNode(node) || hasTemporaryVariable(node)) {
                    statement = `${node.toGLSLBase(context)} = ${result};`;
                } else if (isFloatNode(node) && node.name) {
                    statement = `${node.parent.toGLSLBase(context)}.${node.name} = ${result};`;
                } else {
                    node.temporaryVariable = `temp_${context.getNextID()}`;
                    statement = `${node.type} ${node.toGLSLBase(context)} = ${result};`;
                }
                this.statements.push(statement);
            });
            return this.statements.join(`\n    `);
        }
    }
    class ConditionalDiscard {
        constructor(condition){
            this.condition = condition;
        }
        toGLSL(context) {
            context.discardConditions.push(`if (${this.condition}{discard;})`);
        }
    }
    // Node Helper functions
    function getType(node) {
        if (isShaderNode(node)) {
            return node.type;
        } else if (Array.isArray(node) && node.length > 1) {
            return `vec${node.length}`;
        } else if (typeof node === 'number' || Array.isArray(node) && node.length === 1) {
            return 'float';
        }
        return undefined;
    }
    function computeVectorLength(values) {
        let length = 0;
        if (Array.isArray(values)) {
            for (let val1 of values){
                if (isVectorType(val1)) {
                    length += parseInt(val1.type.slice(3));
                } else length += 1;
            }
        } else if (isVectorType(values)) {
            length += parseInt(val.type.slice(3));
        }
        if (![
            2,
            3,
            4
        ].includes(length)) {
            throw new Error(`You have attempted to construct a vector with ${length} values. Only vec2, vec3, and vec4 types are supported.`);
        }
        return length;
    }
    fn.dynamicNode = function(input) {
        if (isShaderNode(input)) {
            return input;
        } else if (typeof input === 'number') {
            return new FloatNode(input);
        } else if (Array.isArray(input)) {
            return nodeConstructors.dynamicVector(input);
        }
    };
    // For replacing unary expressions
    fn.unaryNode = function(input, sign) {
        input = dynamicNode(input);
        return dynamicAddSwizzleTrap(new UnaryExpressionNode(input, sign));
    };
    function isShaderNode(node) {
        return node instanceof BaseNode;
    }
    function isIntType(node) {
        return isShaderNode(node) && node.type === 'int';
    }
    function isFloatType(node) {
        return isShaderNode(node) && node.type === 'float';
    }
    function isFloatNode(node) {
        return node instanceof FloatNode;
    }
    function isVectorType(node) {
        return isShaderNode(node) && (node.type === 'vec2' || node.type === 'vec3' || node.type === 'vec4');
    }
    function isBinaryExpressionNode(node) {
        return node instanceof BinaryExpressionNode;
    }
    function isVariableNode(node) {
        return node instanceof VariableNode || node instanceof ComponentNode;
    }
    function isConditionalNode(node) {
        return node instanceof ConditionalNode || node instanceof BranchNode;
    }
    function hasTemporaryVariable(node) {
        return node.temporaryVariable;
    }
    function isPrimitiveNode(node) {
        return node instanceof FloatNode || node instanceof IntNode || node instanceof VectorNode;
    }
    function isFunctionCallNode(node) {
        return node instanceof FunctionCallNode;
    }
    function isVectorNode(node) {
        return node instanceof VectorNode;
    }
    function isUnaryExpressionNode(node) {
        return node instanceof UnaryExpressionNode;
    }
    // Helper function to check if a type is a user defined struct or native type
    function isGLSLNativeType(typeName) {
        // Supported types for now
        const glslNativeTypes = [
            'int',
            'float',
            'vec2',
            'vec3',
            'vec4',
            'sampler2D'
        ];
        return glslNativeTypes.includes(typeName);
    }
    // Shader Generator
    // This class is responsible for converting the nodes into an object containing GLSL code, to be used by p5.Shader.modify
    class ShaderGenerator {
        constructor(userCallback, originalShader, srcLocations){
            GLOBAL_SHADER = this;
            this.userCallback = userCallback;
            this.srcLocations = srcLocations;
            this.cleanup = ()=>{};
            this.generateHookOverrides(originalShader);
            this.output = {
                vertexDeclarations: new Set(),
                fragmentDeclarations: new Set(),
                uniforms: {}
            };
            this.uniformNodes = [];
            this.resetGLSLContext();
            this.isGenerating = false;
        }
        generate() {
            const prevFESDisabled = p51.disableFriendlyErrors;
            // We need a custom error handling system within shader generation
            p51.disableFriendlyErrors = true;
            this.isGenerating = true;
            this.userCallback();
            this.output.vertexDeclarations = [
                ...this.output.vertexDeclarations
            ].join('\n');
            this.output.fragmentDeclarations = [
                ...this.output.fragmentDeclarations
            ].join('\n');
            this.isGenerating = false;
            this.cleanup();
            p51.disableFriendlyErrors = prevFESDisabled;
            return this.output;
        }
        // This method generates the hook overrides which the user calls in their modify function.
        generateHookOverrides(originalShader) {
            const availableHooks = {
                ...originalShader.hooks.vertex,
                ...originalShader.hooks.fragment
            };
            const windowOverrides = {};
            Object.keys(availableHooks).forEach((hookName)=>{
                const hookTypes = originalShader.hookTypes(hookName);
                // These functions are where the user code is executed
                this[hookTypes.name] = function(userCallback) {
                    // Create the initial nodes which are passed to the user callback
                    // Also generate a string of the arguments for the code generation
                    const argNodes = [];
                    const argsArray = [];
                    hookTypes.parameters.forEach((parameter)=>{
                        // For hooks with structs as input we should pass an object populated with variable nodes
                        if (!isGLSLNativeType(parameter.type.typeName)) {
                            const structArg = {};
                            parameter.type.properties.forEach((property)=>{
                                structArg[property.name] = variableConstructor(`${parameter.name}.${property.name}`, property.type.typeName, true);
                            });
                            argNodes.push(structArg);
                        } else {
                            argNodes.push(variableConstructor(parameter.name, parameter.type.typeName, true));
                        }
                        const qualifiers = parameter.type.qualifiers.length > 0 ? parameter.type.qualifiers.join(' ') : '';
                        argsArray.push(`${qualifiers} ${parameter.type.typeName} ${parameter.name}`.trim());
                    });
                    let returnedValue = userCallback(...argNodes);
                    const expectedReturnType = hookTypes.returnType;
                    const toGLSLResults = {};
                    // If the expected return type is a struct we need to evaluate each of its properties
                    if (!isGLSLNativeType(expectedReturnType.typeName)) {
                        Object.entries(returnedValue).forEach(([propertyName, propertyNode])=>{
                            propertyNode = dynamicNode(propertyNode);
                            toGLSLResults[propertyName] = propertyNode.toGLSLBase(this.context);
                            this.context.updateComponents(propertyNode);
                        });
                    } else {
                        if (!isShaderNode(returnedValue)) {
                            returnedValue = nodeConstructors[expectedReturnType.typeName](returnedValue);
                        } else if (isFloatType(returnedValue) && expectedReturnType.typeName.startsWith('vec')) {
                            returnedValue = nodeConstructors[expectedReturnType.typeName](returnedValue);
                        }
                        toGLSLResults['notAProperty'] = returnedValue.toGLSLBase(this.context);
                        this.context.updateComponents(returnedValue);
                    }
                    this.context.ifs.forEach((statement)=>{
                        if (statement.usedIn.length === 0) {
                            return;
                        }
                        const lines = statement.toGLSL(this.context);
                        this.context.declarations.splice(statement.insertionPoint, 0, lines);
                    });
                    // Build the final GLSL string.
                    // The order of this code is a bit confusing, we need to call toGLSLBase
                    let codeLines = [
                        `(${argsArray.join(', ')}) {`,
                        ...this.context.declarations,
                        `\n  ${hookTypes.returnType.typeName} finalReturnValue;`
                    ];
                    Object.entries(toGLSLResults).forEach(([propertyName, result])=>{
                        const propString = expectedReturnType.properties ? `.${propertyName}` : '';
                        codeLines.push(`  finalReturnValue${propString} = ${result};`);
                    });
                    this.context.declarations = [];
                    for(let key in this.context.varyings){
                        const declArray = this.context.varyings[key];
                        const finalVaryingAssignments = [];
                        declArray.forEach((obj)=>{
                            const { node, value } = obj;
                            finalVaryingAssignments.push(`  ${node.name} = ${value.toGLSLBase(this.context)};`);
                            finalVaryingAssignments.unshift(...this.context.declarations);
                            node.timesChanged = 0;
                        });
                        codeLines.push(...finalVaryingAssignments);
                    }
                    codeLines.push('  return finalReturnValue;', '}');
                    this.output[hookName] = codeLines.join('\n');
                    this.resetGLSLContext();
                };
                windowOverrides[hookTypes.name] = window[hookTypes.name];
                // Expose the Functions to global scope for users to use
                window[hookTypes.name] = function(userOverride) {
                    GLOBAL_SHADER[hookTypes.name](userOverride);
                };
            });
            this.cleanup = ()=>{
                for(const key in windowOverrides){
                    window[key] = windowOverrides[key];
                }
            };
        }
        registerVarying(node, value) {
            if (!Array.isArray(this.context.varyings[node.name])) {
                this.context.varyings[node.name] = [];
            }
            this.context.varyings[node.name].push({
                node,
                value
            });
            this.output.vertexDeclarations.add(`OUT ${node.type} ${node.name};`);
            this.output.fragmentDeclarations.add(`IN ${node.type} ${node.name};`);
        }
        resetGLSLContext() {
            this.uniformNodes.forEach((node)=>{
                node.usedIn = [];
                node.temporaryVariable = undefined;
            });
            this.context = {
                id: 0,
                getNextID () {
                    return this.id++;
                },
                declarations: [],
                varyings: [],
                ifs: [],
                updateComponents: function(node, _emplaceAt, _changedComponents) {
                    if (node.componentsChanged) {
                        if (!_changedComponents) {
                            _changedComponents = node.componentNames.map(()=>true);
                        }
                        const lines = [];
                        if (isVectorNode(node)) {
                            node.componentNames.forEach((name, i)=>{
                                if (!_changedComponents[i]) return;
                                if (node[name] !== node.originalValues[i]) {
                                    const replacement = nodeConstructors['float'](node[name]);
                                    const line = `  ${node.temporaryVariable}.${name} = ${replacement.toGLSLBase(this)};`;
                                    lines.push(line);
                                }
                            });
                        } else {
                            const components = node.componentNames.map((name)=>{
                                return node[name];
                            });
                            const replacement = nodeConstructors[node.type](components);
                            const line = `  ${node.temporaryVariable} = ${replacement.toGLSLBase(this)};`;
                            lines.push(line);
                        }
                        if (_emplaceAt) {
                            this.declarations.splice(_emplaceAt, 0, ...lines);
                        } else {
                            this.declarations.push(...lines);
                        }
                        node.componentsChanged = false;
                    }
                }
            };
            this.uniformNodes = [];
        }
    }
    // User function helpers
    function makeDependencyObject(dep) {
        if (isVectorType(dep)) {
            return {
                node: dep,
                isVector: true,
                originalComponents: [
                    ...dep.componentNames.map((name)=>dep[name])
                ],
                get currentComponents () {
                    return dep.componentNames.map((name)=>dep[name]);
                }
            };
        } else {
            return {
                node: dep,
                isVector: false
            };
        }
    }
    function makeDependencyArray(dependencies) {
        return dependencies.map((dep)=>makeDependencyObject(dep));
    }
    function conformVectorParameters(value, vectorDimensions) {
        // Allow arguments as arrays or otherwise. The following are all equivalent:
        // ([0,0,0,0]) (0,0,0,0) (0) ([0])
        if (!Array.isArray(value)) {
            value = [
                value
            ];
        }
        value = value.flat();
        value = value.map((val1)=>{
            if (isVectorType(val1)) {
                const componentArray = val1.componentNames.map((comp)=>val1[comp]);
                return componentArray;
            } else {
                return val1;
            }
        }).flat();
        // Populate arguments so uniformVector3(0) becomes [0,0,0]
        if (value.length === 1 && !isVectorNode(value[0])) {
            value = Array(vectorDimensions).fill(value[0]);
        }
        return value;
    }
    function swizzleTrap(size) {
        const swizzleSets = [
            [
                'x',
                'y',
                'z',
                'w'
            ],
            [
                'r',
                'g',
                'b',
                'a'
            ],
            [
                's',
                't',
                'p',
                'q'
            ]
        ].map((s)=>s.slice(0, size));
        return {
            get (target, property, receiver) {
                if (property in target) {
                    return Reflect.get(...arguments);
                } else {
                    for (const set of swizzleSets){
                        if ([
                            ...property
                        ].every((char)=>set.includes(char))) {
                            if (property.length === 1) {
                                return target[swizzleSets[0][set.indexOf(property[0])]];
                            }
                            const components = [
                                ...property
                            ].map((char)=>{
                                const index = set.indexOf(char);
                                const mappedChar = swizzleSets[0][index];
                                return target[mappedChar];
                            });
                            const type = `vec${property.length}`;
                            return nodeConstructors[type](components);
                        }
                    }
                }
            },
            set (target, property, value, receiver) {
                for (const set of swizzleSets){
                    const propertyCharArray = [
                        ...property
                    ];
                    if (propertyCharArray.every((char)=>set.includes(char))) {
                        const newValues = Array.isArray(value) ? value : Array(property.length).fill(value);
                        propertyCharArray.forEach((char, i)=>{
                            const index = set.indexOf(char);
                            const realProperty = swizzleSets[0][index];
                            Reflect.set(target, realProperty, newValues[i], receiver);
                        });
                        return true;
                    }
                }
                return Reflect.set(...arguments);
            }
        };
    }
    // User functions
    fn.If = function(condition, branch) {
        return new ConditionalNode(condition, branch);
    };
    fn.instanceID = function() {
        return variableConstructor('gl_InstanceID', 'int');
    };
    fn.getTexture = function(...userArgs) {
        const props = {
            args: [
                'sampler2D',
                'vec2'
            ],
            returnType: 'vec4',
            isp5Function: true
        };
        return fnNodeConstructor('getTexture', userArgs, props);
    };
    // Generating uniformFloat, uniformVec, createFloat, etc functions
    // Maps a GLSL type to the name suffix for method names
    const GLSLTypesToIdentifiers = {
        int: 'Int',
        float: 'Float',
        vec2: 'Vector2',
        vec3: 'Vector3',
        vec4: 'Vector4',
        sampler2D: 'Texture'
    };
    function dynamicAddSwizzleTrap(node, _size) {
        if (node.type.startsWith('vec') || _size) {
            const size = parseInt(node.type.slice(3));
            node = new Proxy(node, swizzleTrap(size));
            node.addVectorComponents();
        }
        return node;
    }
    function binaryExpressionNodeConstructor(a, b, operator, isInternal) {
        let node;
        if (operator === '%') {
            node = new ModulusNode(a, b);
        } else {
            node = new BinaryExpressionNode(a, b, operator, isInternal);
        }
        return dynamicAddSwizzleTrap(node);
    }
    function variableConstructor(name, type, isInternal) {
        const node = new VariableNode(name, type, isInternal);
        return dynamicAddSwizzleTrap(node);
    }
    function fnNodeConstructor(name, userArgs, properties, isInternal) {
        let node = new FunctionCallNode(name, userArgs, properties, isInternal);
        node = dynamicAddSwizzleTrap(node);
        node.dependsOn = makeDependencyArray(node.args);
        const dependsOnConditionals = node.args.map((arg)=>{
            const conditionals = arg.usedIn.filter((n)=>isConditionalNode(n)).map((c)=>{
                if (c instanceof BranchNode) {
                    return c.parent;
                } else {
                    return c;
                }
            });
            return conditionals;
        }).flat();
        dependsOnConditionals.forEach((conditional)=>conditional.usedIn.push(node));
        return node;
    }
    const nodeConstructors = {
        int: (value)=>new IntNode(value),
        float: (value)=>new FloatNode(value),
        vec2: (value)=>dynamicAddSwizzleTrap(new VectorNode(value, 'vec2')),
        vec3: (value)=>dynamicAddSwizzleTrap(new VectorNode(value, 'vec3')),
        vec4: (value)=>dynamicAddSwizzleTrap(new VectorNode(value, 'vec4')),
        dynamicVector: function(value) {
            const size = computeVectorLength(value);
            return this[`vec${size}`](value);
        }
    };
    for(const glslType in GLSLTypesToIdentifiers){
        // Generate uniform*() Methods for creating uniforms
        const typeIdentifier = GLSLTypesToIdentifiers[glslType];
        const uniformMethodName = `uniform${typeIdentifier}`;
        ShaderGenerator.prototype[uniformMethodName] = function(...args) {
            let [name, ...defaultValue] = args;
            if (glslType.startsWith('vec') && !(defaultValue[0] instanceof Function)) {
                defaultValue = conformVectorParameters(defaultValue, parseInt(glslType.slice(3)));
                this.output.uniforms[`${glslType} ${name}`] = defaultValue;
            } else {
                this.output.uniforms[`${glslType} ${name}`] = defaultValue[0];
            }
            const uniform = variableConstructor(name, glslType, false);
            this.uniformNodes.push(uniform);
            return uniform;
        };
        fn[uniformMethodName] = function(...args) {
            return GLOBAL_SHADER[uniformMethodName](...args);
        };
        // We don't need a texture creation method.
        if (glslType === 'sampler2D') {
            continue;
        }
        const varyingMethodName = `varying${typeIdentifier}`;
        ShaderGenerator.prototype[varyingMethodName] = function(name) {
            return dynamicAddSwizzleTrap(new VaryingNode(name, glslType, false));
        };
        fn[varyingMethodName] = function(name) {
            return GLOBAL_SHADER[varyingMethodName](name);
        };
        // Generate the creation methods for creating variables in shaders
        const originalFn = fn[glslType];
        fn[glslType] = function(...value) {
            if (GLOBAL_SHADER?.isGenerating) {
                if (glslType.startsWith('vec')) {
                    value = conformVectorParameters(value, parseInt(glslType.slice(3)));
                } else {
                    value = value[0];
                }
                return nodeConstructors[glslType](value);
            } else if (originalFn) {
                return originalFn.apply(this, value);
            } else {
                p51._friendlyError(`It looks like you've called ${glslType} outside of a shader's modify() function.`);
            }
        };
    }
    // GLSL Built in functions
    // Add a whole lot of these functions.
    // https://docs.gl/el3/abs
    const builtInGLSLFunctions = {
        //////////// Trigonometry //////////
        'acos': {
            args: [
                'genType'
            ],
            returnType: 'genType',
            isp5Function: true
        },
        'acosh': {
            args: [
                'genType'
            ],
            returnType: 'genType',
            isp5Function: false
        },
        'asin': {
            args: [
                'genType'
            ],
            returnType: 'genType',
            isp5Function: true
        },
        'asinh': {
            args: [
                'genType'
            ],
            returnType: 'genType',
            isp5Function: false
        },
        'atan': [
            {
                args: [
                    'genType'
                ],
                returnType: 'genType',
                isp5Function: false
            },
            {
                args: [
                    'genType',
                    'genType'
                ],
                returnType: 'genType',
                isp5Function: false
            }
        ],
        'atanh': {
            args: [
                'genType'
            ],
            returnType: 'genType',
            isp5Function: false
        },
        'cos': {
            args: [
                'genType'
            ],
            returnType: 'genType',
            isp5Function: true
        },
        'cosh': {
            args: [
                'genType'
            ],
            returnType: 'genType',
            isp5Function: false
        },
        'degrees': {
            args: [
                'genType'
            ],
            returnType: 'genType',
            isp5Function: true
        },
        'radians': {
            args: [
                'genType'
            ],
            returnType: 'genType',
            isp5Function: true
        },
        'sin': {
            args: [
                'genType'
            ],
            returnType: 'genType',
            isp5Function: true
        },
        'sinh': {
            args: [
                'genType'
            ],
            returnType: 'genType',
            isp5Function: false
        },
        'tan': {
            args: [
                'genType'
            ],
            returnType: 'genType',
            isp5Function: true
        },
        'tanh': {
            args: [
                'genType'
            ],
            returnType: 'genType',
            isp5Function: false
        },
        ////////// Mathematics //////////
        'abs': {
            args: [
                'genType'
            ],
            returnType: 'genType',
            isp5Function: true
        },
        'ceil': {
            args: [
                'genType'
            ],
            returnType: 'genType',
            isp5Function: true
        },
        'clamp': {
            args: [
                'genType',
                'genType',
                'genType'
            ],
            returnType: 'genType',
            isp5Function: false
        },
        'dFdx': {
            args: [
                'genType'
            ],
            returnType: 'genType',
            isp5Function: false
        },
        'dFdy': {
            args: [
                'genType'
            ],
            returnType: 'genType',
            isp5Function: false
        },
        'exp': {
            args: [
                'genType'
            ],
            returnType: 'genType',
            isp5Function: true
        },
        'exp2': {
            args: [
                'genType'
            ],
            returnType: 'genType',
            isp5Function: false
        },
        'floor': {
            args: [
                'genType'
            ],
            returnType: 'genType',
            isp5Function: true
        },
        'fma': {
            args: [
                'genType',
                'genType',
                'genType'
            ],
            returnType: 'genType',
            isp5Function: false
        },
        'fract': {
            args: [
                'genType'
            ],
            returnType: 'genType',
            isp5Function: true
        },
        'fwidth': {
            args: [
                'genType'
            ],
            returnType: 'genType',
            isp5Function: false
        },
        'inversesqrt': {
            args: [
                'genType'
            ],
            returnType: 'genType',
            isp5Function: true
        },
        // 'isinf': {},
        // 'isnan': {},
        'log': {
            args: [
                'genType'
            ],
            returnType: 'genType',
            isp5Function: true
        },
        'log2': {
            args: [
                'genType'
            ],
            returnType: 'genType',
            isp5Function: false
        },
        'max': [
            {
                args: [
                    'genType',
                    'genType'
                ],
                returnType: 'genType',
                isp5Function: true
            },
            {
                args: [
                    'genType',
                    'float'
                ],
                returnType: 'genType',
                isp5Function: true
            }
        ],
        'min': [
            {
                args: [
                    'genType',
                    'genType'
                ],
                returnType: 'genType',
                isp5Function: true
            },
            {
                args: [
                    'genType',
                    'float'
                ],
                returnType: 'genType',
                isp5Function: true
            }
        ],
        'mix': [
            {
                args: [
                    'genType',
                    'genType',
                    'genType'
                ],
                returnType: 'genType',
                isp5Function: false
            },
            {
                args: [
                    'genType',
                    'genType',
                    'float'
                ],
                returnType: 'genType',
                isp5Function: false
            }
        ],
        // 'mod': {},
        // 'modf': {},
        'pow': {
            args: [
                'genType',
                'genType'
            ],
            returnType: 'genType',
            isp5Function: true
        },
        'round': {
            args: [
                'genType'
            ],
            returnType: 'genType',
            isp5Function: true
        },
        'roundEven': {
            args: [
                'genType'
            ],
            returnType: 'genType',
            isp5Function: false
        },
        // 'sign': {},
        'smoothstep': [
            {
                args: [
                    'genType',
                    'genType',
                    'genType'
                ],
                returnType: 'genType',
                isp5Function: false
            },
            {
                args: [
                    'float',
                    'float',
                    'genType'
                ],
                returnType: 'genType',
                isp5Function: false
            }
        ],
        'sqrt': {
            args: [
                'genType'
            ],
            returnType: 'genType',
            isp5Function: true
        },
        'step': {
            args: [
                'genType',
                'genType'
            ],
            returnType: 'genType',
            isp5Function: false
        },
        'trunc': {
            args: [
                'genType'
            ],
            returnType: 'genType',
            isp5Function: false
        },
        ////////// Vector //////////
        'cross': {
            args: [
                'vec3',
                'vec3'
            ],
            returnType: 'vec3',
            isp5Function: true
        },
        'distance': {
            args: [
                'genType',
                'genType'
            ],
            returnType: 'float',
            isp5Function: true
        },
        'dot': {
            args: [
                'genType',
                'genType'
            ],
            returnType: 'float',
            isp5Function: true
        },
        // 'equal': {},
        'faceforward': {
            args: [
                'genType',
                'genType',
                'genType'
            ],
            returnType: 'genType',
            isp5Function: false
        },
        'length': {
            args: [
                'genType'
            ],
            returnType: 'float',
            isp5Function: false
        },
        'normalize': {
            args: [
                'genType'
            ],
            returnType: 'genType',
            isp5Function: true
        },
        // 'notEqual': {},
        'reflect': {
            args: [
                'genType',
                'genType'
            ],
            returnType: 'genType',
            isp5Function: false
        },
        'refract': {
            args: [
                'genType',
                'genType',
                'float'
            ],
            returnType: 'genType',
            isp5Function: false
        },
        ////////// Texture sampling //////////
        'texture': {
            args: [
                'sampler2D',
                'vec2'
            ],
            returnType: 'vec4',
            isp5Function: true
        }
    };
    Object.entries(builtInGLSLFunctions).forEach(([functionName, properties])=>{
        const isp5Function = Array.isArray(properties) ? properties[0].isp5Function : properties.isp5Function;
        if (isp5Function) {
            const originalFn = fn[functionName];
            fn[functionName] = function(...args) {
                if (GLOBAL_SHADER?.isGenerating) {
                    return fnNodeConstructor(functionName, args, properties);
                } else {
                    return originalFn.apply(this, args);
                }
            };
        } else {
            fn[functionName] = function(...args) {
                if (GLOBAL_SHADER?.isGenerating) {
                    return new fnNodeConstructor(functionName, args, properties);
                } else {
                    p51._friendlyError(`It looks like you've called ${functionName} outside of a shader's modify() function.`);
                }
            };
        }
    });
}
if (typeof p5 !== 'undefined') {
    p5.registerAddon(shadergenerator);
}
;
}}),
"[project]/node_modules/p5/dist/webgl/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>webgl)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d2d$aAe5aq3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/rendering--aAe5aq3.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$interaction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/interaction.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$loading$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/loading.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$text$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/text.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$RenderBuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.RenderBuffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$Quat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.Quat.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Matrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Matrix.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Matrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Matrix.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.Geometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$DataArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.DataArray.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$ShaderGenerator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/ShaderGenerator.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$C$2d$g_eAdC$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/constants-C-g_eAdC.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$creating_reading$2d$D4AAKRbx$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/creating_reading-D4AAKRbx.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$color$2f$color_spaces$2f$hsb$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/color/color_spaces/hsb.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$dom$2f$p5$2e$Element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/dom/p5.Element.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$dom$2f$p5$2e$File$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/dom/p5.File.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$p5$2e$XML$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/p5.XML.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$CwAYZOC2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/p5.Renderer-CwAYZOC2.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$filters$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/filters.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Vector.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$custom_shapes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/custom_shapes.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$States$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/States.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/utilities.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$file$2d$saver$2f$FileSaver$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/file-saver/FileSaver.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$dom$2f$p5$2e$MediaElement$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/dom/p5.MediaElement.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$2d_primitives$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/2d_primitives.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$helpers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/helpers.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$attributes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/attributes.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$curves$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/curves.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$vertex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/vertex.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$color$2f$setting$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/color/setting.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$omggif$2f$omggif$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/omggif/omggif.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$csv$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/csv.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$gifenc$2f$dist$2f$gifenc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/gifenc/dist/gifenc.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$pixels$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/pixels.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$transform$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/transform.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$GeometryBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/GeometryBuilder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$Matrices$2f$Matrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/Matrices/Matrix.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$Matrices$2f$MatrixInterface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/Matrices/MatrixInterface.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$ShapeBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/ShapeBuilder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libtess$2f$libtess$2e$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libtess/libtess.min.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$GeometryBufferCache$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/GeometryBufferCache.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$const$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/const.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$trigonometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/trigonometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$p5$2e$Font$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/type/p5.Font.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$textCore$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/type/textCore.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$japont$2f$unicode$2d$range$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@japont/unicode-range/lib/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$unicodeRanges$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/type/unicodeRanges.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$lib$2f$Typr$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/type/lib/Typr.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pako$2f$dist$2f$pako$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pako/dist/pako.esm.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$davepagurek$2f$bezier$2d$path$2f$build$2f$bezier$2d$path$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@davepagurek/bezier-path/build/bezier-path.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$acorn$2f$dist$2f$acorn$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/acorn/dist/acorn.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$acorn$2d$walk$2f$dist$2f$walk$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/acorn-walk/dist/walk.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$escodegen$2f$escodegen$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/escodegen/escodegen.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
function webgl(p5) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d2d$aAe5aq3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["r"])(p5, p5.prototype);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d2d$aAe5aq3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["p"])(p5, p5.prototype);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$interaction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(p5, p5.prototype);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d2d$aAe5aq3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["l"])(p5, p5.prototype);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$loading$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(p5, p5.prototype);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d2d$aAe5aq3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["m"])(p5, p5.prototype);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$text$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(p5, p5.prototype);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$RenderBuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(p5, p5.prototype);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$Quat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(p5, p5.prototype);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Matrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"])(p5, p5.prototype);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$Geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(p5, p5.prototype);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d2d$aAe5aq3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c"])(p5, p5.prototype);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d2d$aAe5aq3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(p5, p5.prototype);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$DataArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(p5, p5.prototype);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d2d$aAe5aq3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["s"])(p5, p5.prototype);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d2d$aAe5aq3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["t"])(p5, p5.prototype);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$ShaderGenerator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(p5, p5.prototype);
}
;
}}),
}]);

//# sourceMappingURL=node_modules_p5_dist_webgl_3a3c5d0b._.js.map